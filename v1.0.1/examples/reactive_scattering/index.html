<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reactive scattering from a metal surface · NQCDynamics.jl</title><meta name="title" content="Reactive scattering from a metal surface · NQCDynamics.jl"/><meta property="og:title" content="Reactive scattering from a metal surface · NQCDynamics.jl"/><meta property="twitter:title" content="Reactive scattering from a metal surface · NQCDynamics.jl"/><meta name="description" content="Documentation for NQCDynamics.jl."/><meta property="og:description" content="Documentation for NQCDynamics.jl."/><meta property="twitter:description" content="Documentation for NQCDynamics.jl."/><meta property="og:url" content="https://nqcd.github.io/NQCDynamics.jl/stable/examples/reactive_scattering/"/><meta property="twitter:url" content="https://nqcd.github.io/NQCDynamics.jl/stable/examples/reactive_scattering/"/><link rel="canonical" href="https://nqcd.github.io/NQCDynamics.jl/stable/examples/reactive_scattering/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="NQCDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NQCDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../getting_started/">Getting started</a></li><li><a class="tocitem" href="../../atoms/">Atoms</a></li><li><a class="tocitem" href="../../ensemble_simulations/">Ensemble simulations</a></li><li><a class="tocitem" href="../../saving_loading/">Saving and loading</a></li><li><span class="tocitem">NQCModels.jl</span><ul><li><a class="tocitem" href="../../NQCModels/overview/">NQCModels.jl</a></li><li><a class="tocitem" href="../../NQCModels/combining_models/">Composing multiple models</a></li><li><a class="tocitem" href="../../NQCModels/analyticmodels/">Analytic model library</a></li><li><a class="tocitem" href="../../NQCModels/machinelearningmodels/">Machine learning interatomic potentials</a></li><li><a class="tocitem" href="../../NQCModels/fullsizemodels/">Full dimensional model library</a></li><li><a class="tocitem" href="../../NQCModels/frictionmodels/">Electronic friction models</a></li><li><a class="tocitem" href="../../NQCModels/systembathmodels/">System-bath models</a></li></ul></li><li><span class="tocitem">NQCCalculators.jl</span><ul><li><a class="tocitem" href="../../NQCCalculators/overview/">NQCCalculators.jl</a></li></ul></li><li><span class="tocitem">NQCDistributions.jl</span><ul><li><a class="tocitem" href="../../NQCDistributions/overview/">NQCDistributions.jl</a></li></ul></li><li><span class="tocitem">Initial conditions</span><ul><li><a class="tocitem" href="../../initialconditions/ebk/">Semiclassical EBK quantisation</a></li><li><a class="tocitem" href="../../initialconditions/hamiltonian/">Thermal Hamiltonian Monte Carlo</a></li><li><a class="tocitem" href="../../initialconditions/langevin/">Thermal Langevin dynamics</a></li><li><a class="tocitem" href="../../initialconditions/metropolishastings/">Thermal Metropolis-Hastings Monte Carlo</a></li></ul></li><li><span class="tocitem">Dynamics simulations</span><ul><li><a class="tocitem" href="../../dynamicssimulations/dynamicssimulations/">Introduction</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/classical/">Classical molecular dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/ehrenfest/">Ehrenfest molecular dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/fssh/">Fewest-switches surface hopping (FSSH)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/iesh/">Independent electron surface hopping (IESH)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/langevin/">Classical Langevin dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/mdef/">Molecular dynamics with electronic friction (MDEF)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/nrpmd/">Nonadiabatic ring polymer molecular dynamics (NRPMD)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/rpmd/">Ring polymer molecular dynamics (RPMD)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/rpsh/">Ring polymer surface hopping (RPSH)</a></li></ul></li><li><span class="tocitem">Outputs and Analysis</span><ul><li><a class="tocitem" href="../../output_and_analysis/intro/">Simulations outputs and analysis functions</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Reactive scattering from a metal surface</a><ul class="internal"><li><a class="tocitem" href="#Data-analysis-and-truncation-function"><span>Data analysis and truncation function</span></a></li><li><a class="tocitem" href="#MDEF-with-the-LDFA"><span>MDEF with the LDFA</span></a></li><li><a class="tocitem" href="#MDEF-with-machine-learned-LDFA"><span>MDEF with machine-learned LDFA</span></a></li><li><a class="tocitem" href="#MDEF-with-machine-learned-TDPT-(ODF)"><span>MDEF with machine-learned TDPT (ODF)</span></a></li><li><a class="tocitem" href="#Visualisation"><span>Visualisation</span></a></li></ul></li><li><a class="tocitem" href="../spinboson/">Ohmic spin-boson nonequilibrium population dynamics</a></li><li><a class="tocitem" href="../threestatemorse/">Time-dependent populations with the ThreeStateMorse model</a></li><li><a class="tocitem" href="../tully_scattering/">Scattering probabilities for TullyModelTwo</a></li></ul></li><li><a class="tocitem" href="../../NQCRecipes/overview/">NQCRecipes</a></li><li><a class="tocitem" href="../../integration_algorithms/">Integration algorithms</a></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../../devdocs/diffeq/">DifferentialEquations.jl integration</a></li><li><a class="tocitem" href="../../devdocs/models/">Implementing a new model</a></li><li><a class="tocitem" href="../../devdocs/new_methods/">Contributing a new method</a></li></ul></li><li><span class="tocitem">API</span><ul><li><input class="collapse-toggle" id="menuitem-16-1" type="checkbox"/><label class="tocitem" for="menuitem-16-1"><span class="docs-label">NQCBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCBase/nqcbase/">NQCBase</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-2" type="checkbox"/><label class="tocitem" for="menuitem-16-2"><span class="docs-label">NQCModels</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCModels/FrictionProviders/">FrictionModels</a></li><li><a class="tocitem" href="../../api/NQCModels/adiabaticmodels/">ClassicalModels</a></li><li><a class="tocitem" href="../../api/NQCModels/bathdiscretisations/">BathDiscretisations</a></li><li><a class="tocitem" href="../../api/NQCModels/diabaticmodels/">QuantumModels</a></li><li><a class="tocitem" href="../../api/NQCModels/frictionmodels/">FrictionProviders.jl</a></li><li><a class="tocitem" href="../../api/NQCModels/mace/">MACEModels.jl</a></li><li><a class="tocitem" href="../../api/NQCModels/nonadiabaticmodels/">NQCModels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-3" type="checkbox"/><label class="tocitem" for="menuitem-16-3"><span class="docs-label">NQCDistributions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCDistributions/nqcdistributions/">NQCDistributions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-4" type="checkbox"/><label class="tocitem" for="menuitem-16-4"><span class="docs-label">NQCDynamics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCDynamics/analysis/">Analysis</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsmethods/">DynamicsMethods</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsoutputs/">DynamicsOutputs</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsutils/">DynamicsUtils</a></li><li><a class="tocitem" href="../../api/NQCDynamics/ensembles/">Ensembles</a></li><li><a class="tocitem" href="../../api/NQCDynamics/estimators/">Estimators</a></li><li><a class="tocitem" href="../../api/NQCDynamics/initialconditions/">InitialConditions</a></li><li><a class="tocitem" href="../../api/NQCDynamics/nonadiabaticmoleculardynamics/">NQCDynamics</a></li><li><a class="tocitem" href="../../api/NQCDynamics/numericutils/">Numerical utilities</a></li><li><a class="tocitem" href="../../api/NQCDynamics/ringpolymers/">RingPolymers</a></li><li><a class="tocitem" href="../../api/NQCDynamics/structure/">Structure</a></li><li><a class="tocitem" href="../../api/NQCDynamics/timecorrelationfunctions/">TimeCorrelationFunctions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-5" type="checkbox"/><label class="tocitem" for="menuitem-16-5"><span class="docs-label">NQCCalculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCCalculators/nqccalculators/">NQCCalculators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-6" type="checkbox"/><label class="tocitem" for="menuitem-16-6"><span class="docs-label">NQCDInterfASE</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCDInterfASE/ase-interface/">NQCDInterfASE</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-7" type="checkbox"/><label class="tocitem" for="menuitem-16-7"><span class="docs-label">RingPolymerArrays</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/RingPolymerArrays/ringpolymerarrays/">RingPolymerArrays</a></li></ul></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Reactive scattering from a metal surface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reactive scattering from a metal surface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NQCD/NQCDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NQCD/NQCDynamics.jl/blob/main/docs/src/examples/reactive_scattering.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="example-h2scattering"><a class="docs-heading-anchor" href="#example-h2scattering">Reactive scattering from a metal surface</a><a id="example-h2scattering-1"></a><a class="docs-heading-anchor-permalink" href="#example-h2scattering" title="Permalink"></a></h1><p>Our implementation allows us to simulate vibrational (de-)excitation probability during reactive  scattering events at metal surfaces for any diatomic molecule with a suitable model to describe  energies and forces (and friction coefficients for MDEF simulations). Here, we investigate the reactive scattering of hydrogen on a Cu(111) metal surface as a  prototypical example and we employ machine learning models for potential energy surface (MLIP)  and electronic friction tensor (EFT).</p><p>To run this kind of simulation, a set of initial positions and velocities (<span>$\mathbf{R}$</span> and <span>$\mathbf{\dot{R}}$</span>) with ro-vibrational quantum states <span>$\nu$</span> and <span>$j$</span> have to be generated (see <a href="../../initialconditions/ebk/#ebk-sampling">EBK quantisation</a>). With a specific ro-vibrational quantum state it is possible to compute different properties after molecular  collision and energy transfer with the metal surface like the vibrational de-excitation probabilities discussed here. </p><p>To reproduce the state-to-state vibrational de-excitation probability results presented by [<a href="../../references/#Stark2025">27</a>] for  this system, the same initial conditions can be generated with <a href="../../api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.generate_configurations-Tuple{Any, Any, Any}"><code>QuantisedDiatomic.generate_configurations</code></a> setting the initial ro-vibrational quantum state to (<span>$\nu=2, j=1$</span>) as was explored in the original paper. </p><p>As shown earlier in the <a href="../../initialconditions/ebk/#ebk-sampling">EBK documentation</a> we are able to generate a semiclassically  quantised distribution for a diatomic molecule on a collision course with a metal surface. In this example we follow the <a href="../../initialconditions/ebk/#ebk-sampling">EBK example</a> using <a href="../../NQCModels/machinelearningmodels/#ml-pes-models"><code>machine learning potential</code></a>  to prepare our initial distribution and run our simulation.</p><p>Specifically, we have produced a set of initial conditions with different translational energy (<code>translational_energy</code> keyword)  ranging from 0.04 to 0.4 eV, locating the hydrogen molecule 7 Å away from the metal surface (<code>height</code> keyword) with a normal incidence.</p><div class="admonition is-info" id="Atomic-units-3395b33a2064e8b1"><header class="admonition-header">Atomic units<a class="admonition-anchor" href="#Atomic-units-3395b33a2064e8b1" title="Permalink"></a></header><div class="admonition-body"><p>As usual, all quantities default to atomic units. Here we use <a href="https://painterqubits.github.io/Unitful.jl/stable/">Unitful</a> to input the translational energy and height using different units, where they are later converted internally.</p></div></div><pre><code class="language-julia hljs">using NQCDynamics
using NQCDInterfASE
using Unitful
using NQCDynamics.InitialConditions: QuantisedDiatomic
using JLD2
using PythonCall

mace_calc = pyimport(&quot;mace.calculators&quot;)
io = pyimport(&quot;ase.io&quot;)
ase_units = pyimport(&quot;ase.units&quot;)

function mace_model(model_path, cur_atoms)
    calculator = mace_calc.MACECalculator(model_path=model_path, device=&quot;cpu&quot;, default_dtype=&quot;float32&quot;) # or &quot;cuda&quot;
    cur_atoms.set_calculator(calculator)
    model = ClassicalASEModel(cur_atoms)

    return model
end

model_path = &quot;h2cu.model&quot;
surface_structures_path = &quot;surf_structures.xyz&quot;

# settings
ν, J = 2, 1     # selected ro-vibrational quantum states  
nsamples = 10  # number of configurations      
Ek = 0.3u&quot;eV&quot;   # Translational energy [eV] ; range considered [0.0-0.4] eV
z = 7.0u&quot;Å&quot;     # Height [Å]  ; fixed at 7 Å
z = ang_to_au(z)
dof = 3

# Read surface structures (equilibrated at chosen temperature)
surface_ase = ase_io.read(surface_structures_path)
xatoms, xpositions, xcell = NQCDynamics.convert_from_ase_atoms(surface_ase[0])
set_periodicity!(xcell,[true,true,true])

# load PES model
model_pes = mace_model(model_path, atoms_path)
# set simulation
sim = Simulation(NQCDynamics.Atoms([:H,:H]), model_pes; cell=xcell)

configurations = QuantisedDiatomic.generate_configurations(sim, ν, J;
    samples=nsamples, 
    translational_energy=Ek, 
    height=z
)
v_h2 = first.(configurations)
r_h2 = last.(configurations)


# Re build the position and velocities for the whole system Cu56H2
n_atoms = length(atoms)
v = [zeros(dof,n_atoms) for i=1:length(r_h2)]
r = [zeros(dof,n_atoms) for i=1:length(r_h2)]

for i in 1:length(r_h2)
    surf_atoms, surf_positions, surf_cell = convert_from_ase_atoms(surface_ase[i])
    r[i][:,1:n_atoms-2] .= surf_positions
    r[i][:,n_atoms-1:n_atoms] .= r_h2[i]  

    v[i][:,1:n_atoms-2] .= austrip.(transpose(surface_ase[i].get_velocities().*ase_units.fs)*u&quot;Å/fs&quot;)
    v[i][:,n_atoms-1:n_atoms] .= v_h2[i]
end


distribution = DynamicalDistribution(v, r, (dof,length(surface_ase[0])+2))
nothing # hide</code></pre><div class="admonition is-success" id="Saving-the-distribution-4f560b8020864973"><header class="admonition-header">Saving the distribution<a class="admonition-anchor" href="#Saving-the-distribution-4f560b8020864973" title="Permalink"></a></header><div class="admonition-body"><p>Generally it will be desirable to generate a distribution once and re-use it for multiple dynamics simulations. The simplest way to do this is to save the distribution using <a href="https://juliaio.github.io/JLD2.jl/dev/">JLD2.jl</a>. Refer to <a href="../../saving_loading/#saving-and-loading">Saving and loading</a> to learn more.</p></div></div><p>In order to produce an unweighted distribution, the lateral and angular orientation are randomly selected within the unit cell. As an example of the spacial and orientation distribution generated with this module, a subset of data (300 configurations) is shown below. To run our production simulations, however, a set of 80,000 initial velocities and positions were used.</p><p><img src="../../assets/figures/icond_scatter.png" alt="initial conditions"/></p><h2 id="Data-analysis-and-truncation-function"><a class="docs-heading-anchor" href="#Data-analysis-and-truncation-function">Data analysis and truncation function</a><a id="Data-analysis-and-truncation-function-1"></a><a class="docs-heading-anchor-permalink" href="#Data-analysis-and-truncation-function" title="Permalink"></a></h2><p>Since we are interested in the dynamics only when the molecule is close to the surface, we can use a callback to terminate the simulation early to save us some time. This requires defining a function that returns <code>true</code> when we want the simulation to terminate. This means we can set our time span relatively long since we expect most simulations to terminate before reaching the time limit.</p><pre><code class="language-julia hljs">using Statistics: mean
using LinearAlgebra: norm

h2distance(p) = norm(p[:,ids_adsorbate[1]] .- p[:,ids_adsorbate[2]])

&quot;Terminates simulation if returns `true`.&quot; 
mutable struct TrajectoryTerminator
    h2_indices
    ads_height_cutoff
    ads_dist_cutoff
    n_atoms_layer
end
function (t::TrajectoryTerminator)(u, t, integrator)::Bool
    R = get_positions(u)
    com_h2_z = minimum(R[3,t.h2_indices[1]:t.h2_indices[2]])
    top_surface_avg_z = mean(R[3,end-Int(t.n_atoms_layer)-1:end-2])
    zcom = au_to_ang(com_h2_z-top_surface_avg_z) # Convert vertical centre of mass to angstrom
    if zcom &gt; t.ads_height_cutoff                         # Scattering event
        return true
    elseif au_to_ang(h2distance(R)) &gt; t.ads_dist_cutoff   # Reactive event
        return true
    else
        return false
    end
end

termination_condition = TrajectoryTerminator(ids_adsorbate, 7.2, 2.25, 9)
terminate = DynamicsUtils.TerminatingCallback(termination_condition)
tspan = (0.0, 420.0u&quot;fs&quot;)
nothing # hide</code></pre><p>In this example, we consider the outcome a reactive event if the H-H bond length is larger than 2.5 Å in any point of during the trajectory and a scattering event if the molecule rebounds to a vertical distance from the metal surface greater than 8.1 Å.</p><h2 id="MDEF-with-the-LDFA"><a class="docs-heading-anchor" href="#MDEF-with-the-LDFA">MDEF with the LDFA</a><a id="MDEF-with-the-LDFA-1"></a><a class="docs-heading-anchor-permalink" href="#MDEF-with-the-LDFA" title="Permalink"></a></h2><p>Now that we have set up the initial distribution and some of our simulation parameters, we can choose which form of friction we would like use. First, let&#39;s use the cube-based density implementation for LDFA friction provided by the <a href="../../NQCModels/frictionmodels/#friction-providers">FrictionProviders.jl</a>. This takes a <code>.cube</code> file containing the electron density and will provide the friction during the dynamics. Here we initialize the MACE-based interatomic potential, together with the cube-based calculator.</p><pre><code class="language-julia hljs">
# load cube EFT calculator
using FrictionProviders
density_model = CubeLDFA(&quot;path_to_cube.cube&quot;, cell)
model_eft = LDFAFriction(density_model, atoms; friction_atoms=ids_adsorbate)</code></pre><p>Now we can pass all the variables defined so far to the <code>Simulation</code> and run multiple trajectories using <a href="../../ensemble_simulations/#NQCDynamics.Ensembles.run_dynamics"><code>run_dynamics</code></a>.</p><pre><code class="language-julia hljs">model = CompositeFrictionModel(model_pes, model_eft)
sim = Simulation{MDEF}(atoms, model, cell=cell, temperature=300u&quot;K&quot;)
ensemble = run_dynamics(sim, tspan, distribution; selection=1:nsamples,
    dt=0.1u&quot;fs&quot;, output=OutputPosition, trajectories=nsamples, callback=terminate)</code></pre><h2 id="MDEF-with-machine-learned-LDFA"><a class="docs-heading-anchor" href="#MDEF-with-machine-learned-LDFA">MDEF with machine-learned LDFA</a><a id="MDEF-with-machine-learned-LDFA-1"></a><a class="docs-heading-anchor-permalink" href="#MDEF-with-machine-learned-LDFA" title="Permalink"></a></h2><p>Above, we used the cube-based LDFA interpretation of MDEF to perform the simulation. However, in this scheme, surface atoms have to stay fixed to match the cube densities. To include surface temperature effects machine learning models can be trained that predict densities at any surface configuration. Here, we run MDEF simulation employing two machine learning models, to predict adiabatic PES (based on <a href="https://github.com/ACEsuit/mace">MACE</a>) and surface electron density (based on <a href="https://github.com/ACEsuit/ACEpotentials.jl">ACEpotentials.jl</a>), utilizing <a href="https://github.com/NQCD/FrictionProviders.jl">FrictionProviders.jl</a>, to run MDEF simulation.</p><pre><code class="language-julia hljs">using ACEpotentials
ace_model, ace_model_meta = ACEpotentials.load_model(&quot;ace_ldfa_model_path.json&quot;)
density_model = AdiabaticModels.ACEpotentialsModel(atoms, cell, ace_model) 
ace_density_model = AceLDFA(density_model)
model_eft = LDFAFriction(ace_density_model, atoms; friction_atoms=ids_adsorbate)

model = CompositeFrictionModel(model_pes, model_eft)

sim = Simulation{MDEF}(atoms, model, cell=cell, temperature=300u&quot;K&quot;)
ensemble = run_dynamics(sim, tspan, distribution; selection=1:nsamples,
    dt=0.1u&quot;fs&quot;, output=OutputPosition, trajectories=nsamples, callback=terminate)</code></pre><h2 id="MDEF-with-machine-learned-TDPT-(ODF)"><a class="docs-heading-anchor" href="#MDEF-with-machine-learned-TDPT-(ODF)">MDEF with machine-learned TDPT (ODF)</a><a id="MDEF-with-machine-learned-TDPT-(ODF)-1"></a><a class="docs-heading-anchor-permalink" href="#MDEF-with-machine-learned-TDPT-(ODF)" title="Permalink"></a></h2><p>Above, we used the LDFA interpretation of MDEF to perform the simulation. However, an alternative, TDPT (otherwise known as ODF) method can be used that provides full friction tensor. TDPT ML models can be incorporated in our simulation in a similar way as LDFA models, through <a href="https://github.com/NQCD/FrictionProviders.jl">FrictionProviders.jl</a>. Here, we show how this can be done for <a href="https://github.com/ACEsuit/ACEds.jl">ACEds</a> (<a href="https://github.com/ACEsuit/ACEfriction.jl">ACEfriction</a>) models. Such models require the usage of <a href="https://github.com/JuliaMolSim/JuLIP.jl">JuLIP</a>-type atoms. We can easily convert our ASE-type atoms into such format:</p><pre><code class="language-julia hljs">using ASE, JuLIP
atoms_ase_jl = ASE.ASEAtoms(atoms_ase)
atoms_julip = JuLIP.Atoms(atoms_ase_jl)</code></pre><p>Having our atoms, ACEds (ACEfriction) EFT models can be then initialized and combined with previously loaded potential model.</p><pre><code class="language-julia hljs">using ACE
using ACEds.FrictionModels
using ACEds.FrictionModels: Gamma
aceds_model = ACEdsODF(read_dict(load_dict(&quot;aceds_odf_model_path.model&quot;)), Gamma, atoms_julip)
model_eft = ODFriction(ace_model; friction_atoms=ids_adsorbate)

model = CompositeFrictionModel(model_pes, model_eft)

sim = Simulation{MDEF}(atoms, model, cell=cell, temperature=300u&quot;K&quot;)
ensemble = run_dynamics(sim, tspan, distribution; selection=1:nsamples,
    dt=0.1u&quot;fs&quot;, output=OutputPosition, trajectories=nsamples, callback=terminate)</code></pre><h2 id="Visualisation"><a class="docs-heading-anchor" href="#Visualisation">Visualisation</a><a id="Visualisation-1"></a><a class="docs-heading-anchor-permalink" href="#Visualisation" title="Permalink"></a></h2><p>To show the effect of the truncation procedure, we have run 20 trajectories with and without the truncation function starting with an initial translation energy at 1.0 eV. For both figures, the total and kinetic energies are shown in the top panels along with the H-H distance and centre of mass z coordinate for each individual trajectory.</p><p><img src="../../assets/figures/scattering_truncation.png" alt="truncation"/></p><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../output_and_analysis/intro/">« Simulations outputs and analysis functions</a><a class="docs-footer-nextpage" href="../spinboson/">Ohmic spin-boson nonequilibrium population dynamics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 23 July 2025 22:30">Wednesday 23 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
