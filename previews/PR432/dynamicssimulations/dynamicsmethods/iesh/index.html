<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Independent electron surface hopping (IESH) · NQCDynamics.jl</title><meta name="title" content="Independent electron surface hopping (IESH) · NQCDynamics.jl"/><meta property="og:title" content="Independent electron surface hopping (IESH) · NQCDynamics.jl"/><meta property="twitter:title" content="Independent electron surface hopping (IESH) · NQCDynamics.jl"/><meta name="description" content="Documentation for NQCDynamics.jl."/><meta property="og:description" content="Documentation for NQCDynamics.jl."/><meta property="twitter:description" content="Documentation for NQCDynamics.jl."/><meta property="og:url" content="https://nqcd.github.io/NQCDynamics.jl/stable/dynamicssimulations/dynamicsmethods/iesh/"/><meta property="twitter:url" content="https://nqcd.github.io/NQCDynamics.jl/stable/dynamicssimulations/dynamicsmethods/iesh/"/><link rel="canonical" href="https://nqcd.github.io/NQCDynamics.jl/stable/dynamicssimulations/dynamicsmethods/iesh/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.svg" alt="NQCDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">NQCDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Introduction</a></li><li><a class="tocitem" href="../../../getting_started/">Getting started</a></li><li><a class="tocitem" href="../../../atoms/">Atoms</a></li><li><a class="tocitem" href="../../../ensemble_simulations/">Ensemble simulations</a></li><li><a class="tocitem" href="../../../saving_loading/">Saving and loading</a></li><li><span class="tocitem">NQCModels.jl</span><ul><li><a class="tocitem" href="../../../NQCModels/overview/">NQCModels.jl</a></li><li><a class="tocitem" href="../../../NQCModels/combining_models/">Composing multiple models</a></li><li><a class="tocitem" href="../../../NQCModels/analyticmodels/">Analytic model library</a></li><li><a class="tocitem" href="../../../NQCModels/machinelearningmodels/">Machine learning interatomic potentials</a></li><li><a class="tocitem" href="../../../NQCModels/fullsizemodels/">Full dimensional model library</a></li><li><a class="tocitem" href="../../../NQCModels/frictionmodels/">Electronic friction models</a></li><li><a class="tocitem" href="../../../NQCModels/systembathmodels/">System-bath models</a></li></ul></li><li><span class="tocitem">NQCCalculators.jl</span><ul><li><a class="tocitem" href="../../../NQCCalculators/overview/">NQCCalculators.jl</a></li></ul></li><li><span class="tocitem">NQCDistributions.jl</span><ul><li><a class="tocitem" href="../../../NQCDistributions/overview/">NQCDistributions.jl</a></li></ul></li><li><span class="tocitem">Initial conditions</span><ul><li><a class="tocitem" href="../../../initialconditions/ebk/">Semiclassical EBK quantisation</a></li><li><a class="tocitem" href="../../../initialconditions/hamiltonian/">Thermal Hamiltonian Monte Carlo</a></li><li><a class="tocitem" href="../../../initialconditions/langevin/">Thermal Langevin dynamics</a></li><li><a class="tocitem" href="../../../initialconditions/metropolishastings/">Thermal Metropolis-Hastings Monte Carlo</a></li></ul></li><li><span class="tocitem">Dynamics simulations</span><ul><li><a class="tocitem" href="../../dynamicssimulations/">Introduction</a></li><li><a class="tocitem" href="../classical/">Classical molecular dynamics</a></li><li><a class="tocitem" href="../ehrenfest/">Ehrenfest molecular dynamics</a></li><li><a class="tocitem" href="../fssh/">Fewest-switches surface hopping (FSSH)</a></li><li class="is-active"><a class="tocitem" href>Independent electron surface hopping (IESH)</a><ul class="internal"><li><a class="tocitem" href="#Algorithm"><span>Algorithm</span></a></li><li><a class="tocitem" href="#Interfacing-with-the-AndersonHolstein-model"><span>Interfacing with the <code>AndersonHolstein</code> model</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="../langevin/">Classical Langevin dynamics</a></li><li><a class="tocitem" href="../mdef/">Molecular dynamics with electronic friction (MDEF)</a></li><li><a class="tocitem" href="../nrpmd/">Nonadiabatic ring polymer molecular dynamics (NRPMD)</a></li><li><a class="tocitem" href="../rpmd/">Ring polymer molecular dynamics (RPMD)</a></li><li><a class="tocitem" href="../rpsh/">Ring polymer surface hopping (RPSH)</a></li></ul></li><li><span class="tocitem">Outputs and Analysis</span><ul><li><a class="tocitem" href="../../../output_and_analysis/intro/">Simulations outputs and analysis functions</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../../examples/reactive_scattering/">Reactive scattering from a metal surface</a></li><li><a class="tocitem" href="../../../examples/spinboson/">Ohmic spin-boson nonequilibrium population dynamics</a></li><li><a class="tocitem" href="../../../examples/threestatemorse/">Time-dependent populations with the ThreeStateMorse model</a></li><li><a class="tocitem" href="../../../examples/tully_scattering/">Scattering probabilities for TullyModelTwo</a></li></ul></li><li><a class="tocitem" href="../../../NQCRecipes/overview/">NQCRecipes</a></li><li><a class="tocitem" href="../../../integration_algorithms/">Integration algorithms</a></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../../../devdocs/diffeq/">DifferentialEquations.jl integration</a></li><li><a class="tocitem" href="../../../devdocs/models/">Implementing a new model</a></li><li><a class="tocitem" href="../../../devdocs/new_methods/">Contributing a new method</a></li></ul></li><li><span class="tocitem">API</span><ul><li><input class="collapse-toggle" id="menuitem-16-1" type="checkbox"/><label class="tocitem" for="menuitem-16-1"><span class="docs-label">NQCBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../api/NQCBase/nqcbase/">NQCBase</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-2" type="checkbox"/><label class="tocitem" for="menuitem-16-2"><span class="docs-label">NQCModels</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../api/NQCModels/FrictionProviders/">FrictionModels</a></li><li><a class="tocitem" href="../../../api/NQCModels/adiabaticmodels/">ClassicalModels</a></li><li><a class="tocitem" href="../../../api/NQCModels/bathdiscretisations/">BathDiscretisations</a></li><li><a class="tocitem" href="../../../api/NQCModels/diabaticmodels/">QuantumModels</a></li><li><a class="tocitem" href="../../../api/NQCModels/frictionmodels/">FrictionProviders.jl</a></li><li><a class="tocitem" href="../../../api/NQCModels/mace/">MACEModels.jl</a></li><li><a class="tocitem" href="../../../api/NQCModels/nonadiabaticmodels/">NQCModels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-3" type="checkbox"/><label class="tocitem" for="menuitem-16-3"><span class="docs-label">NQCDistributions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../api/NQCDistributions/nqcdistributions/">NQCDistributions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-4" type="checkbox"/><label class="tocitem" for="menuitem-16-4"><span class="docs-label">NQCDynamics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../api/NQCDynamics/analysis/">Analysis</a></li><li><a class="tocitem" href="../../../api/NQCDynamics/dynamicsmethods/">DynamicsMethods</a></li><li><a class="tocitem" href="../../../api/NQCDynamics/dynamicsoutputs/">DynamicsOutputs</a></li><li><a class="tocitem" href="../../../api/NQCDynamics/dynamicsutils/">DynamicsUtils</a></li><li><a class="tocitem" href="../../../api/NQCDynamics/ensembles/">Ensembles</a></li><li><a class="tocitem" href="../../../api/NQCDynamics/estimators/">Estimators</a></li><li><a class="tocitem" href="../../../api/NQCDynamics/initialconditions/">InitialConditions</a></li><li><a class="tocitem" href="../../../api/NQCDynamics/nonadiabaticmoleculardynamics/">NQCDynamics</a></li><li><a class="tocitem" href="../../../api/NQCDynamics/numericutils/">Numerical utilities</a></li><li><a class="tocitem" href="../../../api/NQCDynamics/ringpolymers/">RingPolymers</a></li><li><a class="tocitem" href="../../../api/NQCDynamics/structure/">Structure</a></li><li><a class="tocitem" href="../../../api/NQCDynamics/timecorrelationfunctions/">TimeCorrelationFunctions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-5" type="checkbox"/><label class="tocitem" for="menuitem-16-5"><span class="docs-label">NQCCalculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../api/NQCCalculators/nqccalculators/">NQCCalculators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-6" type="checkbox"/><label class="tocitem" for="menuitem-16-6"><span class="docs-label">NQCDInterfASE</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../api/NQCDInterfASE/ase-interface/">NQCDInterfASE</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-7" type="checkbox"/><label class="tocitem" for="menuitem-16-7"><span class="docs-label">RingPolymerArrays</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../api/RingPolymerArrays/ringpolymerarrays/">RingPolymerArrays</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Dynamics simulations</a></li><li class="is-active"><a href>Independent electron surface hopping (IESH)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Independent electron surface hopping (IESH)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NQCD/NQCDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NQCD/NQCDynamics.jl/blob/main/docs/src/dynamicssimulations/dynamicsmethods/iesh.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="iesh-dynamics"><a class="docs-heading-anchor" href="#iesh-dynamics">Independent electron surface hopping (IESH)</a><a id="iesh-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#iesh-dynamics" title="Permalink"></a></h1><p>Independent electron surface hopping (IESH) ([<a href="../../../references/#Shenvi2009">8</a>][<a href="../../../references/#Gardner2023">9</a>]) is an extension of Tully&#39;s fewest-switches surface hopping (FSSH) [<a href="../../../references/#Tully1990">1</a>] that describes a single particle (single electronic state) interacting with a metal, represented as a bath of electronic states.</p><p>IESH is classified as a mixed-quantum-classical method, where the nuclei are treated classically and the electrons are treated quantum mechanically. Like FSSH and other such surface hopping methods, the nuclei evolve on a single adiabatic potential energy surface at any given moment. At each timestep, a hopping probability is evaluated. If the hopping probability is larger than a uniform random number between 0 and 1, the active state is switched and the adiabatic propagation continues on the new electronic state. When this algorithm is applied to an ensemble of trajectories, the discrete adiabatic state populations approximate the quantum mechanical populations for each state.</p><p>The key difference with IESH comes from the assumption that electrons in the systems are independent. This allows:</p><ol><li>the many-electron Hamiltonian of the system to be decomposed into a sum of single electron Hamiltonians <span>$\hat{H}_{el}^{1}(\mathbf{q})$</span>,</li><li>the many-electron wavefunction <span>$\ket{\Psi}$</span> can be fomrulated as a single slater determinant <span>$\ket{\psi_{1} \psi_{2} ... \psi_{N_{e}}}$</span></li></ol><p>The IESH classical Hamiltonian can be written as</p><p class="math-container">\[H_{\textrm{IESH}}(\mathbf{q}(t), \mathbf{p}) = \sum_{\alpha=1}^{N} \frac{p_{\alpha}^{2}}{2m_{\alpha}} + U_{0}(\mathbf{q}_{\alpha}(t)) + \sum_{k \in \mathbf{s}(t)} \lambda_{k} (\mathbf{q}_{\alpha}(t))\]</p><p>where <span>$\mathbf{p}$</span> is the vector of momenta, <span>$\mathbf{q}$</span> the positions and <span>$|\alpha$</span> denotes the nuclear degree of freedom. <span>$\mathbf{s}(t)$</span> is a binary vector that indicates the currently occupied adiabatic electronic states as a function of time As such, this Hamiltonian describes classical dynamics that proceeds under the influence of the model&#39;s ground state potential <span>$U_{0}(\mathbf{q}_{\alpha}(t))$</span>, adjusted by the sum of the eigenvalues of <span>$\hat{H}_{el}^{1}(\mathbf{q})$</span> to corresponding to occupied electronic states given in <span>$s(t)$</span>.</p><p>Similarly to FSSH, <span>$s(t)$</span> must be obtained as the dynamics progress since it itself is time dependent. Again, this is achieved stochastically for each trajectory by making probabilistic hops between surfaces. The probabilities for making successful hops are obtained by integrating the electronic Schrödinger equation alongside the dynamics as</p><p class="math-container">\[i \hbar \dot{c}_{k}^{l}(t) = \lambda_{k}(\mathbf{q}(t))c_{k}^{l}(t) - i \hbar \sum_{\alpha=1}^{N}\sum_{j \neq k} \frac{p_{\alpha}}{m_{\alpha}} d_{\alpha,jk}(\mathbf{q}(t)) c_{j}^{l}(t)\]</p><p>In this equation, <span>$c_{k}^{l}(t)$</span> are the time dependent expansion coefficients for state <span>$k$</span> and electron <span>$l$</span>. <span>$\mathbf{d}_{\alpha,jk}$</span> is the nonadiabatic coupling between adiabatic states <span>$j$</span> and <span>$k$</span>. The hopping probability (which corresponds to replacing index <span>$k$</span> in <span>$s(t)$</span> with <span>$j$</span>) is calculated as</p><p class="math-container">\[g_{k \to j} = \textrm{max}\left( \frac{B_{jk} \Delta t}{A_{kk}}, 0 \right)\]</p><p>Where</p><p class="math-container">\[\begin{align*}
    B_{jk} &amp;= -2 \textrm{Re} (A_{kj}^{*}) \sum_{\alpha = 1}^{N} \frac{p_{\alpha}}{m_{\alpha}} d_{\alpha,jk}\\
    A_{kj} &amp;= \braket{\mathbf{k}|\psi} \braket{\psi | \mathbf{j}}  
\end{align*}\]</p><p>At each timestep, a uniform random number between 0 and 1 is generated which is compared to the calculated probabilities. If the probability is higher than the random number, then a hop is attempted.</p><p>In addition, after a hopping event is selected to occur, the velocity needs to be rescaled in the direction of the nonadiabatic coupling vector. A selected hop will only be successful when there is sufficient kinetic energy for the rescaling such that energy is conserved after the hop.</p><p>If there is insufficient kinetic energy, this is termed a frustrated hop, and the dynamics proceeds without performing a hop. When a hop is successful, the kinetic energy is adjusted and the occupation vector <span>$s(t + \Delta t)$</span> is modified to reflect the change in state occupation.</p><h2 id="Algorithm"><a class="docs-heading-anchor" href="#Algorithm">Algorithm</a><a id="Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm" title="Permalink"></a></h2><ol><li>Integrate classical dynamics for one timestep</li><li>Integrate electronic dynamics for one timestep</li><li>Evaluate hopping probability</li><li>Perform hop if sufficient probability and kinetic energy</li><li>Rescale velocity if hop is performed</li><li>Return to step 1</li></ol><div class="admonition is-info" id="Note-31e433c470d3e9e8"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-31e433c470d3e9e8" title="Permalink"></a></header><div class="admonition-body"><p>With <code>DifferentialEquations.jl</code> we use a callback to perform the surface hopping procedure such that steps 1 and 2 are performed by the DifferentialEquations solvers and steps 3, 4, 5 are performed by the callback.</p></div></div><p>More details of this method&#39;s implementation within NQCD, and associated simulation results for molecular scattering and thermal desorption from a metal surface using IESH were published at the following reference ([<a href="../../../references/#Gardner2023">9</a>]).</p><h2 id="Interfacing-with-the-AndersonHolstein-model"><a class="docs-heading-anchor" href="#Interfacing-with-the-AndersonHolstein-model">Interfacing with the <code>AndersonHolstein</code> model</a><a id="Interfacing-with-the-AndersonHolstein-model-1"></a><a class="docs-heading-anchor-permalink" href="#Interfacing-with-the-AndersonHolstein-model" title="Permalink"></a></h2><p>The Newns-Anderson or Anderson-Holstein model ([<a href="../../../references/#Anderson1961">14</a>][<a href="../../../references/#Newns1969">15</a>]) is a commonly used impurity model which has many applications to surface systems where one wants to simulate an absorbate molecule interacting with a surface. This model works well with the IESH method due to presence of an the explicit bath. </p><p>As such, the IESH single electron Hamiltonian within the framework of the Newns-Anderson model can be written as</p><p class="math-container">\[    \hat{H}_{el}^{1}(\mathbf{q}) = h(\mathbf{q})\ket{d}\bra{d} + \sum_{k=1}^{N} \epsilon_{k} \ket{k}\bra{k} + \sum_{k=1}^{N} V_{k}(\mathbf{q})\left( \ket{k}\bra{d} + \ket{d}\bra{k} \right)\]</p><p>Where <span>$\ket{d}$</span> and <span>$\ket{k}$</span> are the single electron states, <span>$\ket{\psi_{l}}$</span> acted upon by the creation operators for an electron in the absorbate state (<span>$\hat{d}$</span>) and <span>$k^\textrm{th}$</span> bath state (<span>$\hat{c}_{k}^{\dagger}$</span>) respectively. <span>$h(\mathbf{q})$</span> is the difference in energy between the absorbate ground and excited states (<span>$U_{1}(\mathbf{q}) - U_{0}\mathbf{q}$</span>), <span>$\epsilon_{k}$</span> is the energy contribution from the <span>$k^\textrm{th}$</span> bath state, and <span>$V_{k}(\mathbf{q})$</span> is the coupling strength between the <span>$k^\textrm{th}$</span> bath state and the absorbate state.</p><p>More details of the Newns-Anderson model and it&#39;s implementation within NQCD is provided <a href="../../../NQCModels/systembathmodels/">here</a>.</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>In this section we can investigate the results for molecular scattering from a metal surface, obtained for a single trajectory using IESH.</p><p>First, the simulation parameters are created. Here, we have a single atom with a mass of <code>10.54</code> a.u. and we are using <code>ErpenbeckThoss</code> model ([<a href="../../../references/#Erpenbeck2018">6</a>][<a href="../../../references/#Erpenbeck2019">7</a>]), provided by <a href="../../../NQCModels/overview/#NQCModels.jl">NQCModels.jl</a>, to describe the absorbate, and the <code>AndersonHolstein</code> model to provide the coupling to a metallic surface. The Gauss-Legendre bath discretisation method (<code>ShenviGaussLegendre()</code>) implemented by Shenvi ([<a href="../../../references/#Shenvi2009">8</a>]) has been used in preference to a uniform discretisation to better characterise the electronic states close to the fermi level. More details regarding discretisation for system-bath models can be found <a href="../../../NQCModels/systembathmodels/">here</a>.</p><pre><code class="language-julia hljs">using Random; Random.seed!(10)
using NQCDynamics
using Unitful, UnitfulAtomic

atoms = Atoms(2000)

#### Absorbate
Γ = austrip(0.2u&quot;eV&quot;) # Defines coupling strength between diabatic ground state and diabatic excited state of the absorbate
thossmodel = ErpenbeckThoss(;Γ, m=atoms.masses[1]) # This model defines the absorbate

#### Bath
nstates = 20 # Number of states into which the electronic continuum of the substrate is discretised into
bandwidth = austrip(50*u&quot;eV&quot;) #Spectral width of the electronic bands
bandmin = -bandwidth / 2
bandmax = bandwidth / 2
bath = ShenviGaussLegendre(nstates, bandmin, bandmax) #Discretisation method

#### Combined Model
model = AndersonHolstein(thossmodel, bath)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AndersonHolstein{ErpenbeckThoss{Float64}, ShenviGaussLegendre{Float64}, Float64}(ErpenbeckThoss{Float64}(0.007349864435103719, Morse{Float64}
  Dₑ: Float64 0.12935761405782545
  x₀: Float64 3.363712501833871
  a: Float64 0.9187045558486983
  m: Float64 2000.0
, 0.16610693623334402, 0.029031964518659692, 3.363712501833871, 0.7297353738352369, -0.005171714455931712, -0.05512398326327789, 0.05, 0.9448630623128851, 6.614041436190195, 0.03420186041580309), ShenviGaussLegendre{Float64}([-0.9067465870104627, -0.8567476817526358, -0.771464541125868, -0.6584538642970019, -0.527754415280274, -0.39097863910769076, -0.26027919009096284, -0.14726851326209678, -0.061985372635328995, -0.01198646737750203, 0.01198646737750203, 0.061985372635328995, 0.14726851326209678, 0.26027919009096284, 0.39097863910769076, 0.527754415280274, 0.6584538642970019, 0.771464541125868, 0.8567476817526358, 0.9067465870104627], [0.17500452536559272, 0.2620170743363064, 0.3172395648473383, 0.3516989021000065, 0.36844801099871627, 0.36844801099871627, 0.3516989021000065, 0.3172395648473383, 0.2620170743363064, 0.17500452536559272, 0.17500452536559272, 0.2620170743363064, 0.3172395648473383, 0.3516989021000065, 0.36844801099871627, 0.36844801099871627, 0.3516989021000065, 0.3172395648473383, 0.2620170743363064, 0.17500452536559272]), 0.0, 10, 1.0)</code></pre><p>As this is mixed-quantum-classical dynamics method where both the electrons and nuceli are evolved, initial conditions must be generated both for the nuclei (<code>nuclear_distribution</code>) and electrons (<code>electronic_distrbution</code>) and passed as a &quot;product distribution&quot; to the <code>run_dynamics()</code> call.  With an absorbate-bath system, the electronic distribution is given by some Fermi-Dirac distribution generated at a given temperature, from which the electronic state occupations can be sampled during initialisation.</p><pre><code class="language-julia hljs">####  nuclear parameters
r0 = austrip(5u&quot;Å&quot;) # Projectile is 5A away from surface
m = atoms.masses[1] # Mass of projectile
ke = austrip(2u&quot;eV&quot;) # Initial kinetic energy
v0 = -sqrt(2*ke/m) # Velocity direction towards the surface with magnitude defined by kinetic energy
nuclear_distribution = DynamicalDistribution(v0, r0, (1,1))

#### electronic parameters
fermi_level = 0*u&quot;eV&quot; # We reference the spectrum of electronic states of the surface to the Fermi level
temperature = 300u&quot;K&quot;
electronic_distribution = FermiDiracState(fermi_level, temperature)

#### product distribution
dist = electronic_distribution * nuclear_distribution</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NQCDistributions.ProductDistribution{NQCDistributions.FixedFill{Float64}, NQCDistributions.FixedFill{Float64}, FermiDiracState{Adiabatic, Float64, Colon}}(DynamicalDistribution{NQCDistributions.FixedFill{Float64}, NQCDistributions.FixedFill{Float64}}(NQCDistributions.FixedFill{Float64}(-0.00857313503632348, (1, 1)), NQCDistributions.FixedFill{Float64}(9.448630623128851, (1, 1)), Random.Xoshiro(0xaaa9b96be8ddef6c, 0x8fc8b50f30d567d6, 0xc0481f5df5bdceb3, 0x08b8c7560fbec968, 0x5879e8c9b64ab245), Int64[]), FermiDiracState{Adiabatic, Float64, Colon}(0.0, 1052.5834160174613, Adiabatic(), Colon()))</code></pre><p>The final component is defining the &quot;termination condition&quot; that bring the simulation to an end. For this scattering simulation the run is terminated when the absorbate is more the 5.5 Å away from the surfce with a non-zero velocity, or, if the run time exceeds some cut-off time that is sensible.</p><pre><code class="language-julia hljs">### Defining termination criterion
dcut = 3*r0
tcut = abs(dcut/v0)

function termination_condition(u, t, integrator)::Bool

    return ((t &gt; tcut) || ((mean(DynamicsUtils.get_positions(u)) &gt; austrip(5.5u&quot;Å&quot;)) &amp;&amp; (mean(DynamicsUtils.get_velocities(u)) &gt; 0)))
end
terminate = DynamicsUtils.TerminatingCallback(termination_condition)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SciMLBase.DiscreteCallback{typeof(Main.termination_condition), typeof(SciMLBase.terminate!), typeof(SciMLBase.INITIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT), Nothing, Tuple{}}(Main.termination_condition, SciMLBase.terminate!, SciMLBase.INITIALIZE_DEFAULT, SciMLBase.FINALIZE_DEFAULT, Bool[1, 1], nothing, ())</code></pre><p>Finally, the trajectory can be run by passing all the parameters we have set up so far. Here, we request both the <code>OutputAdiabaticPopulation</code> output which is equal to <span>$s(t)$</span>, (the population of each adiabatic state along the trajectory) and <code>OutputSurfaceHops</code>, which details the number of hops between iesh surfaces were allowed during the trajectory.</p><pre><code class="language- hljs">using Statistics
ntrajs = 1
dt = 0.01u&quot;fs&quot;
output= (OutputAdiabaticPopulation, OutputSurfaceHops)

### Run IESH simulations
sim = Simulation{AdiabaticIESH}(atoms, model)

result = run_dynamics(sim,
                    (0.0, tcut),
                    dist;
                    trajectories=ntrajs,
                    callback=terminate,
                    output=output,
                    saveat=[0.0, tcut],
                    dt=dt,
                    precompile_dynamics=true
                   )</code></pre><p>We can plot the adiabatic populations to show how <span>$s(t)$</span> changes throughout the trajectory. </p><pre><code class="language- hljs">using Plots

energy_states = ustrip(auconvert.(u&quot;eV&quot;,sim.cache.eigen.values))

plot(energy_states, result[:OutputAdiabaticPopulation][1], marker=:circle, linestyle=:solid, xlabel=&quot;bath states / eV&quot;, ylabel=&quot;Adiabatic Population&quot;, label=&quot;start&quot;)
plot!(energy_states, result[:OutputAdiabaticPopulation][end], marker=:diamond, linestyle=:dash, label=&quot;end&quot;)</code></pre><pre><code class="language- hljs">println(&quot;Num. surface hops = $(result[:OutputSurfaceHops])&quot;)</code></pre><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fssh/">« Fewest-switches surface hopping (FSSH)</a><a class="docs-footer-nextpage" href="../langevin/">Classical Langevin dynamics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 4 September 2025 17:31">Thursday 4 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
