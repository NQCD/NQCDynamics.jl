<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>System-bath models · NQCDynamics.jl</title><meta name="title" content="System-bath models · NQCDynamics.jl"/><meta property="og:title" content="System-bath models · NQCDynamics.jl"/><meta property="twitter:title" content="System-bath models · NQCDynamics.jl"/><meta name="description" content="Documentation for NQCDynamics.jl."/><meta property="og:description" content="Documentation for NQCDynamics.jl."/><meta property="twitter:description" content="Documentation for NQCDynamics.jl."/><meta property="og:url" content="https://nqcd.github.io/NQCDynamics.jl/stable/NQCModels/systembathmodels/"/><meta property="twitter:url" content="https://nqcd.github.io/NQCDynamics.jl/stable/NQCModels/systembathmodels/"/><link rel="canonical" href="https://nqcd.github.io/NQCDynamics.jl/stable/NQCModels/systembathmodels/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="NQCDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NQCDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../getting_started/">Getting started</a></li><li><a class="tocitem" href="../../atoms/">Atoms</a></li><li><a class="tocitem" href="../../ensemble_simulations/">Ensemble simulations</a></li><li><a class="tocitem" href="../../saving_loading/">Saving and loading</a></li><li><span class="tocitem">NQCModels.jl</span><ul><li><a class="tocitem" href="../overview/">NQCModels.jl</a></li><li><a class="tocitem" href="../combining_models/">Composing multiple models</a></li><li><a class="tocitem" href="../analyticmodels/">Analytic model library</a></li><li><a class="tocitem" href="../machinelearningmodels/">Machine learning interatomic potentials</a></li><li><a class="tocitem" href="../fullsizemodels/">Full dimensional model library</a></li><li><a class="tocitem" href="../frictionmodels/">Electronic friction models</a></li><li class="is-active"><a class="tocitem" href>System-bath models</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Spin-Boson-model"><span>Spin-Boson model</span></a></li><li><a class="tocitem" href="#Newns-Anderson-model"><span>Newns-Anderson model</span></a></li></ul></li></ul></li><li><span class="tocitem">NQCCalculators.jl</span><ul><li><a class="tocitem" href="../../NQCCalculators/overview/">NQCCalculators.jl</a></li></ul></li><li><span class="tocitem">NQCDistributions.jl</span><ul><li><a class="tocitem" href="../../NQCDistributions/overview/">NQCDistributions.jl</a></li></ul></li><li><span class="tocitem">Initial conditions</span><ul><li><a class="tocitem" href="../../initialconditions/ebk/">Semiclassical EBK quantisation</a></li><li><a class="tocitem" href="../../initialconditions/hamiltonian/">Thermal Hamiltonian Monte Carlo</a></li><li><a class="tocitem" href="../../initialconditions/langevin/">Thermal Langevin dynamics</a></li><li><a class="tocitem" href="../../initialconditions/metropolishastings/">Thermal Metropolis-Hastings Monte Carlo</a></li></ul></li><li><span class="tocitem">Dynamics simulations</span><ul><li><a class="tocitem" href="../../dynamicssimulations/dynamicssimulations/">Introduction</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/classical/">Classical molecular dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/ehrenfest/">Ehrenfest molecular dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/fssh/">Fewest-switches surface hopping (FSSH)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/iesh/">Independent electron surface hopping (IESH)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/langevin/">Classical Langevin dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/mdef/">Molecular dynamics with electronic friction (MDEF)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/nrpmd/">Nonadiabatic ring polymer molecular dynamics (NRPMD)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/rpmd/">Ring polymer molecular dynamics (RPMD)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/rpsh/">Ring polymer surface hopping (RPSH)</a></li></ul></li><li><span class="tocitem">Outputs and Analysis</span><ul><li><a class="tocitem" href="../../output_and_analysis/intro/">Simulations outputs and analysis functions</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/reactive_scattering/">Reactive scattering from a metal surface</a></li><li><a class="tocitem" href="../../examples/spinboson/">Ohmic spin-boson nonequilibrium population dynamics</a></li><li><a class="tocitem" href="../../examples/threestatemorse/">Time-dependent populations with the ThreeStateMorse model</a></li><li><a class="tocitem" href="../../examples/tully_scattering/">Scattering probabilities for TullyModelTwo</a></li></ul></li><li><a class="tocitem" href="../../NQCRecipes/overview/">NQCRecipes</a></li><li><a class="tocitem" href="../../integration_algorithms/">Integration algorithms</a></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../../devdocs/diffeq/">DifferentialEquations.jl integration</a></li><li><a class="tocitem" href="../../devdocs/models/">Implementing a new model</a></li><li><a class="tocitem" href="../../devdocs/new_methods/">Contributing a new method</a></li></ul></li><li><span class="tocitem">API</span><ul><li><input class="collapse-toggle" id="menuitem-16-1" type="checkbox"/><label class="tocitem" for="menuitem-16-1"><span class="docs-label">NQCBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCBase/nqcbase/">NQCBase</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-2" type="checkbox"/><label class="tocitem" for="menuitem-16-2"><span class="docs-label">NQCModels</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCModels/FrictionProviders/">FrictionModels</a></li><li><a class="tocitem" href="../../api/NQCModels/adiabaticmodels/">ClassicalModels</a></li><li><a class="tocitem" href="../../api/NQCModels/bathdiscretisations/">BathDiscretisations</a></li><li><a class="tocitem" href="../../api/NQCModels/diabaticmodels/">QuantumModels</a></li><li><a class="tocitem" href="../../api/NQCModels/frictionmodels/">FrictionProviders.jl</a></li><li><a class="tocitem" href="../../api/NQCModels/mace/">MACEModels.jl</a></li><li><a class="tocitem" href="../../api/NQCModels/nonadiabaticmodels/">NQCModels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-3" type="checkbox"/><label class="tocitem" for="menuitem-16-3"><span class="docs-label">NQCDistributions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCDistributions/nqcdistributions/">NQCDistributions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-4" type="checkbox"/><label class="tocitem" for="menuitem-16-4"><span class="docs-label">NQCDynamics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCDynamics/analysis/">Analysis</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsmethods/">DynamicsMethods</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsoutputs/">DynamicsOutputs</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsutils/">DynamicsUtils</a></li><li><a class="tocitem" href="../../api/NQCDynamics/ensembles/">Ensembles</a></li><li><a class="tocitem" href="../../api/NQCDynamics/estimators/">Estimators</a></li><li><a class="tocitem" href="../../api/NQCDynamics/initialconditions/">InitialConditions</a></li><li><a class="tocitem" href="../../api/NQCDynamics/nonadiabaticmoleculardynamics/">NQCDynamics</a></li><li><a class="tocitem" href="../../api/NQCDynamics/numericutils/">Numerical utilities</a></li><li><a class="tocitem" href="../../api/NQCDynamics/ringpolymers/">RingPolymers</a></li><li><a class="tocitem" href="../../api/NQCDynamics/structure/">Structure</a></li><li><a class="tocitem" href="../../api/NQCDynamics/timecorrelationfunctions/">TimeCorrelationFunctions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-5" type="checkbox"/><label class="tocitem" for="menuitem-16-5"><span class="docs-label">NQCCalculators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCCalculators/nqccalculators/">NQCCalculators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-6" type="checkbox"/><label class="tocitem" for="menuitem-16-6"><span class="docs-label">NQCDInterfASE</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCDInterfASE/ase-interface/">NQCDInterfASE</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-16-7" type="checkbox"/><label class="tocitem" for="menuitem-16-7"><span class="docs-label">RingPolymerArrays</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/RingPolymerArrays/ringpolymerarrays/">RingPolymerArrays</a></li></ul></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">NQCModels.jl</a></li><li class="is-active"><a href>System-bath models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>System-bath models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NQCD/NQCDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NQCD/NQCDynamics.jl/blob/main/docs/src/NQCModels/systembathmodels.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="System-bath-models"><a class="docs-heading-anchor" href="#System-bath-models">System-bath models</a><a id="System-bath-models-1"></a><a class="docs-heading-anchor-permalink" href="#System-bath-models" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Often, in chemical dynamics, we consider &quot;open systems&quot;, i.e. systems that are coupled to an environment (or &quot;bath&quot;). For example, we can consider a molecule in contact with a metal or semiconductor surface as a molecule in contact with an electron bath (the surface electrons) and a phonon bath (the surface vibrations). Quantum Hamiltonian models that describe system-bath coupling allow the simulation of energy exchange and dissipation between the system and the bath(s).</p><p>The effect that the bath has on the system is described by the bath spectral density, <span>$J(\varepsilon)$</span>, which can take various forms depending on the choice of coupling.</p><h2 id="Spin-Boson-model"><a class="docs-heading-anchor" href="#Spin-Boson-model">Spin-Boson model</a><a id="Spin-Boson-model-1"></a><a class="docs-heading-anchor-permalink" href="#Spin-Boson-model" title="Permalink"></a></h2><p>The Spin-Boson model consists of 2 electronic states (2-level system) coupled to a bath of harmonic oscillators. The potential of the system is given below.</p><p class="math-container">\[V(\mathbf{\hat{R}}) = 
\begin{pmatrix}
\varepsilon + \mathbf{c}^{T} \mathbf{\hat{R}} &amp; \Delta\\
\Delta &amp; - \varepsilon - \mathbf{c}^{T} \mathbf{\hat{R}}
\end{pmatrix} + \frac{1}{2} \mathbf{\hat{R}}^{T} \mathbf{\Omega}^{2} \mathbf{\hat{R}} \]</p><p>The set of coupling coefficients (<span>$\mathbf{c} = \{c\}$</span>) and frequencies (<span>$\mathbf{\Omega} = \{\omega\}$</span>) of the bath harmonic modes required for this model are sampled from a discretisation of the bath spectral density, <span>$J(\omega)$</span>.</p><p>When defining the Spin-Boson model, 4 arguments are provided to the function:</p><pre><code class="language-julia hljs">using NQCModels
SpinBoson(density::SpectralDensity, N::Integer, ϵ, Δ)</code></pre><p>The first two arguments define the bath discretisation, the first being the type of bath, the second (<code>N</code>) indicates the number of discretised bath modes. From these arguments, the bath discretisation functions can return the set of frequencies, <span>$\Omega$</span>, and coupling coefficients for each harmonic mode <span>$j$</span>.</p><p>The final two arguments <code>ϵ</code> and <code>Δ</code> define information about the 2-level system coupling to the bath. <code>ϵ</code> provides the energy bias between the two states and <code>Δ</code> the coupling between them (also referred to as the tunneling matrix element) [<a href="../../references/#He2019">5</a>].</p><p>Discretisations of the spectral density function have been implemented for two of the bath types that are commonly used in literature.</p><ul><li><strong>Ohmic</strong> bath (<code>OhmicSpectralDensity()</code>)</li><li><strong>Debye</strong> bath (<code>DebyeSpectralDensity()</code>, <code>AltDebyeSpectralDensity</code>)</li></ul><p>These functions are containers that store the relevant information needed to build a discretised bath. The actual construction and subsequent sampling is only done when <code>SpinBoson()</code> is called.</p><p>The following section details each bath discretisation method with examples of their implementation.</p><h3 id="Ohmic-bath"><a class="docs-heading-anchor" href="#Ohmic-bath">Ohmic bath</a><a id="Ohmic-bath-1"></a><a class="docs-heading-anchor-permalink" href="#Ohmic-bath" title="Permalink"></a></h3><p>The Ohmic bath spectral density function (for <span>$\omega \geq 0$</span>) takes the form:</p><p class="math-container">\[J(\omega) = \frac{\pi}{2} \alpha \omega e^{-\omega / \omega_{c}}  \]</p><p>Where <span>$\omega_{c}$</span> is the characteristic frequency of the bath and <span>$\alpha$</span> is the Kondo parameter. These are provided as inputs to the function <code>OhmicSpectralDensity(ωᶜ,α)</code>.</p><p>The set of frequencies, <span>$\mathbf{\Omega}$</span>, and coupling coefficients, <span>$\mathbf{c}$</span>, are generated for the number of discretised bath modes, <span>$N_{b}$</span> provided.</p><p class="math-container">\[\begin{align*}
   \omega_{j} &amp;= - \omega_{c} \ln\left[ 1 - \frac{j}{(1 + N_{b})} \right] \\
   c_{j} &amp;= \sqrt{\frac{\alpha \omega_{c}}{N_{b} + 1}} \omega_{j}
\end{align*}\]</p><p>Where <span>$j=1,...,N_{b}$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using NQCModels</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; DebyeDensity = DebyeSpectralDensity(0.25, 0.5)</code><code class="nohighlight hljs ansi" style="display:block;">DebyeSpectralDensity{Float64}(0.25, 0.5)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SpinBoson(DebyeDensity, 10, 1.0, 1.0)</code><code class="nohighlight hljs ansi" style="display:block;">SpinBoson{Float64}(1.0, 1.0, [1.738788192943366, 0.8514218097223122, 0.5474236407474202, 0.38900759324386036, 0.28851538013325234, 0.21662623313576573, 0.16066524429208276, 0.11417117447588881, 0.07340662323459164, 0.035944573498743346], [0.5242643659902941, 0.2567133346522072, 0.1650544379754093, 0.11729020248991609, 0.0869906601953415, 0.06531526682358083, 0.048442393833420735, 0.034423904328247684, 0.02213292967237503, 0.010837696685880355])</code></pre><h3 id="Debye-bath"><a class="docs-heading-anchor" href="#Debye-bath">Debye bath</a><a id="Debye-bath-1"></a><a class="docs-heading-anchor-permalink" href="#Debye-bath" title="Permalink"></a></h3><p>The Debye bath spectral density function takes the form:</p><p class="math-container">\[J(\omega) = 2 \lambda \frac{\omega_{c} \omega}{\omega_{c}^{2} + \omega^{2}} \]</p><p>Where <span>$\omega_{c}$</span> is the characteristic frequency of the bath and <span>$\lambda$</span> is the reorganisation. These are provided as inputs to the function <code>DebyeSpectralDensity(ωᶜ,λ)</code>.</p><p>The set of frequencies, <span>$\mathbf{\Omega}$</span>, and coupling coefficients, <span>$\mathbf{c}$</span>, are generated for the number of discretised bath modes, <span>$N_{b}$</span> provided.</p><p class="math-container">\[\begin{align*}
   \omega_{j} &amp;= \omega_{c} \tan\left( \frac{\pi}{2} \left(1 - \frac{j}{(1 + N_{b})} \right) \right) \\
   c_{j} &amp;= \sqrt{\frac{2 \lambda}{N_{b} + 1}} \omega_{j}
\end{align*}\]</p><p>Where <span>$j=1,...,N_{b}$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using NQCModels</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; OhmicDensity = OhmicSpectralDensity(2.5, 0.1)</code><code class="nohighlight hljs ansi" style="display:block;">OhmicSpectralDensity{Float64}(2.5, 0.1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SpinBoson(OhmicDensity, 10, 1.0, 1.0)</code><code class="nohighlight hljs ansi" style="display:block;">SpinBoson{Float64}(1.0, 1.0, [0.23827544951081223, 0.5016767386553781, 0.7961343277963364, 1.1299628093576433, 1.515339508925789, 1.9711434009106752, 2.5290022791961997, 3.248207460325652, 4.261870230596064, 5.994738181995926], [0.03592137558093801, 0.07563061400768518, 0.1200217658191937, 0.17034830298614512, 0.22844602641401135, 0.29716104858208175, 0.3812614388203375, 0.4896856994151551, 0.6425011118214814, 0.903740784822625])</code></pre><h2 id="Newns-Anderson-model"><a class="docs-heading-anchor" href="#Newns-Anderson-model">Newns-Anderson model</a><a id="Newns-Anderson-model-1"></a><a class="docs-heading-anchor-permalink" href="#Newns-Anderson-model" title="Permalink"></a></h2><p>The Anderson Impurity Model (AIM) describes a single electronic state (&quot;impurity&quot;) coupled with a continuous band of electronic bath states. AIM is a fundamental model in condensed matter physics and quantum chemistry, introduced by P.W. Anderson in 1961. The Newns-Anderson model is a generalization of the AIM, which includes the possibility of multiple impurity states and a more complex interaction with the bath. A key advantage of using the AIM lies in its ability to yield analytical solutions for the energy level distribution and the hybridization (coupling) density, making it a powerful tool for theoretical analysis.</p><h3 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h3><p>The total Hamiltonian <span>$H$</span> of the Newns-Anderson model can be written as:</p><p class="math-container">\[H = H_{S} + H_{B} + H_{C}\]</p><h4 id="Impurity"><a class="docs-heading-anchor" href="#Impurity">Impurity</a><a id="Impurity-1"></a><a class="docs-heading-anchor-permalink" href="#Impurity" title="Permalink"></a></h4><p>The Impurity (or system, S) Hamiltonian describes the localized orbitals:</p><p class="math-container">\[H_{S} = \sum_{i} \varepsilon_{i} d_{i}^{\dagger} d_{i}\]</p><p>Here</p><ul><li><span>$\varepsilon_{i}$</span> is the energy of the <span>$i$</span>-th impurity orbital.</li><li><span>$d_i^{\dagger}, d_i$</span> : creation/annihilation operators for orbital <span>$i$</span></li></ul><p>For the specific case of a single impurity system, the system Hamiltonian can be expressed as:</p><p class="math-container">\[H_{S} = h \cdot d^{\dagger} d + U_0\]</p><p>In this representation:</p><ul><li><span>$U_0$</span> is a state-independent potential (or energy offset)</li><li><span>$h$</span> is the energy contribution due to populating the impurity state. It can be convenient to define <span>$h = U_1 - U_0$</span> such that <span>$U_1$</span> and <span>$U_0$</span> define two energy landscapes and populating <span>$h$</span> with an electron switches between <span>$U_0$</span> and <span>$U_1$</span></li></ul><h4 id="Bath"><a class="docs-heading-anchor" href="#Bath">Bath</a><a id="Bath-1"></a><a class="docs-heading-anchor-permalink" href="#Bath" title="Permalink"></a></h4><p>Describes a set of non-interacting electronic states. Usually written as</p><p class="math-container">\[H_B = \sum_{k} \epsilon_k c_k^{\dagger} c_k\]</p><ul><li><span>$\epsilon_k$</span>: energy of bath state <span>$k$</span>  </li><li><span>$c_{k}^\dagger, c_{k}$</span>: creation/annihilation operators for state <span>$k$</span></li></ul><h4 id="Interaction"><a class="docs-heading-anchor" href="#Interaction">Interaction</a><a id="Interaction-1"></a><a class="docs-heading-anchor-permalink" href="#Interaction" title="Permalink"></a></h4><p>Captures the coupling between the impurity, <span>$i$</span>, and the bath states, <span>$k$</span>:</p><p class="math-container">\[H_{C} = \sum_{i,k} V_{ik} d_i^{\dagger} c_k + V_{ik}^{*} c_k^{\dagger} d_i\]</p><p>where <span>$V_{ik}$</span> stands for the coupling strength.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>To build a Newns-Anderson model in NQCModels.jl, you can use the <a href="../../api/NQCModels/diabaticmodels/#NQCModels.QuantumModels.AndersonHolstein"><code>AndersonHolstein</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using NQCModels</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; quantum_model = ErpenbeckThoss(Γ=2.0)</code><code class="nohighlight hljs ansi" style="display:block;">ErpenbeckThoss{Float64}(2.0, Morse{Float64}
  Dₑ: Float64 0.12935761405782545
  x₀: Float64 3.363712501833871
  a: Float64 0.9187045558486983
  m: Float64 1822.888486217313
, 0.16610693623334402, 0.029031964518659692, 3.363712501833871, 0.7297353738352369, -0.005414510796122209, -0.05512398326327789, 0.05, 0.9448630623128851, 6.614041436190195, 0.5641895835477563)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bath = TrapezoidalRule(10, -1, 1)</code><code class="nohighlight hljs ansi" style="display:block;">TrapezoidalRule{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Float64}(-1.0:0.2222222222222222:1.0, 0.4472135954999579)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; AndersonHolstein(quantum_model, bath; couplings_rescale=1.0)</code><code class="nohighlight hljs ansi" style="display:block;">AndersonHolstein{ErpenbeckThoss{Float64}, TrapezoidalRule{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Float64}, Float64}(ErpenbeckThoss{Float64}(2.0, Morse{Float64}
  Dₑ: Float64 0.12935761405782545
  x₀: Float64 3.363712501833871
  a: Float64 0.9187045558486983
  m: Float64 1822.888486217313
, 0.16610693623334402, 0.029031964518659692, 3.363712501833871, 0.7297353738352369, -0.005414510796122209, -0.05512398326327789, 0.05, 0.9448630623128851, 6.614041436190195, 0.5641895835477563), TrapezoidalRule{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Float64}(-1.0:0.2222222222222222:1.0, 0.4472135954999579), 0.0, 5, 1.0, [0.0 0.0; 0.0 0.0], LinearAlgebra.Hermitian{Float64, Matrix{Float64}}[[0.0 0.0; 0.0 0.0];;])</code></pre><p>The <code>ErpenbeckThoss</code> model ([<a href="../../references/#Erpenbeck2018">6</a>], [<a href="../../references/#Erpenbeck2019">7</a>]) is used here to describe the adsorbate impurity (the system Hamiltonian <span>$H_S$</span>) and a <code>TrapezoidalRule</code> discretisation scheme provides the set of discrete energy states (and their couplings to the impurity) that represent the bath of electrons in a metal surface. The <a href="../../api/NQCModels/diabaticmodels/#NQCModels.QuantumModels.AndersonHolstein"><code>couplings_rescale</code></a> is a scalar parameter that rescales the coupling strengths to the bath states to adjust the model&#39;s parametrisation to the chosen discretisation. Let&#39;s now look at the various ways to discretise the electron bath.</p><h3 id="Discretisation-of-bath"><a class="docs-heading-anchor" href="#Discretisation-of-bath">Discretisation of bath</a><a id="Discretisation-of-bath-1"></a><a class="docs-heading-anchor-permalink" href="#Discretisation-of-bath" title="Permalink"></a></h3><p>Some mixed quantum classical dynamics methods that deal with system-bath simulations require the discretisation of the bath spectral density, <span>$J(\varepsilon)$</span>, into a finite number of discrete energy levels such that the individual state couplings are explicitly considered during propagation. i.e. <a href="../../dynamicssimulations/dynamicsmethods/iesh/#iesh-dynamics">Independent electron surface hopping (IESH)</a> [<a href="../../references/#Shenvi2009">8</a>] [<a href="../../references/#Gardner2023">9</a>].</p><p>The bath spectral density here is given by the following integral:</p><p class="math-container">\[J(\varepsilon) = \int_{a}^{b} d\varepsilon&#39; \left| V(\varepsilon&#39;) \right|^{2} \delta(\varepsilon - \varepsilon&#39;) = \left| V(\varepsilon) \right|^{2}\]</p><p>Where <span>$V(\varepsilon)$</span> is the &quot;coupling function&quot; which describes how the bath and system should be related at a given energy [<a href="../../references/#DeVega2015">10</a>]]. Discretising this over a set of <span>$N$</span> bath states gives the following form:</p><p class="math-container">\[J^{discr}(\varepsilon) = \sum_{n=1}^{N} \left|V_{n}\right|^{2} \delta \left( \varepsilon - \varepsilon_{n} \right)\]</p><p>Where <span>$V_{n}$</span> is the coupling contribution at state n. </p><h4 id="Discretisation-in-the-wide-band-limit"><a class="docs-heading-anchor" href="#Discretisation-in-the-wide-band-limit">Discretisation in the wide band limit</a><a id="Discretisation-in-the-wide-band-limit-1"></a><a class="docs-heading-anchor-permalink" href="#Discretisation-in-the-wide-band-limit" title="Permalink"></a></h4><p>The Wide Band Limit (WBL) is a common approximation which considers the bath spectral density to be constant over a wide range of energies. In the WBL, discretisation of the bath spectral density function, <span>$J(\varepsilon)$</span>, yields couplings associated with each state that are simply related to the energy spacing between states.</p><h5 id="WBL-Discretisation-with-constant-spacing"><a class="docs-heading-anchor" href="#WBL-Discretisation-with-constant-spacing">WBL Discretisation with constant spacing</a><a id="WBL-Discretisation-with-constant-spacing-1"></a><a class="docs-heading-anchor-permalink" href="#WBL-Discretisation-with-constant-spacing" title="Permalink"></a></h5><p>The simplest choice for discretising the bath spectral density is to represent the bath as a set of <code>M</code> evenly spaced energy states according to a trapezoidal integration rule. </p><p>This is implemented as <code>TrapezoidalRule()</code> which takes the following arguments:</p><pre><code class="language-julia hljs">using NQCModels
TrapezoidalRule(M, bandmin, bandmax)</code></pre><p>Where:</p><ul><li><code>M</code> = number of discretised bath states to be generated</li><li><code>bandmin</code> / <code>bandmax</code> = miniumum / maximum energies that define the bath energy range</li></ul><p>The discretised bath energy states, <span>$\varepsilon_{n}$</span>, and couplings, <span>$V_{n}$</span>, are calculated as follows:</p><p class="math-container">\[\begin{align*}
   \varepsilon_{n} &amp;= a + \frac{(n - 1)(b - a)}{M - 1} \\
   V_{n} &amp;= V(\varepsilon_{n})\sqrt{(b-a)/(M-1)} = \sqrt{\Delta \varepsilon_{n}}
\end{align*}\]</p><p>Where:</p><ul><li><span>$n$</span> = index of the discretised state</li><li><span>$a$</span> = minimum energy of bath discretisation (<code>bandmin</code>)</li><li><span>$b$</span> = maximum energy of bath discretisation (<code>bandmax</code>)</li><li><span>$M$</span> = number of bath states in the discretisation (<code>M</code>)</li><li><span>$\Delta \varepsilon_{n}$</span> is the spacing between the <span>$n$</span> discretised energy states </li><li><span>$V(\varepsilon_{n})$</span> is the coupling function evaluated at the <span>$n$</span> discretised energy states</li></ul><p>When making the WBL approximation, however, the coupling function, <span>$V(\varepsilon)$</span>, is independent of energy, <span>$\varepsilon$</span>. Taking <span>$V(\varepsilon_{n})$</span> as a  constant allows the simplification:</p><p class="math-container">\[\left| V_{n} \right|^{2} = \left| V(\varepsilon_{n}) \right|^{2} \Delta \varepsilon_{n} \approx \Delta \varepsilon_{n}\]</p><p>This discretisation method is effective and given enough states will always accurately represent the spectral density, but methods such as IESH using this discretisation scheme will suffer from long computation times as the number of bath states <span>$M$</span> increases. </p><div class="admonition is-success" id="Number-of-bath-states-c0fd154d7c99b7ac"><header class="admonition-header">Number of bath states<a class="admonition-anchor" href="#Number-of-bath-states-c0fd154d7c99b7ac" title="Permalink"></a></header><div class="admonition-body"><p>Typically, keeping <span>$M&lt;100$</span> for IESH simulations is highly recommended to keep computational simulation times low.</p></div></div><h5 id="WBL-Discretisation-by-Gauss-Legendre-quadrature"><a class="docs-heading-anchor" href="#WBL-Discretisation-by-Gauss-Legendre-quadrature">WBL Discretisation by Gauss-Legendre quadrature</a><a id="WBL-Discretisation-by-Gauss-Legendre-quadrature-1"></a><a class="docs-heading-anchor-permalink" href="#WBL-Discretisation-by-Gauss-Legendre-quadrature" title="Permalink"></a></h5><p>Gauss-Legendre quadrature addresses the computational scaling issues with constant spacing methods and allows denser sampling close to the midpoint of the electronic band (the Fermi energy).</p><p>Implemented as <code>ShenviGaussLegendre()</code> is the method developed by Shenvi et al in 2009, where Gauss-Legendre quadrature was used to discretise the bath in two halves, one above and one below the Fermi level [<a href="../../references/#Shenvi2009">8</a>].  This function takes the following arguments:</p><pre><code class="language-julia hljs">using NQCModels
ShenviGaussLegendre(M, bandmin, bandmax)</code></pre><p>The rescaled knots, <span>$\epsilon_{n}$</span>, and weights, <span>$w_{n}$</span>, are given by the following scaling related to the value of the Fermi level, <span>$\epsilon_{F}$</span>.</p><p class="math-container">\[\begin{align*}
   \epsilon_{n} &amp;=
   \begin{cases}
      \frac{1}{2}(\epsilon_{F} - a) x_{n} + \frac{1}{2}(a + \epsilon_{F}) \qquad n \leq M/2\\
      \frac{1}{2}(b - \epsilon_{F}) x_{n} + \frac{1}{2}(\epsilon_{F} - b) \qquad n \geq M/2
   \end{cases}\\
   \tilde{w}_{n} &amp;=
   \begin{cases}
      \frac{1}{2}(\epsilon_{F} - a) w_{n} \qquad n \leq M/2\\
      \frac{1}{2}(b - \epsilon_{F}) w_{n} \qquad n \geq M/2
   \end{cases}\\
\end{align*}\]</p><p>Where:</p><ul><li><span>$\epsilon_{F}$</span> = Fermi level</li><li><span>$x{n}$</span> = knots obtained from Gauss-Legendre quadrature</li><li><span>$w_{n}$</span> = weights obtained from Gauss-Legendre quadrature</li><li><span>$a$</span> = minimum energy of bath discretisation (<code>bandmin</code>)</li><li><span>$b$</span> = maximum energy of bath discretisation (<code>bandmax</code>)</li><li><span>$M$</span> = number of bath states in the discretisation (<code>M</code>)</li></ul><p>By supplying a value for the Fermi level, the dense discretisation region is shifted to be centred on a different region of the energy range that may benefit from being well described during a calculation.</p><h4 id="Discretisation-with-a-gap"><a class="docs-heading-anchor" href="#Discretisation-with-a-gap">Discretisation with a gap</a><a id="Discretisation-with-a-gap-1"></a><a class="docs-heading-anchor-permalink" href="#Discretisation-with-a-gap" title="Permalink"></a></h4><p>Two numerical discretisation methods which introduce a band gap in the middle of the discretised electronic states are introduced and named as <a href="../../api/NQCModels/bathdiscretisations/#NQCModels.BathDiscretisations.GapTrapezoidalRule"><code>GapTrapezoidalRule</code></a> and <a href="../../api/NQCModels/bathdiscretisations/#NQCModels.BathDiscretisations.GapGaussLegendre"><code>GapGaussLegendre</code></a>.</p><pre><code class="language-julia hljs">using NQCModels
gapbath_T = GapTrapezoidalRule(nstates, bandmin_val, bandmax_val, bandgap)
gapbath_G = GapGaussLegendre(nstates, bandmin_val, bandmax_val, bandgap)</code></pre><h5 id="Gapped-Trapezoidal-Rule"><a class="docs-heading-anchor" href="#Gapped-Trapezoidal-Rule">Gapped Trapezoidal Rule</a><a id="Gapped-Trapezoidal-Rule-1"></a><a class="docs-heading-anchor-permalink" href="#Gapped-Trapezoidal-Rule" title="Permalink"></a></h5><p>The <em>Gapped Trapezoidal</em> Rule discretises a band into two evenly spaced continuums, which is particularly useful for systems with a band gap, such as semiconductors.</p><p>The energy <span>$\epsilon_k$</span> for each discretised state <span>$k$</span> is defined as:</p><p class="math-container">\[\epsilon_k = \begin{cases}E_{\text{F}} - \Delta E + (k-1) \times \frac{\Delta E - E_{\text{gap}}}{M} &amp;\text { if } k \leq M/2 \\ E_{\text{F}} + \frac{E_{\text{gap}}}{2} + (k-M/2 -1) \times \frac{\Delta E - E_{\text{gap}}}{M}&amp;\text { otherwise }\end{cases}\]</p><p>These states are associated with constant coupling weights <span>$\omega_k$</span>:</p><p class="math-container">\[\omega_k = \frac{\Delta E - E_{\text{gap}}}{M}\]</p><p>where:</p><ul><li><span>$\Delta E$</span> is the total energy range of the bath.</li><li><span>$E_{\text{gap}}$</span> is the size of the gap located in the middle of the band.</li><li><span>$E_{\text{F}}$</span> is the Fermi energy.</li><li><span>$M$</span> is the total number of discretised states.</li></ul><h5 id="Gapped-Gauss-Legendre"><a class="docs-heading-anchor" href="#Gapped-Gauss-Legendre">Gapped Gauss Legendre</a><a id="Gapped-Gauss-Legendre-1"></a><a class="docs-heading-anchor-permalink" href="#Gapped-Gauss-Legendre" title="Permalink"></a></h5><p>The <em>Gapped Gauss-Legendre</em> discretization, unlike the Gapped Trapezoidal method, creates a band with a high density of states around the band gap, using a scheme adapted from the Legendre quadrature method.</p><p>The discretisation for the energy <span>$\epsilon_k$</span> of each state <span>$k$</span> is defined as follows:</p><p class="math-container">\[\epsilon_k = \begin{cases}E_{\text{F}} - \left[\frac{\Delta E-E_{\text{gap}}}{2} (1+x_{\text L,M/2-k+1}) + E_{\text{gap}}\right]/2 &amp;\text { if } k \leq M/2 \\
E_{\text{F}} + \left[\frac{\Delta E-E_{\text{gap}}}{2} (1+x_{\text L,k-M/2}) + E_{\text{gap}}\right]/2&amp;\text { otherwise }\end{cases}\]</p><p>with conjugate weights:</p><p class="math-container">\[\omega_k = \begin{cases}
\Delta E w_{\text{L},M/2-k+1} /2 &amp;\text { if } k \leq M/2 \\
\Delta E w_{\text{L},k-M/2} /2 &amp;\text { otherwise }
\end{cases}\]</p><p><strong>Parameters:</strong></p><ul><li><span>$x_{\text{L},i}$ and $\omega_{\text{L},i}$</span>: These represent the knot points and weights, respectively, obtained from Legendre quadrature over the interval <span>$[-1,1]$</span>. For this formulation, <span>$M/2$</span> knots are used.</li><li><span>$E_{\text{F}}$</span>: The Fermi level, which is typically set to 0 eV or the centre of the continuum band.</li><li><span>$M$</span>: The total number of discretisation points. It is crucial that <span>$M$</span> is an even number for this formulation to be valid.</li><li><span>$\Delta E$</span>: The total width of the continuum band.</li><li><span>$E_{\text{gap}}$</span>: The size of the band gap.</li></ul><h5 id="Gapped-discretisation-examples"><a class="docs-heading-anchor" href="#Gapped-discretisation-examples">Gapped discretisation examples</a><a id="Gapped-discretisation-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Gapped-discretisation-examples" title="Permalink"></a></h5><p>To build a discretised bath with a gap in the middle, you can use the <a href="../../api/NQCModels/bathdiscretisations/#NQCModels.BathDiscretisations.GapTrapezoidalRule"><code>GapTrapezoidalRule</code></a> or <a href="../../api/NQCModels/bathdiscretisations/#NQCModels.BathDiscretisations.GapGaussLegendre"><code>GapGaussLegendre</code></a> methods. <img src="../../assets/system-bath-model/DOS_bath_discretisation_compare_test.svg" alt="gappedDOS"/></p><p>The Julia script to reproduce the above figure is available in the <a href="../../assets/system-bath-model/plot_bath_DOS.jl">plot<em>bath</em>DOS.jl</a>.</p><h4 id="Discretisation-with-a-densely-sampled-&quot;window&quot;-region"><a class="docs-heading-anchor" href="#Discretisation-with-a-densely-sampled-&quot;window&quot;-region">Discretisation with a densely sampled &quot;window&quot; region</a><a id="Discretisation-with-a-densely-sampled-&quot;window&quot;-region-1"></a><a class="docs-heading-anchor-permalink" href="#Discretisation-with-a-densely-sampled-&quot;window&quot;-region" title="Permalink"></a></h4><p>The windowed discretisation method generates a dense region of states within a user-specified energy &quot;window&quot;, and a sparse discretisation elsewhere. It also assumes a constant density of states in the WBL. The density of this region is controlled through an optional keyword parameter <code>densityratio</code> which takes a default value of <code>0.5</code>. This is defined as the ratio <span>$N_{\textrm{States in window}} / N_{\textrm{Total number of states}}$</span>. </p><p>This discretisation is selected by the function <code>WindowedTrapezoidalRule()</code> which takes the following arguments:</p><pre><code class="language-julia hljs">using NQCModels
WindowedTrapezoidalRule(M, bandmin, bandmax, windmin, windmax, densityratio=0.50)</code></pre><p>Where:</p><ul><li><code>M</code> = number discretised bath states</li><li><code>bandmin</code> / <code>bandmax</code> = minimum / maximum values of bath discretisation energy range</li><li><code>windmin</code> / <code>windmax</code> = minimum / maximum energy values of window region in bath discretisation</li><li><code>densityratio</code> = ratio between the number of states in the window region to the total number of discretised bath states</li></ul><p>The discretised bath states and the associated couplings are calculated using the trapezoidal rule in each region, with the energy spacing between the window and sparse regions given by <span>$\Delta \varepsilon_{\textrm{join}} = \frac{1}{2}(\Delta \varepsilon_{\textrm{win}} + \Delta \varepsilon_{\textrm{sparse}})$</span>:</p><p class="math-container">\[\begin{align*}
\varepsilon_{n} &amp;= 
   \begin{cases}
      a^{\textrm{win}} + \frac{(n - 1)(b^{\textrm{win}} - a^{\textrm{win}})}{\eta M - 1} &amp;\qquad n^{\textrm{win}}_{-} &lt; n \leq n^{\textrm{win}}_{+} \\ 
      b^{\textrm{win}} + \Delta \varepsilon_{\textrm{join}} + \frac{(n - 1)(b - b^{\textrm{win}} - \Delta \varepsilon_{join})}{n^{\textrm{win}}_{-} - 1} &amp;\qquad  n &gt; n^{\textrm{win}}_{+} \\
      a - \Delta \varepsilon_{\textrm{join}} + \frac{(n - 1)(b^{\textrm{win}} - a - \Delta \varepsilon_{\textrm{join}})}{n^{\textrm{win}}_{-} - 1} &amp;\qquad n &lt; n^{\textrm{win}}_{-}
   \end{cases}\\ 
   V_{n} &amp;= 
   \begin{cases}
      V(\varepsilon_{n})\sqrt{(b^{\textrm{win}} - a^{\textrm{win}})/(\eta M - 1)} = \sqrt{\Delta \varepsilon_{n}^{\textrm{win}}} &amp;\qquad n^{\textrm{win}}_{-} &lt; n \leq n^{\textrm{win}}_{+} \\ 
      V(\varepsilon_{n})\sqrt{(2b - 2b^{\textrm{win}} - \Delta \varepsilon^{\textrm{win}})/(2n^{\textrm{win}}_{-} - 1)} = \sqrt{\Delta \varepsilon_{n}^{sp}} &amp;\qquad n \leq n^{\textrm{win}}_{-} \; \textrm{and} \; n&gt;n^{\textrm{win}}_{+}
   \end{cases}
\end{align*}\]</p><p>Where:</p><ul><li><span>$n^{\textrm{win}}_{\mp} = M(1 \mp \eta)/2:$</span> are the state indices that define the window region (<span>$n^{win}_{-}$</span> is also equivalent to the number of states in the sparse region)</li><li><span>$\eta$</span> = density ratio (<code>densityratio</code>) which defines the proportion of states within the window relative to the total number of discretised states. <span>$M^{win} = \eta M$</span></li><li><span>$a$</span> = minimum energy of bath discretisation (<code>bandmin</code>)</li><li><span>$b$</span> = maximum energy of bath discretisation (<code>bandmax</code>)</li><li><span>$a^{\textrm{win}}$</span> = minimum energy of the window region in the bath discretisation (<code>windmin</code>)</li><li><span>$b^{\textrm{win}}$</span> = maximum energy of the window region in the bath discretisation (<code>windmax</code>)</li></ul><p>This method allows the user to finely discretise the electronic bath states over a larger energy range than can be achieved with the Gauss-Legendre quadrature method, without resorting to use a trapezoidal rule discretisation with many states. Hence, saving computation time. The motivation for such a discretisation was to provide a better energy grid for the bath such that a non-equlibrium electronic distribution with a complex shape could be more accurately sampled from. </p><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../frictionmodels/">« Electronic friction models</a><a class="docs-footer-nextpage" href="../../NQCCalculators/overview/">NQCCalculators.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 8 December 2025 10:59">Monday 8 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
