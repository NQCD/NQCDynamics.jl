<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reactive scattering from a metal surface · NQCDynamics.jl</title><meta name="title" content="Reactive scattering from a metal surface · NQCDynamics.jl"/><meta property="og:title" content="Reactive scattering from a metal surface · NQCDynamics.jl"/><meta property="twitter:title" content="Reactive scattering from a metal surface · NQCDynamics.jl"/><meta name="description" content="Documentation for NQCDynamics.jl."/><meta property="og:description" content="Documentation for NQCDynamics.jl."/><meta property="twitter:description" content="Documentation for NQCDynamics.jl."/><meta property="og:url" content="https://nqcd.github.io/NQCDynamics.jl/stable/examples/reactive_scattering/"/><meta property="twitter:url" content="https://nqcd.github.io/NQCDynamics.jl/stable/examples/reactive_scattering/"/><link rel="canonical" href="https://nqcd.github.io/NQCDynamics.jl/stable/examples/reactive_scattering/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="NQCDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NQCDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../getting_started/">Getting started</a></li><li><a class="tocitem" href="../../atoms/">Atoms</a></li><li><a class="tocitem" href="../../ensemble_simulations/">Ensemble simulations</a></li><li><a class="tocitem" href="../../saving_loading/">Saving and loading</a></li><li><span class="tocitem">NQCModels.jl</span><ul><li><a class="tocitem" href="../../NQCModels/overview/">NQCModels.jl</a></li><li><a class="tocitem" href="../../NQCModels/combining_models/">Composing multiple models</a></li><li><a class="tocitem" href="../../NQCModels/combining_models/">Composing multiple models</a></li><li><a class="tocitem" href="../../NQCModels/analyticmodels/">Analytic model library</a></li><li><a class="tocitem" href="../../NQCModels/machinelearningmodels/">Machine learning interatomic potentials</a></li><li><a class="tocitem" href="../../NQCModels/fullsizemodels/">Full dimensional model library</a></li><li><a class="tocitem" href="../../NQCModels/frictionmodels/">Electronic friction models</a></li></ul></li><li><span class="tocitem">NQCDistributions.jl</span><ul><li><a class="tocitem" href="../../NQCDistributions/overview/">NQCDistributions.jl</a></li></ul></li><li><span class="tocitem">Initial conditions</span><ul><li><a class="tocitem" href="../../initialconditions/ebk/">Semiclassical EBK quantisation</a></li><li><a class="tocitem" href="../../initialconditions/hamiltonian/">Thermal Hamiltonian Monte Carlo</a></li><li><a class="tocitem" href="../../initialconditions/langevin/">Thermal Langevin dynamics</a></li><li><a class="tocitem" href="../../initialconditions/metropolishastings/">Thermal Metropolis-Hastings Monte Carlo</a></li></ul></li><li><span class="tocitem">Dynamics simulations</span><ul><li><a class="tocitem" href="../../dynamicssimulations/dynamicssimulations/">Introduction</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/classical/">Classical molecular dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/ehrenfest/">Ehrenfest molecular dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/fssh/">Fewest-switches surface hopping (FSSH)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/langevin/">Classical Langevin dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/mdef/">Molecular dynamics with electronic friction (MDEF)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/nrpmd/">Nonadiabatic ring polymer molecular dynamics (NRPMD)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/rpmd/">Ring polymer molecular dynamics (RPMD)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/rpsh/">Ring polymer surface hopping (RPSH)</a></li></ul></li><li><span class="tocitem">Outputs and Analysis</span><ul><li><a class="tocitem" href="../../output_and_analysis/intro/">Simulations outputs and analysis functions</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../mdef_multithermostat/">MDEF with the Two-temperature model and separate Electron and Phonon Thermostats</a></li><li class="is-active"><a class="tocitem" href>Reactive scattering from a metal surface</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#load-PES-model"><span>load PES model</span></a></li><li class="toplevel"><a class="tocitem" href="#Re-build-the-position-and-velocities-for-the-whole-system-Cu56H2"><span>Re build the position and velocities for the whole system Cu56H2</span></a></li><li class="toplevel"><a class="tocitem" href="#load-PES-model-2"><span>load PES model</span></a></li><li class="toplevel"><a class="tocitem" href="#load-cube-EFT-calculator"><span>load cube EFT calculator</span></a></li></ul></li><li><a class="tocitem" href="../spinboson/">Ohmic spin-boson nonequilibrium population dynamics</a></li><li><a class="tocitem" href="../threestatemorse/">Time-dependent populations with the ThreeStateMorse model</a></li><li><a class="tocitem" href="../tully_scattering/">Scattering probabilities for TullyModelTwo</a></li></ul></li><li><a class="tocitem" href="../../integration_algorithms/">Integration algorithms</a></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../../devdocs/diffeq/">DifferentialEquations.jl integration</a></li><li><a class="tocitem" href="../../devdocs/models/">Implementing a new model</a></li><li><a class="tocitem" href="../../devdocs/new_methods/">Contributing a new method</a></li></ul></li><li><span class="tocitem">API</span><ul><li><input class="collapse-toggle" id="menuitem-14-1" type="checkbox"/><label class="tocitem" for="menuitem-14-1"><span class="docs-label">NQCBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCBase/nqcbase/">NQCBase</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14-2" type="checkbox"/><label class="tocitem" for="menuitem-14-2"><span class="docs-label">NQCModels</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCModels/FrictionProviders/">FrictionModels</a></li><li><a class="tocitem" href="../../api/NQCModels/adiabaticmodels/">AdiabaticModels</a></li><li><a class="tocitem" href="../../api/NQCModels/diabaticmodels/">DiabaticModels</a></li><li><a class="tocitem" href="../../api/NQCModels/frictionmodels/">FrictionProviders.jl</a></li><li><a class="tocitem" href="../../api/NQCModels/mace/">MACEModels.jl</a></li><li><a class="tocitem" href="../../api/NQCModels/nonadiabaticmodels/">NQCModels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14-3" type="checkbox"/><label class="tocitem" for="menuitem-14-3"><span class="docs-label">NQCDistributions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCDistributions/nqcdistributions/">NQCDistributions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14-4" type="checkbox"/><label class="tocitem" for="menuitem-14-4"><span class="docs-label">NQCDynamics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCDynamics/analysis/">Analysis</a></li><li><a class="tocitem" href="../../api/NQCDynamics/calculators/">Calculators</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsmethods/">DynamicsMethods</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsoutputs/">DynamicsOutputs</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsutils/">DynamicsUtils</a></li><li><a class="tocitem" href="../../api/NQCDynamics/ensembles/">Ensembles</a></li><li><a class="tocitem" href="../../api/NQCDynamics/estimators/">Estimators</a></li><li><a class="tocitem" href="../../api/NQCDynamics/initialconditions/">InitialConditions</a></li><li><a class="tocitem" href="../../api/NQCDynamics/nonadiabaticmoleculardynamics/">NQCDynamics</a></li><li><a class="tocitem" href="../../api/NQCDynamics/numericutils/">Numerical utilities</a></li><li><a class="tocitem" href="../../api/NQCDynamics/ringpolymers/">RingPolymers</a></li><li><a class="tocitem" href="../../api/NQCDynamics/structure/">Structure</a></li><li><a class="tocitem" href="../../api/NQCDynamics/timecorrelationfunctions/">TimeCorrelationFunctions</a></li></ul></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Reactive scattering from a metal surface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reactive scattering from a metal surface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NQCD/NQCDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NQCD/NQCDynamics.jl/blob/main/docs/src/examples/reactive_scattering.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="example-h2scattering"><a class="docs-heading-anchor" href="#example-h2scattering">Reactive scattering from a metal surface</a><a id="example-h2scattering-1"></a><a class="docs-heading-anchor-permalink" href="#example-h2scattering" title="Permalink"></a></h1><p>Our implementation allows us to simulate vibrational de-excitation probability during reactive scattering events at metal surfaces for any diatomic molecule  with a suitable model to describe energies and forces (and friction coefficients for MDEF simulations).  Here, we investigate the reactive scattering of hydrogen on a Cu(111) metal surface as a prototypical example.</p><p>To run this kind of simulation, a set of initial positions and velocities (<span>$\mathbf{R}$</span> and <span>$\mathbf{\dot{R}}$</span>) with ro-vibrational quantum states <span>$\nu$</span> and <span>$j$</span> have to be generated (see <a href="../../initialconditions/ebk/#ebk-sampling">EBK quantisation</a>). With a specific ro-vibrational quantum state it is possible to compute different properties after molecular collision and energy transfer with the metal surface like the vibrational de-excitation probabilities discussed here.</p><p>In order to reproduce the state-to-state vibrational de-excitation probability results presented originally by [<a href="../../references/#Maurer2019">22</a>] for this system, the same initial conditions were generated with <a href="../../api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.generate_configurations-Tuple{Any, Any, Any}"><code>QuantisedDiatomic.generate_configurations</code></a> setting the initial ro-vibrational quantum state to (<span>$\nu=2, j=0$</span>) as was explored in the original paper. </p><p>As shown earlier in the <a href="../../initialconditions/ebk/#ebk-sampling">EBK documentation</a> we are able to generate a semiclassically quantised distribution for a diatomic molecule on a collision course with a metal surface. In this example we follow the <a href="../../initialconditions/ebk/#ebk-sampling">EBK example</a> using <a href="../../NQCModels/machinelearningmodels/#ml-pes-models"><code>machine learning potential</code></a> to prepare our initial distribution and run our simulation.</p><p>Specifically, we have produced a set of initial conditions with different translational energy (<code>translational_energy</code> keyword) ranging from 0.2 to 1.4 eV, locating the hydrogen molecule 8 Å away from the metal surface (<code>height</code> keyword) with a normal incidence.</p><div class="admonition is-info"><header class="admonition-header">Atomic units</header><div class="admonition-body"><p>As usual, all quantities default to atomic units. Here we use <a href="https://painterqubits.github.io/Unitful.jl/stable/">Unitful</a> to input the translational energy and height using different units, where they are later converted internally.</p></div></div><pre><code class="language-julia hljs"></code></pre><p>julia @example h2scatter using NQCDynamics using Unitful using NQCDynamics.InitialConditions: QuantisedDiatomic using JLD2 using PythonCall</p><p>mace_calc = pyimport(&quot;mace.calculators&quot;)</p><p>atoms = Atoms([:H, :H]) cell = PeriodicCell([11.1175 -5.5588 0.0; 0.0 9.628 0.0; 0.0 0.0 70.3079]) positions = [0.0 0.0; 0.0 0.0; 0.0 0.73] atoms<em>ase = NQCDynamics.convert</em>from<em>ase</em>atoms(atoms, positions, cell) ids_adsorbate = [55,56]</p><h1 id="load-PES-model"><a class="docs-heading-anchor" href="#load-PES-model">load PES model</a><a id="load-PES-model-1"></a><a class="docs-heading-anchor-permalink" href="#load-PES-model" title="Permalink"></a></h1><p>calculator = mace<em>calc.MACECalculator(model</em>path=&quot;../assets/mace/h2cu.model&quot;, device=&quot;cpu&quot;, default<em>dtype=&quot;float32&quot;) atoms</em>ase.set<em>calculator(calculator) model = AdiabaticASEModel(atoms</em>ase)</p><p>sim = Simulation(atoms, model; cell=cell)</p><p>ν, J = 2, 0     # selected ro-vibrational quantum states   nsamples = 10  # number of configurations       Ek = 0.5u&quot;eV&quot;   # Translational energy [eV] ; range considered [0.2-1.4] eV z = 8.0u&quot;Å&quot;     # Height [Å]  ; fixed at 8 Å z = ang<em>to</em>au(z)</p><p>configurations = QuantisedDiatomic.generate<em>configurations(sim, ν, J;     samples=nsamples, translational</em>energy=Ek, height=z) v<em>h2 = first.(configurations) r</em>h2 = last.(configurations)</p><h1 id="Re-build-the-position-and-velocities-for-the-whole-system-Cu56H2"><a class="docs-heading-anchor" href="#Re-build-the-position-and-velocities-for-the-whole-system-Cu56H2">Re build the position and velocities for the whole system Cu56H2</a><a id="Re-build-the-position-and-velocities-for-the-whole-system-Cu56H2-1"></a><a class="docs-heading-anchor-permalink" href="#Re-build-the-position-and-velocities-for-the-whole-system-Cu56H2" title="Permalink"></a></h1><p>dof = 3 ase<em>io = pyimport(&quot;ase.io&quot;) surface</em>ase = ase<em>io.read(&quot;../assets/h2cu/h2cu</em>surf.traj@:nsamples&quot;)</p><p>n<em>atoms = length(atoms) v = [zeros(dof,n</em>atoms) for i=1:length(r<em>h2)] r = [zeros(dof,n</em>atoms) for i=1:length(r_h2)]</p><p>for i in 1:length(r<em>h2)     surf</em>atoms, surf<em>positions, surf</em>cell = NQCDynamics.convert<em>from</em>ase<em>atoms(surface</em>ase[i])     r[i][:,1:n<em>atoms-2] .= surf</em>positions     r[i][:,n<em>atoms-1:n</em>atoms] .= r_h2[i]  </p><pre><code class="nohighlight hljs">v[i][:,1:n_atoms-2] .= austrip.(transpose(surface_ase[i].get_velocities().*ase_units.fs)*u&quot;Å/fs&quot;)
v[i][:,n_atoms-1:n_atoms] .= v_h2[i]</code></pre><p>end</p><p>atoms<em>ase = ase</em>io.read(&quot;../assets/h2cu/h2cu<em>init.in&quot;) atoms, positions, cell = convert</em>from<em>ase</em>atoms(atoms_ase)</p><p>distribution = DynamicalDistribution(v, r, (dof,length(atoms_ase))) nothing # hide</p><pre><code class="nohighlight hljs">
!!! tip &quot;Saving the distribution&quot;

    Generally it will be desirable to generate a distribution once and re-use it for multiple dynamics simulations.
    The simplest way to do this is to save the distribution using [JLD2.jl](https://juliaio.github.io/JLD2.jl/dev/).
    Refer to [Saving and loading](@ref saving-and-loading) to learn more.

In order to produce an unweighted distribution, the lateral and angular orientation are randomly selected within the unit cell.
As an example of the spacial and orientation distribution generated with this module, a subset of data (300 configurations) is shown below.
To run our production simulations, however, a set of 80,000 initial velocities and positions were used.

![initial conditions](../assets/figures/icond_scatter.png)

## Data analysis and truncation function

Since we are interested in the dynamics only when the molecule is close to the surface,
we can use a callback to terminate the simulation early to save us some time.
This requires defining a function that returns `true` when we want the simulation to
terminate.
This means we can set our time span relatively long since we expect most simulations to
terminate before reaching the time limit.
</code></pre><p>julia @example h2scatter using Statistics: mean using LinearAlgebra: norm</p><p>h2distance(p) = norm(p[:,ids<em>adsorbate[1]] .- p[:,ids</em>adsorbate[2]])</p><p>&quot;Terminates simulation if returns <code>true</code>.&quot;  mutable struct TrajectoryTerminator     h2<em>indices     ads</em>height<em>cutoff     ads</em>dist<em>cutoff     n</em>atoms<em>layer end function (t::TrajectoryTerminator)(u, t, integrator)::Bool     R = get</em>positions(u)     com<em>h2</em>z = minimum(R[3,t.h2<em>indices[1]:t.h2</em>indices[2]])     top<em>surface</em>avg<em>z = mean(R[3,end-Int(t.n</em>atoms<em>layer)-1:end-2])     zcom = au</em>to<em>ang(com</em>h2<em>z-top</em>surface<em>avg</em>z) # Convert vertical centre of mass to angstrom     if zcom &gt; t.ads<em>height</em>cutoff                         # Scattering event         return true     elseif au<em>to</em>ang(h2distance(R)) &gt; t.ads<em>dist</em>cutoff   # Reactive event         return true     else         return false     end end</p><p>termination<em>condition = TrajectoryTerminator(ids</em>adsorbate, 8.1, 2.5, 9) terminate = DynamicsUtils.TerminatingCallback(termination_condition) tspan = (0.0, 420.0u&quot;fs&quot;) nothing # hide</p><pre><code class="nohighlight hljs">In this example, we consider the outcome a reactive event if the H-H
bond length is larger than 2.5 Å in any point of during the trajectory and a
scattering event if the molecule rebounds to a vertical distance from the metal
surface greater than 8.1 Å.

## MDEF with the LDFA

Now that we have set up the initial distribution and some of our simulation parameters,
we can choose which form of friction we would like use.
First, let&#39;s use the cube-based density implementation for LDFA friction provided by the
[FrictionProviders.jl](@ref friction-providers).
This takes a `.cube` file containing the electron density and will provide the friction
during the dynamics.
Here we initialize the MACE-based interatomic potential, together with the cube-based calculator.
</code></pre><p>julia @example h2scatter</p><h1 id="load-PES-model-2"><a class="docs-heading-anchor" href="#load-PES-model-2">load PES model</a><a class="docs-heading-anchor-permalink" href="#load-PES-model-2" title="Permalink"></a></h1><p>calculator = mace<em>calc.MACECalculator(model</em>path=&quot;../assets/mace/h2cu.model&quot;, device=&quot;cpu&quot;, default<em>dtype=&quot;float32&quot;) atoms</em>ase.set<em>calculator(calculator) model</em>pes = AdiabaticASEModel(atoms_ase)</p><h1 id="load-cube-EFT-calculator"><a class="docs-heading-anchor" href="#load-cube-EFT-calculator">load cube EFT calculator</a><a id="load-cube-EFT-calculator-1"></a><a class="docs-heading-anchor-permalink" href="#load-cube-EFT-calculator" title="Permalink"></a></h1><p>using FrictionProviders density<em>model = CubeLDFA(&quot;../assets/friction/test.cube&quot;, cell) model</em>eft = LDFAFriction(density<em>model, atoms; friction</em>atoms=ids_adsorbate)</p><pre><code class="nohighlight hljs">
Now we can pass all the variables defined so far to the `Simulation` and run multiple
trajectories using [`run_dynamics`](@ref).
</code></pre><p>julia model = CompositeFrictionModel(model<em>pes, model</em>eft) sim = Simulation{MDEF}(atoms, model, cell=cell, temperature=300u&quot;K&quot;) ensemble = run_dynamics(sim, tspan, distribution; selection=1:nsamples,     dt=0.1u&quot;fs&quot;, output=OutputPosition, trajectories=nsamples, callback=terminate)</p><pre><code class="nohighlight hljs">


## MDEF with machine-learned LDFA 

Above, we used the cube-based LDFA interpretation of MDEF to perform the simulation.
However, in this scheme, surface atoms have to stay fixed to match the cube densities. To include surface temperature effects machine learning models can be trained that predict densities at any surface configuration.
Here, we run MDEF simulation employing two machine learning models, to predict adiabatic PES (based on [MACE](https://github.com/ACEsuit/mace)) and surface electron density (based on [ACEpotentials.jl](https://github.com/ACEsuit/ACEpotentials.jl)), utilizing [FrictionProviders.jl](https://github.com/NQCD/FrictionProviders.jl), to run MDEF simulation.
</code></pre><p>julia using ACEpotentials ace<em>model, ace</em>model<em>meta = ACEpotentials.load</em>model(&quot;../assets/ace<em>ldfa/model.json&quot;) density</em>model = AdiabaticModels.ACEpotentialsModel(atoms, cell, ace<em>model)  ace</em>density<em>model = AceLDFA(density</em>model) model<em>eft = LDFAFriction(ace</em>density<em>model, atoms; friction</em>atoms=ids_adsorbate)</p><p>model = CompositeFrictionModel(model<em>pes, model</em>eft)</p><p>sim = Simulation{MDEF}(atoms, model, cell=cell, temperature=300u&quot;K&quot;) ensemble = run_dynamics(sim, tspan, distribution; selection=1:nsamples,     dt=0.1u&quot;fs&quot;, output=OutputPosition, trajectories=nsamples, callback=terminate)</p><pre><code class="nohighlight hljs">
## MDEF with machine-learned TDPT (ODF)

Above, we used the LDFA interpretation of MDEF to perform the simulation. However, an alternative, TDPT (otherwise known as ODF) method can be used that provides full friction tensor. TDPT ML models can be incorporated in our simulation in a similar way as LDFA models, through (FrictionProviders.jl)[https://github.com/NQCD/FrictionProviders.jl]. Here, we show how this can be done for (ACEds)[https://github.com/ACEsuit/ACEds.jl] models. Such models require the usage of (JuLIP)[https://github.com/JuliaMolSim/JuLIP.jl]-type atoms. We can easily convert our ASE-type atoms into such format:
</code></pre><p>julia using ASE, JuLIP atoms<em>ase</em>jl = ASE.ASEAtoms(atoms<em>ase) atoms</em>julip = JuLIP.Atoms(atoms<em>ase</em>jl)</p><pre><code class="nohighlight hljs">
Having our atoms, ACEds EFT models can be then initialized and combined with previously loaded potential model.
</code></pre><p>julia using ACE using ACEds.FrictionModels using ACEds.FrictionModels: Gamma aceds<em>model = ACEdsODF(read</em>dict(load<em>dict(&quot;../assets/ace</em>friction/eft<em>ac.model&quot;)), Gamma, atoms</em>julip) model<em>eft = ODFriction(ace</em>model; friction<em>atoms=ids</em>adsorbate)</p><p>model = CompositeFrictionModel(model<em>pes, model</em>eft)</p><p>sim = Simulation{MDEF}(atoms, model, cell=cell, temperature=300u&quot;K&quot;) ensemble = run_dynamics(sim, tspan, distribution; selection=1:nsamples,     dt=0.1u&quot;fs&quot;, output=OutputPosition, trajectories=nsamples, callback=terminate)</p><pre><code class="nohighlight hljs">
## Visualisation

To show the effect of the truncation procedure, we have run 20 trajectories with and without the truncation
function starting with an initial translation energy at 1.0 eV. For both figures, the total and kinetic energies are shown in
the top panels along with the H-H distance and centre of mass z coordinate for each
individual trajectory.

![truncation](../assets/figures/scattering_truncation.png)


</code></pre><p>@setup logging runtime = round(time() - start_time; digits=2) @info &quot;...done after runtime s.&quot; ```</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mdef_multithermostat/">« MDEF with the Two-temperature model and separate Electron and Phonon Thermostats</a><a class="docs-footer-nextpage" href="../spinboson/">Ohmic spin-boson nonequilibrium population dynamics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Thursday 6 March 2025 17:14">Thursday 6 March 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
