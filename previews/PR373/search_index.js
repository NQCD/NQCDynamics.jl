var documenterSearchIndex = {"docs":
[{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"@info \"Expanding src/examples/spinboson.md...\"\nstart_time = time()","category":"page"},{"location":"examples/spinboson/#Ohmic-spin-boson-nonequilibrium-population-dynamics","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"","category":"section"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"The spin-boson model is widely used as a model for condensed phase quantum dynamics. It is defined by a system-bath Hamiltonian where the system is a 2-state spin coupled to a bath of harmonic oscillators. This example shows how to perform nonequilibrium population dynamics with the spin-boson model using a bath characterised by the Ohmic spectral density. We will be using model B from the work of [23].","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"Our boson bath will have 100 oscillators, each with a mass of 1. Here, we also set up the model with the ohmic density and the parameters that match up with our reference ([23]). The ohmic density is given a cutoff frequency of 2.5 and a Kondo parameter of 0.09. The model is symmetric, with the energy bias between states equal to 0.0, and the coupling between states set to 1.","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"using NQCDynamics\nN = 100\natoms = Atoms(fill(1, N))\nβ = 5\nT = 1 / β\ndensity = OhmicSpectralDensity(2.5, 0.09)\nmodel = SpinBoson(density, N, 0.0, 1.0)\nnothing # hide","category":"page"},{"location":"examples/spinboson/#Initial-conditions","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Initial conditions","text":"","category":"section"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"For the initial conditions, we will sample directly from a Wigner distribution for the nuclear degrees of freedom. Since our nuclear degrees of freedom are harmonic, the Wigner distribution has an analytic form and we can use the distributions included in the package. The position and velocity variables we create here are Matrixs of Normal distributions, which are shaped to match the system size (1, N). Inside the DynamicalDistribution they will provide samples that match the size of the system. The initial electronic state is confined to 1 with PureState(1).","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"position = reshape([PositionHarmonicWigner(ω, β, 1) for ω in model.ωⱼ], 1, :)\nvelocity = reshape([VelocityHarmonicWigner(ω, β, 1) for ω in model.ωⱼ], 1, :)\ndistribution = DynamicalDistribution(velocity, position, (1, 100)) * PureState(1)\nnothing # hide","category":"page"},{"location":"examples/spinboson/#Dynamics","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Dynamics","text":"","category":"section"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"Now that we have a distribution from which we can sample our initial conditions, we can run ensembles of trajectories and calculate the population correlation functions. Let's compare the results obtained using FSSH and Ehrenfest.","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"fssh = Simulation{FSSH}(atoms, model)\nehrenfest = Simulation{Ehrenfest}(atoms, model)\n\nsaveat = 0:0.1:20\noutput = TimeCorrelationFunctions.PopulationCorrelationFunction(fssh, Diabatic())\nensemble_fssh = run_dynamics(fssh, (0.0, 20.0), distribution;\n    saveat=saveat, trajectories=100, output, reduction=MeanReduction(), dt=0.1)\noutput = TimeCorrelationFunctions.PopulationCorrelationFunction(ehrenfest, Diabatic())\nensemble_ehrenfest = run_dynamics(ehrenfest, (0.0, 20.0), distribution;\n    saveat=saveat, trajectories=100, output, reduction=MeanReduction(), dt=0.1)\nnothing # hide","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"Here, we can see the population difference between the two states.","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"using Plots\nplot(saveat, [p[1,1] - p[1,2] for p in ensemble_fssh[:PopulationCorrelationFunction]], label=\"FSSH\")\nplot!(saveat, [p[1,1] - p[1,2] for p in ensemble_ehrenfest[:PopulationCorrelationFunction]], label=\"Ehrenfest\")\nxlabel!(\"Time /a.u.\")\nylabel!(\"Population difference\")","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"The exact result for this model, along with various mapping methods can be found  in the work of [23]. We can see that even with just 100 trajectories, our Ehrenfest result closely matches theirs. The FSSH is quite clearly underconverged with only 100 trajectories due to the discontinuous nature of the individual trajectories. Feel free to try this for yourself and see what the converged FSSH result looks like!","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCDynamics/analysis/","page":"Analysis","title":"Analysis","text":"@info \"Expanding src/api/NQCDynamics/analysis.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCDynamics/analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"api/NQCDynamics/analysis/","page":"Analysis","title":"Analysis","text":"Modules=[NQCDynamics.Analysis, NQCDynamics.Analysis.Diatomic, NQCDynamics.Analysis.RigidRotator, NQCDynamics.Analysis.Postprocess]","category":"page"},{"location":"api/NQCDynamics/analysis/#NQCDynamics.Analysis","page":"Analysis","title":"NQCDynamics.Analysis","text":"Analysis functions common enough to be included in the main package.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/analysis/#NQCDynamics.Analysis.Diatomic","page":"Analysis","title":"NQCDynamics.Analysis.Diatomic","text":"Analysis functions for surface chemistry of diatomic molecules.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/analysis/#NQCDynamics.Analysis.Diatomic.close_approach_condition-Tuple{AbstractArray, Vector{Int64}, NQCDynamics.AbstractSimulation}","page":"Analysis","title":"NQCDynamics.Analysis.Diatomic.close_approach_condition","text":"close_approach_condition(x::AbstractArray, indices::Vector{Int}, simulation::AbstractSimulation; threshold = 1.5u\"Å\")\n\nEvaluate true if the diatomic bond length is below `threshold`.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/analysis/#NQCDynamics.Analysis.Diatomic.com_velocity_condition-Tuple{AbstractArray, Vector{Int64}, NQCDynamics.AbstractSimulation}","page":"Analysis","title":"NQCDynamics.Analysis.Diatomic.com_velocity_condition","text":"com_velocity_condition(x::AbstractArray, indices::Vector{Int}, simulation::AbstractSimulation; surface_normal::AbstractVector=[0,0,1])\n\nEvaluates true if the centre of mass velocity vector of the diatomic molecule points to the surface.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/analysis/#NQCDynamics.Analysis.Diatomic.get_desorption_frame-Tuple{AbstractVector, Vector{Int64}, NQCDynamics.AbstractSimulation}","page":"Analysis","title":"NQCDynamics.Analysis.Diatomic.get_desorption_frame","text":"get_desorption_frame(trajectory::AbstractVector, diatomic_indices::Vector{Int}, simulation::AbstractSimulation; surface_normal::Vector=[0, 0, 1], surface_distance_threshold=5.0 * u\"Å\", fallback_distance_threshold = 1.5u\"Å\")\n\nDetermines the index in a trajectory where surface desorption begins.\n\nThis is evaluated using two conditions:\n\nIn the trajectory, the diatomic must be surface_distance_threshold or further away from the highest other atom. (In surface_normal direction).\nDesorption begins at the turning point of the centre of mass velocity component along surface_normal, indicating overall movement away from the surface.\n\nIf the second condition is never reached (can happen for particularly quick desorptions), the fallback_distance_threshold is used to find the last point where the diatomic bond length is above the given value and saves from that point onwards. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/analysis/#NQCDynamics.Analysis.Diatomic.surface_distance_condition-Tuple{AbstractArray, Vector{Int64}, NQCDynamics.AbstractSimulation}","page":"Analysis","title":"NQCDynamics.Analysis.Diatomic.surface_distance_condition","text":"surface_distance_condition(x::AbstractArray, indices::Vector{Int}, simulation::AbstractSimulation; surface_distance_threshold=5.0*u\"Å\")\n\nChecks that the diatomic molecule is at least `surface_distance_threshold` away from the highest substrate atom in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/analysis/#NQCDynamics.Analysis.Diatomic.transform_U-Tuple{Matrix, Int64, Int64, Simulation}","page":"Analysis","title":"NQCDynamics.Analysis.Diatomic.transform_U","text":"transform_U(config::Matrix, index1::Int, index2::Int, sim::Simulation)\n\nBuilds diatomic Cartesian to internal coordinate transformation matrix as described in the SI of 10.1021/jacsau.0c00066\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/analysis/#NQCDynamics.Analysis.RigidRotator.classical_rotation_energy-Tuple{Int64, Any, Union{Int64, CartesianIndex}, Union{Int64, CartesianIndex}, NQCDynamics.AbstractSimulation}","page":"Analysis","title":"NQCDynamics.Analysis.RigidRotator.classical_rotation_energy","text":"classical_rotation_energy(J::Union{Int, CartesianIndex}, config::Any, ind1::Union{Int, CartesianIndex}, ind2::Union{Int, CartesianIndex}, sim::Simulation)\n\nClassical rotation energy of a rigid diatomic rotor in Hartree\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/analysis/#NQCDynamics.Analysis.RigidRotator.classical_translational_energy-Tuple{Any, Union{Int64, CartesianIndex}, Union{Int64, CartesianIndex}, NQCDynamics.AbstractSimulation}","page":"Analysis","title":"NQCDynamics.Analysis.RigidRotator.classical_translational_energy","text":"classical_translational_energy(config::Any, ind1::Union{Int, CartesianIndex}, ind2::Union{Int, CartesianIndex}, sim::Simulation)\n\nReturns the classical translational energy in Hartree\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/analysis/#NQCDynamics.Analysis.RigidRotator.harmonic_vibration_energy-Tuple{Int64, Float64, Union{Int64, CartesianIndex}, Union{Int64, CartesianIndex}, NQCDynamics.AbstractSimulation}","page":"Analysis","title":"NQCDynamics.Analysis.RigidRotator.harmonic_vibration_energy","text":"harmonic_vibration_energy(ν::Union{Int, CartesianIndex}, k::Float, ind1::Union{Int, CartesianIndex}=1, ind2::Union{Int, CartesianIndex}=2, sim::Simulation)\n\nVibrational energy of a harmonic oscillator with the force constant k and vibrational level ν.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/analysis/#NQCDynamics.Analysis.Postprocess.apply_output_functions-Tuple{Any, Any}","page":"Analysis","title":"NQCDynamics.Analysis.Postprocess.apply_output_functions","text":"apply_output_functions(sol::FakeSolution, output_functions; savetime::Bool=true)\n\nEvaluates output functions on a DifferentialEquations.jl solution object or fake solution object generated using a defined Simulation and a DynamicsVariables type.\n\nBasically equivalent to running run_dynamics() with the same output functions, but without doing the dynamics simulation again.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/analysis/#NQCDynamics.Analysis.Postprocess.apply_output_functions-Tuple{NQCDynamics.AbstractSimulation, AbstractVector, AbstractVector, Any}","page":"Analysis","title":"NQCDynamics.Analysis.Postprocess.apply_output_functions","text":"apply_output_functions(sim<:AbstractSimulation, u_type::AbstractVector, t_type::AbstractVector, output_functions; savetime::Bool=true)\n\nEvaluates output functions on a defined Simulation, a DynamicsVariables type output and a time-type output.\n\nBasically equivalent to running run_dynamics() with the same output functions, but without doing the dynamics simulation again.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/analysis/","page":"Analysis","title":"Analysis","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"NQCModels/combining_models/","page":"Composing multiple models","title":"Composing multiple models","text":"@info \"Expanding src/NQCModels/combining_models.md...\"\nstart_time = time()","category":"page"},{"location":"NQCModels/combining_models/#Composing-multiple-models","page":"Composing multiple models","title":"Composing multiple models","text":"","category":"section"},{"location":"NQCModels/combining_models/#Why?","page":"Composing multiple models","title":"Why?","text":"","category":"section"},{"location":"NQCModels/combining_models/","page":"Composing multiple models","title":"Composing multiple models","text":"For some non-adiabatic dynamics methods, we would like to calculate certain quantities using a number of different approximations or different machine learning model interfaces.  However, a model for a potential energy surface does not and should not be able to provide e.g. an electronic friction tensor.  Instead, we can use the modular nature of NQCModels.jl to combine different components to a non-adiabatic dynamics method into a single model that can be used to set up a Simulation","category":"page"},{"location":"NQCModels/combining_models/","page":"Composing multiple models","title":"Composing multiple models","text":"For example, in order to run Molecular Dynamics with Electronic friction, we need to use a Model which supports the following methods:","category":"page"},{"location":"NQCModels/combining_models/","page":"Composing multiple models","title":"Composing multiple models","text":"potential to determine the total energy\nderivative to determine interatomic forces\nfriction to determine the electronic friction tensor","category":"page"},{"location":"NQCModels/combining_models/","page":"Composing multiple models","title":"Composing multiple models","text":"However, most models for potential energy surfaces only provide potential and derivative, whereas friction! is provided by an ElectronicFrictionProvider. ","category":"page"},{"location":"NQCModels/combining_models/","page":"Composing multiple models","title":"Composing multiple models","text":"To combine different models together for a system, we can use Subsystems to define which atoms in the system a given model should be applied to, and a CompositeModel to combine the different models into one.  If different Subsystems should experience different effective temperatures, a TemperatureSetting can be provided when initialising a Simulation. ","category":"page"},{"location":"NQCModels/combining_models/","page":"Composing multiple models","title":"Composing multiple models","text":"(Image: An overview of the different components used to combine models in NQCModels.jl)","category":"page"},{"location":"NQCModels/combining_models/#Example:-Combining-an-AdiabaticModel-with-ElectronicFrictionProviders","page":"Composing multiple models","title":"Example: Combining an AdiabaticModel with ElectronicFrictionProviders","text":"","category":"section"},{"location":"NQCModels/combining_models/","page":"Composing multiple models","title":"Composing multiple models","text":"using NQCDynamics\n\natoms = vcat([:H, :H], [:Cu for _ in 1:54]) # create example surface structure\npositions = rand(3,56) # Placeholder for atomic positions\npes_model = Subsystem(Free(3)) # PES model with potential and derivative\nfriction_model = Subsystem(RandomFriction(3)) # Friction model supporting friction! only\n\nprintln(\"PES model: \\n\", pes_model, \"\\nFriction model:\", \"friction_model\")\n\ncomplete_model = CompositeModel(pes_model, friction_model)","category":"page"},{"location":"NQCModels/combining_models/","page":"Composing multiple models","title":"Composing multiple models","text":"As shown above, we have combined the RandomFriction provider with a model potential to give a total model which can be used in a simulation. ","category":"page"},{"location":"NQCModels/combining_models/","page":"Composing multiple models","title":"Composing multiple models","text":"println(\"Potential: \", NQCModels.potential(complete_model, positions))\nprintln(\"Derivative: \", NQCModels.derivative(complete_model, positions))\nprintln(\"Friction: \", NQCModels.friction(complete_model, positions))","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"@info \"Expanding src/examples/tully_scattering.md...\"\nstart_time = time()","category":"page"},{"location":"examples/tully_scattering/#examples-tully-model-two","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"","category":"section"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"In this section we aim to reproduce the results of Fig. 5 from [1]. This figure presents the scattering outcomes when a particle interacts with Tully's model 2 with an increasing magnitude of incident kinetic energy.","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"To reproduce this figure, first, let's set up our system parameters:","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"using NQCDynamics\n\nsim = Simulation{FSSH}(Atoms(2000), TullyModelTwo())","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"!!! note Atomic units","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"Recall that all of are units are atomic by default, this mass of 2000 is similar to\nthat of a hydrogen atom.","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"Each data point in the figure is obtained from an ensemble average of trajectories. We can use our Ensembles setup to run a set of trajectories for every single momentum value. Firstly, we can prepare the parts that will be the same for every ensemble:","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"using ComponentArrays: ComponentVector\n\noutput = OutputStateResolvedScattering1D(sim, :adiabatic)","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"Here, we are using the OutputStateResolvedScattering1D along with the MeanReduction which will give us the average scattering outcome from the entire ensemble. Each trajectory outputs the scattering outcome along with its final adiabatic state, and the reduction computes the average over all trajectories.","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"Next, we can choose how many trajectories we want to perform for each ensemble, and choose the range of momentum values:","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"trajectories = 500\nmomenta = 9:2:50","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"note: Range notation\nHere we uses Julia's range operator to generate a set of values from 9 to 50 with a spacing of 2: 9, 11, 13, ..., 49. The final value of 50 is not included since a step size of 2 starting from 9 allows us to include only odd numbers.","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"Since each ensemble requires different initial conditions, we will specify the trajectory timespan and the distribution inside the loop. Before the loop begins, we will create an empty list to store the results, and append to this list after every iteration. The distribution we create produces initial conditions where each trajectory has momentum k and starts at a position of -5. ","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"result = []\nfor k in momenta # Iterate through each momentum value\n    v = k / sim.atoms.masses[1] # Starting velocity\n    r = -5 # Starting position\n    tspan = (0, 2abs(r)/v)\n    distribution = DynamicalDistribution(v, -5, size(sim)) * PureState(1, Adiabatic())\n\n    out = run_dynamics(sim, tspan, distribution;\n        saveat=tspan[end], trajectories, output, reduction=MeanReduction()\n    )\n\n    push!(result, out[:OutputStateResolvedScattering1D])\nend\n\nresult","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"tip: Adaptive timespan\nSince the trajectories with larger momentum will exit the scattering region sooner, we scale the timespan to save computational time. Using tspan = (0, 2abs(r)/v) allows enough time such that a particle will be able to travel a total distance of 2r at a constant velocity of v. This is sufficient to ensure the particle has left the interaction region. Alternatively, we could define a callback to terminate the simulation early.","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"Now we can plot our simulation results. We format this plot to match Fig. 3 from [18] which also reproduces Fig. 5 from [1]. We manage to reproduce the FSSH results quite accurately by visual comparison, though a larger number of trajectories would lead to better convergence. Since all of the examples run during the documentation build, we use a minimal number of trajectories to optimise the build time.","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"using Plots\n\nplot(\n    xlabel=\"Incidence momentum / a.u.\",\n    ylabel=\"Scattering probability\"\n)\n\nr1 = [r.reflection[1] for r in result]\nt1 = [r.transmission[1] for r in result]\nt2 = [r.transmission[2] for r in result]\n\nscatter!(momenta, r1; label=\"R1\", color=:red)\nscatter!(momenta, t1; label=\"T1\", color=:green)\nscatter!(momenta, t2; label=\"T2\", color=:blue)","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"As in [18], R1, T1, T2 refer to reflection on state 1, transmission on state 1 and transmission on state 2 respectively. For this model, surface hopping is successful in closely approximating the exact quantum result, especially at higher momentum values. Refer to [1] and [18] for a detailed discussion of the results.","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCDynamics/structure/","page":"Structure","title":"Structure","text":"@info \"Expanding src/api/NQCDynamics/structure.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCDynamics/structure/#Structure","page":"Structure","title":"Structure","text":"","category":"section"},{"location":"api/NQCDynamics/structure/","page":"Structure","title":"Structure","text":"This submodule contains utility functions to analyse and modify atomic structure data, such as interatomic distances, centres of mass, both with and without support for periodic boundary conditions.","category":"page"},{"location":"api/NQCDynamics/structure/","page":"Structure","title":"Structure","text":"These functions can be used to build more sophisticated output functions, or for basic analysis of simulation results in post.","category":"page"},{"location":"api/NQCDynamics/structure/","page":"Structure","title":"Structure","text":"This module doesn't contain:","category":"page"},{"location":"api/NQCDynamics/structure/","page":"Structure","title":"Structure","text":"Basic definitions of atomic structures (e.g. Atoms, PeriodicCell, ...). These are defined in NQCBase.\nFunctions to generate atomic structures. These should be added to NQCDynamics.InitialConditions.\nAnalysis functions for specific systems (e.g. molecules on surfaces). These should be added to NQCDynamics.Analysis.","category":"page"},{"location":"api/NQCDynamics/structure/#Method-reference","page":"Structure","title":"Method reference","text":"","category":"section"},{"location":"api/NQCDynamics/structure/","page":"Structure","title":"Structure","text":"Modules=[NQCDynamics.Structure]","category":"page"},{"location":"api/NQCDynamics/structure/#NQCDynamics.Structure.angle_between-Tuple{Vector, Vector}","page":"Structure","title":"NQCDynamics.Structure.angle_between","text":"angle_between(v1::Vector, v2::Vector)\n\nReturns the angle between two vectors in º based on the scalar product definition. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/structure/#NQCDynamics.Structure.center_of_mass-Tuple{Matrix, Int64, Int64, Atoms}","page":"Structure","title":"NQCDynamics.Structure.center_of_mass","text":"center_of_mass(config::Matrix, ind1::Int, ind2::Int, atoms::Atoms)\n\nGenerates center of mass coordinates for two atoms. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/structure/#NQCDynamics.Structure.distance-Tuple{AbstractVector, Union{Int64, CartesianIndex}, Union{Int64, CartesianIndex}}","page":"Structure","title":"NQCDynamics.Structure.distance","text":"distance(config::AbstractVector, i1::int_or_index, i2::int_or_index)\nInteratomic distance in Angstrom for DynamicsVariables.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/structure/#NQCDynamics.Structure.distance-Tuple{Matrix, Union{Int64, CartesianIndex}, Union{Int64, CartesianIndex}}","page":"Structure","title":"NQCDynamics.Structure.distance","text":"distance(config::Matrix, i1, i2)\n\nInteratomic distance in Angstrom for a position Matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/structure/#NQCDynamics.Structure.fractional_mass-Tuple{Atoms, Union{Int64, CartesianIndex}, Union{Int64, CartesianIndex}}","page":"Structure","title":"NQCDynamics.Structure.fractional_mass","text":"fractional_mass(sim::Simulation, index1::Int, index2::Int)\n\nReturns m1/(m1+m2) and m2/(m1+m2) as a vector. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/structure/#NQCDynamics.Structure.fractional_mass-Tuple{NQCDynamics.AbstractSimulation, Int64, Int64}","page":"Structure","title":"NQCDynamics.Structure.fractional_mass","text":"fractional_mass(sim::NQCDynamics.AbstractSimulation, index1::Int, index2::Int)\n\nReturns m1/(m1+m2) and m2/(m1+m2) as a vector. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/structure/#NQCDynamics.Structure.minimum_distance_translation-Tuple{Matrix, Int64, Int64, PeriodicCell}","page":"Structure","title":"NQCDynamics.Structure.minimum_distance_translation","text":"minimum_distance_translation(config::Matrix, ind1::Int, ind2::Int, simulation::AbstractSimulation)\n\nOutputs a translation vector to move config[:,ind2] such that the closest distance between ind1 and ind2 is reached.  **The search of neighbouring unit cells will expand until the cutoff. If configurations are already subject to a minimum image convention, cutoff=1 reduces unnecessary overhead. **\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/structure/#NQCDynamics.Structure.pbc_center_of_mass-Tuple{Matrix, Int64, Int64, PeriodicCell, Atoms}","page":"Structure","title":"NQCDynamics.Structure.pbc_center_of_mass","text":"pbc_center_of_mass(config::Matrix, ind1::Int, ind2::Int, cell::PeriodicCell, atoms::Atoms;args...)\n\nGenerates center of mass coordinates for two atoms, including a check if the copy of the second atom in any neighbouring unit cell is closer. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/structure/#NQCDynamics.Structure.pbc_distance-Tuple{Matrix, Union{Int64, CartesianIndex}, Union{Int64, CartesianIndex}, PeriodicCell}","page":"Structure","title":"NQCDynamics.Structure.pbc_distance","text":"pbc_distance(config::Matrix, ind1::int_or_index, ind2::int_or_index, simulation::NQCDynamics.AbstractSimulation)\n\nReturns in Angstom, not in Bohr - Check units.\n\nCalculates the distance between two atoms, including a check if the copy of the second atom in any neighbouring unit cell is closer.  This variant is designed for trajectories where cell boundary wrapping has been used. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/structure/#NQCDynamics.Structure.reduced_mass-Tuple{Atoms, Int64, Int64}","page":"Structure","title":"NQCDynamics.Structure.reduced_mass","text":"reduced_mass(sim::Simulation, index1::Int, index2::Int)\n\nReturns the reduced mass of the diatomic in atomic unit. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/structure/#NQCDynamics.Structure.velocity_center_of_mass-Tuple{Matrix, Int64, Int64, Atoms}","page":"Structure","title":"NQCDynamics.Structure.velocity_center_of_mass","text":"velocity_center_of_mass(config::Matrix, ind1::Int, ind2::Int, simulation::NQCDynamics.AbstractSimulation)\n\nsum(m_i*v_i)/sum(m_i)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/structure/","page":"Structure","title":"Structure","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCModels/FrictionProviders/","page":"FrictionModels","title":"FrictionModels","text":"@info \"Expanding src/api/NQCModels/frictionmodels.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCModels/FrictionProviders/#FrictionModels","page":"FrictionModels","title":"FrictionModels","text":"","category":"section"},{"location":"api/NQCModels/FrictionProviders/","page":"FrictionModels","title":"FrictionModels","text":"Modules=[NQCModels.FrictionModels]","category":"page"},{"location":"api/NQCModels/FrictionProviders/#NQCModels.FrictionModels.ASEFrictionProvider","page":"FrictionModels","title":"NQCModels.FrictionModels.ASEFrictionProvider","text":"ASEFrictionProvider{A} <: ElectronicFrictionProvider\n\nObtain the electronic friction from an ASE calculator that implements get_friction_tensor. Assumes that the units of friction are \"eV/Å/Å\". Construct by passing the ase atoms object with the calculator already attached.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/FrictionProviders/#NQCModels.FrictionModels.AdiabaticFrictionModel","page":"FrictionModels","title":"NQCModels.FrictionModels.AdiabaticFrictionModel","text":"AdiabaticFrictionModel <: AdiabaticModel\n\nAdiabaticFrictionModels must implement potential!, derivative!, and friction!\n\npotential! and friction! should be the same as for the AdiabaticModel.\n\nfriction! must fill an AbstractMatrix with size = (ndofs*natoms, ndofs*natoms).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/FrictionProviders/#NQCModels.FrictionModels.CompositeFrictionModel","page":"FrictionModels","title":"NQCModels.FrictionModels.CompositeFrictionModel","text":"CompositeFrictionModel{M,F} <: AdiabaticFrictionModel\n\nCombine an AdiabaticModel with an ElectronicFrictionProvider.\n\nThis allows for arbitrary composition of potentials and friction providers, such that any adiabatic model can be augmented with any form of electronic friction.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/FrictionProviders/#NQCModels.FrictionModels.ElectronicFrictionProvider","page":"FrictionModels","title":"NQCModels.FrictionModels.ElectronicFrictionProvider","text":"ElectronicFrictionProvider\n\nAbstract type for defining models that provide electronic friction only. Subtypes of this should implement friction! and ndofs.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/FrictionProviders/#NQCModels.FrictionModels.RandomFriction","page":"FrictionModels","title":"NQCModels.FrictionModels.RandomFriction","text":"RandomFriction <: ElectronicFrictionProvider\n\nProvide a random positive semi-definite matrix of friction values. Used mostly for testing and examples.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/FrictionProviders/#NQCModels.FrictionModels.friction!","page":"FrictionModels","title":"NQCModels.FrictionModels.friction!","text":"friction!(model::AdiabaticFrictionModel, F, R:AbstractMatrix)\n\nFill F with the electronic friction as a function of the positions R.\n\nThis need only be implemented for AdiabaticFrictionModels.\n\n\n\n\n\n","category":"function"},{"location":"api/NQCModels/FrictionProviders/#NQCModels.FrictionModels.friction-Tuple{NQCModels.FrictionModels.AdiabaticFrictionModel, Any}","page":"FrictionModels","title":"NQCModels.FrictionModels.friction","text":"friction(model::Model, R)\n\nObtain the friction for the current position R.\n\nThis is an allocating version of friction!.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/FrictionProviders/","page":"FrictionModels","title":"FrictionModels","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCModels/frictionmodels/","page":"FrictionProviders.jl","title":"FrictionProviders.jl","text":"@info \"Expanding src/api/NQCModels/FrictionProviders.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCModels/frictionmodels/#FrictionProviders.jl","page":"FrictionProviders.jl","title":"FrictionProviders.jl","text":"","category":"section"},{"location":"api/NQCModels/frictionmodels/","page":"FrictionProviders.jl","title":"FrictionProviders.jl","text":"This package provides MLIP interfaces for the prediction of electronic friction tensors for molecular systems. ","category":"page"},{"location":"api/NQCModels/frictionmodels/","page":"FrictionProviders.jl","title":"FrictionProviders.jl","text":"Modules=[FrictionProviders]","category":"page"},{"location":"api/NQCModels/frictionmodels/#FrictionProviders.ACEdsODF-Tuple{Any, Any, Any}","page":"FrictionProviders.jl","title":"FrictionProviders.ACEdsODF","text":"ACEdsODF(model, gamma, atoms_julip; friction_unit=u\"ps^-1\")\n\nACEfriction.jl tensorial electronic friction provider. \n\nArguments\n\nmodel\n\nThis is the ACEfriction.FrictionModel used to predict the friction tensor. \n\ngamma\n\nThe function used to evaluate the friction tensor from the model using the ACEfriction model and JuLIP Atoms as an input. \n\nSet this to ACEfriction.Gamma unless you need a custom function to postprocess your friction tensor before it is used in dynamics. \n\natoms_julip\n\nA copy of the structure which the friction tensor will be predicted from as JuLIP.Atoms.  This should contain the same atoms and positions, in the same order as your Dynamics Simulation if you are using the model for dynamics. If you are using isotopes, their atomic masses need to be correctly set within this structure to receive the correct friction. \n\nfriction_unit\n\nThe unit in which the ACEfriction model predicts the friction tensor. By default, this is a relaxation rate tensor in inverse ps. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/frictionmodels/#FrictionProviders.AceLDFA-Tuple{Any}","page":"FrictionProviders.jl","title":"FrictionProviders.AceLDFA","text":"AceLDFA(friction_IP; density_unit=u\"Å^-3\")\n\nACE.jl electron density friction provider. \n\n# Arguments\n\n## friction_IP\nThis is the JuLIP potential created from the fitted ACE model, which is used to predict the electron density as a function of atomic positions. \n    \n## density_unit\n\nThe unit in which the ACE model predicts the electron density. By default, this is in Å^-3 and should be converted to atomic units of Bohr^-3.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/frictionmodels/#FrictionProviders.LDFAFriction-Tuple{Any, Any}","page":"FrictionProviders.jl","title":"FrictionProviders.LDFAFriction","text":"LDFAFriction(density, atoms; friction_atoms=collect(Int, range(atoms)))\n\nFrictionProvider for the Local Density Friction Approximation. \n\n# Arguments\n\n## density\nThis should be an interface to the prediction of the electronic density as a function of atomic positions. \nIt should support a `density` method. \n\n## atoms\n`NQCBase.Atoms` for the structure in question. This determines the correct fitting curve between Wigner-Seitz radii and electronic friction as shown in Gerrits2020. \nUsually, this is the same `Atoms` object as you use in your dynamics simulation. \n\n## friction_atoms\n\nThe atom indices which electronic friction should be applied to.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/frictionmodels/#FrictionProviders.friction_matrix_indices-Tuple{Any, Any}","page":"FrictionProviders.jl","title":"FrictionProviders.friction_matrix_indices","text":"friction_matrix_indices(model, indices)\n\nReturns the indices of the friction matrix corresponding to the given Atom indices.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/frictionmodels/#FrictionProviders.get_friction_matrix-Tuple{ACEdsODF, AbstractMatrix, AbstractVector, Float64}","page":"FrictionProviders.jl","title":"FrictionProviders.get_friction_matrix","text":"get_friction_matrix(model::ACEdsODF, R::AbstractMatrix, friction_atoms::AbstractVector, cutoff::Float64)\n\ngetfrictionmatrix uses an ACEdsODF model to predict the friction matrix for friction_atoms and return it for just those atoms. \n\nThis behaviour is different to NQCModels.friction!, which returns friction for the whole system, not just friction_atoms. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/frictionmodels/#FrictionProviders.get_friction_matrix-Tuple{LDFAFriction, AbstractMatrix}","page":"FrictionProviders.jl","title":"FrictionProviders.get_friction_matrix","text":"get_friction_matrix(model::LDFAFriction, R::AbstractMatrix)\n\ngetfrictionmatrix uses the specified density model to predict the friction matrix for friction_atoms and return it for just those atoms.  Units of friction are mass-weighted, and the atomic unit of friction is: [Eh / ħ / me] Convert common friction units such as ps^-1 or meV ps Å^-2 using UnitfulAtomic.austrip. \n\nThis behaviour is different to NQCModels.friction!, which returns friction for the whole system, not just friction_atoms. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/frictionmodels/","page":"FrictionProviders.jl","title":"FrictionProviders.jl","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCDynamics/calculators/","page":"Calculators","title":"Calculators","text":"@info \"Expanding src/api/NQCDynamics/calculators.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCDynamics/calculators/#Calculators","page":"Calculators","title":"Calculators","text":"","category":"section"},{"location":"api/NQCDynamics/calculators/","page":"Calculators","title":"Calculators","text":"Modules=[NQCDynamics.Calculators]","category":"page"},{"location":"api/NQCDynamics/calculators/#NQCDynamics.Calculators","page":"Calculators","title":"NQCDynamics.Calculators","text":"Calculators\n\nThis module exists to bridge the gap between the Models and the Dynamics.\n\nHere, we provide functions and types for evaluating and storing quantities obtained from the Models. In addition any further manipulation of those quantities, such as computing eigenvalues, is included here.\n\nThis module is largely needed to facilitate integration of both ring polymer and classical dynamics to allow using the same models and functions for both. Specific ring polymer types are provided that have the extra fields and methods needed to evaluate the quantities for each bead. \n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/calculators/#NQCDynamics.Calculators.quantities","page":"Calculators","title":"NQCDynamics.Calculators.quantities","text":"Each of the quantities specified here has functions: get_quantity(calculator, r) evaluate_quantity!(calculator, r)!\n\nThe user should access only the former. This will ensure quantities are correctly evaluated and cached accordingly.\n\nThe latter is called by the former and is where the details required to calculate the quantity are found.\n\n\n\n\n\n","category":"constant"},{"location":"api/NQCDynamics/calculators/#NQCDynamics.Calculators.AbstractCalculator","page":"Calculators","title":"NQCDynamics.Calculators.AbstractCalculator","text":"AbstractCalculator{M<:Model}\n\nTop-level type for all calculators.\n\nEach concrete calculator contains the Model and the fields to store the quantities obtained from the model.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/calculators/#NQCDynamics.Calculators.evaluate_nonadiabatic_coupling-Tuple{StaticArraysCore.SMatrix, StaticArraysCore.SVector}","page":"Calculators","title":"NQCDynamics.Calculators.evaluate_nonadiabatic_coupling","text":"References\n\nHammesSchifferTullyJChemPhys10146571994 Eq. (32)\nSubotnikBellonziAnnuRevPhyschem673872016, section 2.3\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/calculators/#NQCDynamics.Calculators.update_electronics!-Tuple{NQCDynamics.Calculators.AbstractDiabaticCalculator, AbstractArray}","page":"Calculators","title":"NQCDynamics.Calculators.update_electronics!","text":"Evaluates all electronic properties for the current position r.\n\nProperties evaluated:\n\nDiabatic potential\nDiabatic derivative\nEigenvalues and eigenvectors\nAdiabatic derivative\nNonadiabatic coupling\n\nThis should no longer be used, instead access the quantities directly with get_quantity(calc, r).\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/calculators/","page":"Calculators","title":"Calculators","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCDynamics/dynamicsmethods/","page":"DynamicsMethods","title":"DynamicsMethods","text":"@info \"Expanding src/api/NQCDynamics/dynamicsmethods.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCDynamics/dynamicsmethods/#DynamicsMethods","page":"DynamicsMethods","title":"DynamicsMethods","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsmethods/","page":"DynamicsMethods","title":"DynamicsMethods","text":"Modules=[NQCDynamics.DynamicsMethods]","category":"page"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods","text":"This module contains functions and types necessary for performing nonadiabatic molecular dynamics.\n\nDynamics is performed using DifferentialEquations.jl. As such, this module is centered around the implementation of the functions necessary to integrate the dynamics.\n\nFor deterministic Hamiltonian methods, the central function is DynamicsMethods.motion!, which is the inplace form of the function to be integrated by DifferentialEquations.jl.\n\nFurther, methods that have discontinuities, such as surface hopping, use the callback interface provided by DifferentialEquations.jl.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.Method","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.Method","text":"Each type of dynamics subtypes Method which is passed to the AbstractSimulation as a parameter to determine the type of dynamics desired.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.DynamicsVariables-Tuple{NQCDynamics.AbstractSimulation, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.DynamicsVariables","text":"DynamicsVariables(::AbstractSimulation, args...)\n\nFor each dynamics method this function is implemented to provide the variables for the dynamics in the appropriate format.\n\nBy default, DynamicsVariables is set up for the classical case and takes sim, v, r as arguments and returns a ComponentVector(v=v, r=r) which is used as a container for the velocities and positions during classical dynamics.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.create_problem-Tuple{Any, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.create_problem","text":"Provides the DEProblem for each type of simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.get_callbacks-Tuple{NQCDynamics.AbstractSimulation}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.get_callbacks","text":"Select the default callbacks for this simulation type.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.motion!","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.motion!","text":"motion!(du, u, sim, t)\n\nAs per DifferentialEquations.jl, this function is implemented for each method and defines the time derivatives of the DynamicalVariables.\n\nWe require that each implementation ensures du and u are subtypes of DynamicalVariables and sim subtypes AbstractSimulation.\n\n\n\n\n\n","category":"function"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.select_algorithm-Tuple{NQCDynamics.AbstractSimulation}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.select_algorithm","text":"Choose a default algorithm for solving the differential equation.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#ClassicalMethods","page":"DynamicsMethods","title":"ClassicalMethods","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsmethods/","page":"DynamicsMethods","title":"DynamicsMethods","text":"Modules=[NQCDynamics.DynamicsMethods.ClassicalMethods]","category":"page"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.ClassicalMethods.Classical","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.ClassicalMethods.Classical","text":"Classical <: DynamicsMethods.Method\n\nType for performing classical molecular dynamics.\n\nsim = Simulation{Classical}(Atoms(:H), Harmonic())\n\n# output\n\nSimulation{Classical}:\n  Atoms{Float64}([:H], [1], [1837.4715941070515])\n  Harmonic{Float64, Float64, Float64}\n  m: Float64 1.0\n  ω: Float64 1.0\n  r₀: Float64 0.0\n  dofs: Int64 1\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.ClassicalMethods.Langevin","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.ClassicalMethods.Langevin","text":"Type for performing Langevin molecular dynamics.\n\nusing Unitful\nsim = Simulation{Langevin}(Atoms(:H), Free(); γ=2.5, temperature=100u\"K\")\n\n# output\n\nSimulation{Langevin{Float64}}:\n  Atoms{Float64}([:H], [1], [1837.4715941070515])\n  Free(1)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.ClassicalMethods.MDEF","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.ClassicalMethods.MDEF","text":"dr = v dt\ndv = -Delta UM dt - Gamma v dt + sigma sqrt2Gamma dW\n\nGamma is the friction tensor with units of inverse time. For thermal dynamics we set sigma = sqrtkT  M, where T is the electronic temperature.\n\nThis is integrated using the BAOAB algorithm where the friction \"O\" step is performed in the tensor's eigenbasis. See src/dynamics/mdef_baoab.jl for details.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.ClassicalMethods.ThermalLangevin","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.ClassicalMethods.ThermalLangevin","text":"Type for performing Langevin ring polymer molecular dynamics.\n\nCurrently there are separate types for classical and ring polymer versions of Langevin dynamics but they should be combined. The reason they are not at the moment is that they use different integration algorithms and require slightly different fields.\n\nusing Unitful\nRingPolymerSimulation{ThermalLangevin}(Atoms(:H), Free(), 10; γ=0.1, temperature=25u\"K\")\n\n# output\n\nRingPolymerSimulation{ThermalLangevin{Float64}}:\n \n  Atoms{Float64}([:H], [1], [1837.4715941070515])\n \n  Free(1)\n  with 10 beads.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!-Tuple{Any, Any, Any, NQCDynamics.AbstractSimulation, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!","text":"f1 in DifferentialEquations.jl docs.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.ClassicalMethods.friction!-Tuple{Any, Any, NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.ClassicalMethods.AbstractMDEF}, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.ClassicalMethods.friction!","text":"friction!(g, r, sim, t)\n\nEvaluates friction tensor\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#MappingVariableMethods","page":"DynamicsMethods","title":"MappingVariableMethods","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsmethods/","page":"DynamicsMethods","title":"DynamicsMethods","text":"Modules=[NQCDynamics.DynamicsMethods.MappingVariableMethods]","category":"page"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.MappingVariableMethods.NRPMD","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.MappingVariableMethods.NRPMD","text":"NRPMD{T} <: DynamicsMethods.Method\n\nNonadiabatic ring polymer molecular dynamics Uses Meyer-Miller-Stock-Thoss mapping variables for electronic degrees of freedom and ring polymer formalism for nuclear degrees of freedom.\n\nRingPolymerSimulation{NRPMD}(Atoms(:H), DoubleWell(), 10)\n\n# output\n\nRingPolymerSimulation{NRPMD{Float64}}:\n \n  Atoms{Float64}([:H], [1], [1837.4715941070515])\n \n  DoubleWell{Int64, Int64, Int64, Int64}\n  mass: Int64 1\n  ω: Int64 1\n  γ: Int64 1\n  Δ: Int64 1\n \n  with 10 beads.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.MappingVariableMethods.eCMM","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.MappingVariableMethods.eCMM","text":"eCMM{T} <: DynamicsMethods.Method\n\nReferences\n\n[26]\n[27]\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#SurfaceHoppingMethods","page":"DynamicsMethods","title":"SurfaceHoppingMethods","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsmethods/","page":"DynamicsMethods","title":"DynamicsMethods","text":"Modules=[NQCDynamics.DynamicsMethods.SurfaceHoppingMethods]","category":"page"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods","text":"SurfaceHoppingMethods\n\nImplementation for surface hopping methods.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AdiabaticIESH","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AdiabaticIESH","text":"IESH{T} <: SurfaceHopping\n\nIndependent electron surface hopping.\n\nReferences\n\nShenvi, Roy, Tully, J. Chem. Phys. 130, 174107 (2009)\nRoy, Shenvi, Tully, J. Chem. Phys. 130, 174716 (2009)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.BCME","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.BCME","text":"BCME{T} <: ClassicalMasterEquation\n\nExtension to CME that incorporates broadening in the potential energy surfaces.\n\nNote that we do not rescale the velocity as this is not mentioned only in the 2016 paper, not any of the later ones, so I presume they later decided not to do it and instead keep it the same as the original CME.\n\nDou, Subotnik, J. Chem. Phys. 144, 024116 (2016)\nDou, Subotnik, J. Phys. Chem. A, 24, 757-771 (2020)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.CME","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.CME","text":"CME{T} <: ClassicalMasterEquation\n\nSimple surface hopping method for Newns-Anderson (Anderson-Holstein) models.\n\nDou, Nitzan, Subotnik, J. Chem. Phys. 142, 084110 (2015)\nDou, Subotnik, J. Phys. Chem. A, 24, 757-771 (2020)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.DecoherenceCorrectionEDC","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.DecoherenceCorrectionEDC","text":"DecoherenceCorrectionEDC{T}\n\nEnergy decoherence correction of Granucci and Persico in J. Chem. Phys. 126, 134114 (2007).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.FSSH","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.FSSH","text":"FSSH{T} <: SurfaceHopping\n\nType for fewest-switches surface hopping\n\nSimulation{FSSH}(Atoms(:H), Free())\n\n# output\n\nSimulation{FSSH{Float64}}:\n  Atoms{Float64}([:H], [1], [1837.4715941070515])\n  Free(1)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping","text":"Abstract type for all surface hopping methods.\n\nSurface hopping methods follow the structure set out in this file. The nuclear and electronic variables are propagated by the motion! function. The surface hopping procedure is handled by the HoppingCallback which uses the functions check_hop! and execute_hop! as its condition and affect!.\n\nTo add a new surface hopping scheme, you must create a new struct and define methods for evaluate_hopping_probability!, select_new_state, and rescale_velocity!.\n\nSee fssh.jl for an example implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.apply_decoherence_correction!-Union{Tuple{T}, Tuple{AbstractVector, NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.DecoherenceCorrectionEDC, Integer, T, AbstractVector, T}} where T","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.apply_decoherence_correction!","text":"Eq. 17 in J. Chem. Phys. 126, 134114 (2007)\n\nModify the wavefunction coefficients in ψ after a successful surface hop.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_Akj-Tuple{NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AbstractIESH}, AbstractMatrix, AbstractMatrix, Number, Vector}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_Akj","text":"Equation 17 in Shenvi, Roy, Tully 2009. Uses equations 19 and 20.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_a-Tuple{NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, AbstractMatrix}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_a","text":"calculate_a(sim::AbstractSimulation{<:SurfaceHopping}, coupling::AbstractMatrix)\n\nEquation 40 from [28].\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_b-Tuple{AbstractMatrix, AbstractMatrix}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_b","text":"calculate_b(coupling::AbstractMatrix, velocity::AbstractMatrix)\n\nEquation 41 from [28].\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.compute_overlap!-Tuple{NQCDynamics.AbstractSimulation{<:AdiabaticIESH}, Matrix, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.compute_overlap!","text":"Equation 20 in Shenvi, Roy, Tully 2009.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_broadening-NTuple{5, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_broadening","text":"evaluate_broadening(h, μ, β, Γ)\n\nEvaluate the convolution of the Fermi function with a Lorentzian.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{NQCDynamics.AbstractSimulation{<:FSSH}, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!","text":"evaluate_hopping_probability!(sim::Simulation{<:FSSH}, u, dt)\n\nEvaluates the probability of hopping from the current state to all other states\n\nImplementation\n\nσ is Hermitan so the choice σ[m,s] or σ[s,m] is irrelevant; we take the real part.\n'd' is skew-symmetric so here the indices are important.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AbstractIESH}, Any, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!","text":"Hopping probability according to equation 21 in Shenvi, Roy, Tully 2009.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!","text":"This function should set the field sim.method.hopping_probability.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.extract_nonadiabatic_coupling-Tuple{Any, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.extract_nonadiabatic_coupling","text":"extract_nonadiabatic_coupling(coupling, new_state, old_state)\n\nExtract the nonadiabatic coupling vector between states new_state and old_state\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.frustrated_hop_invert_velocity!-Tuple{NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.frustrated_hop_invert_velocity!","text":"frustrated_hop_invert_velocity!(\n    sim::AbstractSimulation{<:SurfaceHopping}, velocity, d\n)\n\nMeasures the component of velocity along the nonadiabatic coupling vector and inverts that component.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.iesh_diabatic_population-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.iesh_diabatic_population","text":"Calculate the diabatic population in J. Chem. Theory Comput. 2022, 18, 4615−4626. Eqs. 12, 13 and 14 describe the steps to calculat it though the code is written to use matrix operations instead of summations to calculate the result.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.perform_rescaling!-Tuple{NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.perform_rescaling!","text":"perform_rescaling!(\n    sim::AbstractSimulation{<:SurfaceHopping}, velocity, velocity_rescale, d\n)\n\nEquation 33 from [28].\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!-Tuple{NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!","text":"rescale_velocity!(sim::AbstractSimulation{<:SurfaceHopping}, u)::Bool\n\nRescale the velocity in the direction of the nonadiabatic coupling.\n\nReferences\n\n[28]\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.select_new_state-Tuple{NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.select_new_state","text":"This function should return the desired state determined by the probability. Should return the original state if no hop is desired.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.unpack_states-Tuple{NQCDynamics.AbstractSimulation{<:FSSH}}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.unpack_states","text":"unpack_states(sim)\n\nGet the two states that we are hopping between.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsUtils.acceleration!-Tuple{Any, Any, Any, Simulation{<:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AbstractIESH}, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsUtils.acceleration!","text":"Set the acceleration due to the force from the currently occupied states. See Eq. 12 of Shenvi, Tully JCP 2009 paper.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsUtils.set_quantum_derivative!-Tuple{Any, Any, NQCDynamics.AbstractSimulation{<:AdiabaticIESH}}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsUtils.set_quantum_derivative!","text":"Propagation of electronic wave function happens according to Eq. (14)  in the Shenvi, Tully paper (JCP 2009)\n\nIn IESH each electron is independent so we can loop through electrons and set the derivative one at a time, in the standard way for FSSH.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#EhrenfestMethods","page":"DynamicsMethods","title":"EhrenfestMethods","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsmethods/","page":"DynamicsMethods","title":"DynamicsMethods","text":"Modules=[NQCDynamics.DynamicsMethods.EhrenfestMethods]","category":"page"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.EhrenfestMethods.AbstractEhrenfest","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.EhrenfestMethods.AbstractEhrenfest","text":"Abstract type for Ehrenfest method.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.EhrenfestMethods.Ehrenfest","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.EhrenfestMethods.Ehrenfest","text":"Ehrenfest{T} <: AbstractEhrenfest\n\nEhrenfest molecular dynamics. Classical molecular dynamics where the force is derived by averaging contributions from multiple electronic states.\n\nSimulation{Ehrenfest}(Atoms(:H), DoubleWell())\n\n# output\n\nSimulation{Ehrenfest{Float64}}:\n  Atoms{Float64}([:H], [1], [1837.4715941070515])\n  DoubleWell{Int64, Int64, Int64, Int64}\n  mass: Int64 1\n  ω: Int64 1\n  γ: Int64 1\n  Δ: Int64 1\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#IntegrationAlgorithms","page":"DynamicsMethods","title":"IntegrationAlgorithms","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsmethods/","page":"DynamicsMethods","title":"DynamicsMethods","text":"Modules=[NQCDynamics.DynamicsMethods.IntegrationAlgorithms]","category":"page"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.MInt","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.MInt","text":"MInt <: OrdinaryDiffEq.OrdinaryDiffEqAlgorithm\n\nSecond order symplectic momentum integral algorithm.\n\nReference\n\nJ. Chem. Phys. 148, 102326 (2018)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.RingPolymerMInt","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.RingPolymerMInt","text":"RingPolymerMInt <: OrdinaryDiffEq.OrdinaryDiffEqAlgorithm\n\nSecond order symplectic momentum integral algorithm applied to NRPMD.\n\nReference\n\nJ. Chem. Phys. 148, 102326 (2018)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_C_propagator-Tuple{AbstractVector, AbstractMatrix, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_C_propagator","text":"Get the C propagator for the mapping variables.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_D_propagator-Tuple{AbstractVector, AbstractMatrix, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_D_propagator","text":"Get the D propagator for the mapping variables.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_gamma-Tuple{AbstractMatrix, AbstractVector, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_gamma","text":"Get the Γ variable used to calculate the nuclear propagators.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force","text":"Get the force due to the mapping variables.\n\nEquivalent to this but doesn't allocate:      return 0.5 * (q'Eq + p'Ep) - q'Fp\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force","text":"Get the force due to the mapping variables.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_xi-Tuple{AbstractMatrix, AbstractVector, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_xi","text":"Get the Ξ variable used to calculate the nuclear propagators.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_C_propagator!-Tuple{Any, Any, LinearAlgebra.Eigen, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_C_propagator!","text":"Get the C propagator for the mapping variables.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_D_propagator!-Tuple{Any, Any, LinearAlgebra.Eigen, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_D_propagator!","text":"Get the D propagator for the mapping variables.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_gamma!-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_gamma!","text":"Get the Γ variable used to calculate the nuclear propagators.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_xi!-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_xi!","text":"Get the Ξ variable used to calculate the nuclear propagators.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#StochasticDiffEq.alg_cache-Tuple{NQCDynamics.DynamicsMethods.IntegrationAlgorithms.MDEF_BAOAB, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Type{Val{false}}}","page":"DynamicsMethods","title":"StochasticDiffEq.alg_cache","text":"Insecting the inputs into a Cache structure.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/","page":"DynamicsMethods","title":"DynamicsMethods","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"@info \"Expanding src/NQCModels/machinelearningmodels.md...\"\nstart_time = time()","category":"page"},{"location":"NQCModels/machinelearningmodels/#ml-pes-models","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"","category":"section"},{"location":"NQCModels/machinelearningmodels/#Loading-ML-models-with-ase-calculators","page":"Machine learning interatomic potentials","title":"Loading ML models with ase calculators","text":"","category":"section"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"Using the ASE interface within (NQCModels.jl)[https://github.com/NQCD/NQCModels.jl] we can directly use models trained e.g. using MACE.","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"To use a MACE model, please load any pre-trained model into a given path you can access.","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"First we load the model into an ase calculator and attach it to our diatomic hydrogen molecule.","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"using PythonCall\n\nase = pyimport(\"ase\")\nmace_calc = pyimport(\"mace.calculators\")\n\nh2 = ase.Atoms(\"H2\", [(0, 0, 0), (0, 0, 0.74)])\n\ncalculator = mace_calc.MACECalculator(model_path=\"../assets/mace/h2cu.model\", device=\"cpu\", default_dtype=\"float32\")\nh2.set_calculator(calculator)","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"We can obtain the energies and forces from ase directly in the usual way, converting them to atomic units using UnitfulAtomic.","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"using Unitful, UnitfulAtomic;\naustrip(h2.get_total_energy() * u\"eV\")\naustrip.(h2.get_forces() .* u\"eV/Å\")","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"warning: Warning\nNote that this is an arbitrary model not trained on H2, hence the calculation of the potential energy and forces most likely do not make sense.","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"Then, we can convert the ASE output into the format used in NQCModels, which makes it possible to use the MACE model e.g. for molecular dynamics calculations within NQCDynamics.jl:","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"using NQCModels;\nmodel = AdiabaticASEModel(h2);\n\nr = [0 0; 0 0; 0 ustrip(auconvert(0.74u\"Å\"))]\n\npotential(model, r)\nderivative(model, r)","category":"page"},{"location":"NQCModels/machinelearningmodels/#Example:-Loading-SchNet-(SchNetPack)-models-through-ase","page":"Machine learning interatomic potentials","title":"Example: Loading SchNet (SchNetPack) models through ase","text":"","category":"section"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"Using the ASE interface we can directly use models trained using SchNetPack.","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"warning: Warning\nThe examples on this page do not run during the documentation build due to schnetpack causing segfaults when installed in the build environment. The causes of this is not currently clear but we have temporarily disabled these examples in the build.However, the examples should still be correct and you are welcome to try them with your own schnetpack trained models.","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"To use a SchNet model, please load any pre-trained model into a given path you can access. Here, our SchNet model is named \"best_model\" as is common in SchNet and provide the relative path.","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"First we load the model into an ase calculator and attach it to our diatomic hydrogen molecule.","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"using PythonCall\n\nase = pyimport(\"ase\")\nspkutils = pyimport(\"schnetpack.utils\")\nspkinterfaces = pyimport(\"schnetpack.interfaces\")\n\nspk_model = spkutils.load_model(\"../assets/schnetpack/best_model\"; map_location=\"cpu\")\n\nh2 = ase.Atoms(\"H2\", [(0, 0, 0), (0, 0, 0.74)])\n\ncalc = spkinterfaces.SpkCalculator(spk_model, energy=\"energy\", forces=\"forces\")\nh2.set_calculator(calc)","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"We can obtain the energies and forces from ase directly in the usual way, converting them to atomic units using UnitfulAtomic.","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"using Unitful, UnitfulAtomic;\naustrip(pyconvert(Float64,h2.get_total_energy()) * u\"eV\")\naustrip.(pyconvert(Matrix{Float64}, h2.get_forces()) .* u\"eV/Å\")\naustrip(pyconvert(Float64,h2.get_total_energy()) * u\"eV\")\naustrip.(pyconvert(Matrix{Float64}, h2.get_forces()) .* u\"eV/Å\")","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"warning: Warning\nNote that this is an arbitrary model not trained on H2, hence the calculation of the potential energy and forces most likely do not make sense.","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"Then, we can convert the ASE output into the format used in NQCModels, which makes it possible to use the SchNet model e.g. for molecular dynamics calculations within NQCDynamics.jl:","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"using NQCModels;\nmodel = AdiabaticASEModel(h2);\n\nr = [0 0; 0 0; 0 ustrip(auconvert(0.74u\"Å\"))]\n\npotential(model, r)\nderivative(model, r)","category":"page"},{"location":"NQCModels/machinelearningmodels/","page":"Machine learning interatomic potentials","title":"Machine learning interatomic potentials","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"@info \"Expanding src/dynamicssimulations/dynamicsmethods/langevin.md...\"\nstart_time = time()","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/#langevin-dynamics","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Langevin dynamics can be used to sample the canonical ensemble for a classical system. Langevin dynamics are based on classical equations of motion that are modified by an additional drag force and a random force. The Langevin equation of motion can be written as","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"mathbfMddotmathbfR = - nabla_R V(mathbfR) + mathbfF(t) - gamma dotmathbfR","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"where mathbfM are the masses, ddotmathbfR the time-derivative of the positions,  i.e., the velocities, nabla_R V(mathbfR) the gradient of the potential and mathbfF(t) the random force that is related to the friction coefficient gamma by the second fluctuation-dissipation theorem.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Equally the above equation can be written in the form of Ito stochastic differential equations [7]","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"beginaligned\ndmathbfR = mathbfM^-1 mathbfP dt\ndmathbfP = -nabla V(mathbfR) - gamma mathbfP dt\n+ sigma mathbfM^12 dmathbfW\nendaligned","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"where sigma = sqrt2gammabeta and mathbfW is a vector of N independent Wiener processes. As usual, mathbfP is the vector of particle momenta and mathbfM their diagonal mass matrix.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"note: Stochastic differential equations\nThere are two mathematical frameworks for handling stochastic differential equations, developed by Ruslan Stratonovich and Kiyosi Ito. To learn about the difference between the two in a physical context refer to [8].","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"As a stochastic differential equation, these two can be integrated immediately using StochasticDiffEq provided by DifferentialEquations, which offers a variety of stochastic solvers. It is possible to exploit the dynamical structure of the differential equations by splitting the integration steps into parts that can be solved exactly. In this context,  it has been shown that the BAOAB method from [7] achieves good accuracy compared to other similar algorithms and this algorithm is used here as the default.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/#Example","page":"Classical Langevin dynamics","title":"Example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Using Langevin dynamics we can sample the canonical ensemble for a simple harmonic oscillator and investigate the energy expectation values.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Firstly we set up our system parameters. Here, we have two atoms in a harmonic potential at a temperature of 1e-3. We have arbitrarily chosen the dissipation constant gamma = 1, this can be tuned for optimal sampling in more complex systems. ","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"using NQCDynamics\nusing Unitful\n\natoms = Atoms([:H, :C])\ntemperature = 1e-3\nsim = Simulation{Langevin}(atoms, Harmonic(m=atoms.masses[1]); γ=1, temperature)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"note: Atomic units\nAs usual, all quantities are in atomic units by default.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Here we can generate a simple starting configuration with zeros for every degree of freedom.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"u = DynamicsVariables(sim, zeros(size(sim)), zeros(size(sim)))","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Running the dynamics proceeds by providing all the parameters along with any extra keywords. This time we have requested both the positions and velocities to be outputted and have selected a timestep dt. Since the default algorithm is a fixed timestep algorithm an error will be thrown if a timestep is not provided.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"traj = run_dynamics(sim, (0.0, 2000.0), u; output=(OutputPosition, OutputVelocity), dt=0.5)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Here, we plot the positions of our two atoms throughout the simulation.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"using Plots\nplot(traj, :OutputPosition, label=[\"Hydrogen\" \"Carbon\"], legend=true)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"We next plot the velocities. Notice how the carbon atom with its heavier mass has a smaller magnitude throughout.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"plot(traj, :OutputVelocity, label=[\"Hydrogen\" \"Carbon\"], legend=true)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Using the configurations from the Langevin simulation we can obtain expectation values along the trajectories. This can be done manually, but we provide the Estimators module to make this as simple as possible.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"!!! note Estimators","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"[Here](@ref `Estimators`) you can find the available quantities that [`Estimators`](@ref) provides.\nTo add new quantities, you must implement a new function inside `src/Estimators.jl`.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Let's find the expectation for the potential energy during our simulation. This is the potential energy of the final configuration in the simulation:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Estimators.potential_energy(sim, traj[:OutputPosition][end])","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"We could evaluate this for every configuration and average it manually. Fortunately however, we have the @estimate macro that will do this for us:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Estimators.@estimate potential_energy(sim, traj[:OutputPosition])","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"tip: Tip\nWe can verify this result by comparing to the equipartition theorem which states that each quadratic degree of freedom should contribute frac12kT to the total energy. As this is a harmonic system, this gives us the exact classical potential energy expectation as equal to the temperature, since we have two degrees of freedom and we are in atomic units.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Similarly, we can evaluate the kinetic energy expectation with:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Estimators.@estimate kinetic_energy(sim, traj[:OutputVelocity])","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Again, this takes a similar value since the total energy is evenly split between the kinetic and potential for a classical harmonic system.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"@info \"Expanding src/dynamicssimulations/dynamicsmethods/mdef.md...\"\nstart_time = time()","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/#mdef-dynamics","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/mdef/#Introduction","page":"Molecular dynamics with electronic friction (MDEF)","title":"Introduction","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"A set of fundamental and technologically relevant chemical processes (surface scattering, dissociative chemisorption, surface diffusion, recombinative desorption, etc.) are often catalyzed at the metal surface of several late transition metals (Au, Ag, Cu, Pt, Pd, Rh, etc). These metallic surfaces, unlike other surfaces, are characterized by a dense manifold of electronic states at the Fermi level, which produce continuous conduction and valence bands without a band gap. A theoretical description of the chemical processes at these metal surfaces is often challenging due to the Born-Oppenheimer (BO) approximation no longer being valid. With the breakdown of the Born-Oppenheimer approximation,  nonadiabatic effects have to be considered to describe, e.g., the energy exchange that can take place between adsorbate and substrate degrees of freedom (DOF).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"A fully quantum dynamical approach of this complex scenario is currently unfeasible and the gas-surface reaction dynamics are often described using quasi-classical methods where nuclear motion is described classically. Molecular dynamics with electronic friction (MDEF) is one of main methods used to deal with the nonadiabaticity in gas-surface chemical reactions. MDEF has been widely employed to decribe and simulate the nuclear dynamics in several molecular systems. It is a theoretical model based on a ground-state Langevin equation of motion which introduces nonadiabatic effects by using frictional and stochastic forces. This approach was originally introduced by Head-Gordon and Tully and the nonadiabatic effects can be included through different electronic friction models (see section below, LDFA and TDPT). The nuclear coordinates of the adsorbate atoms evolve as follows:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"mathbfMddotmathbfR = - nabla_R V(mathbfR) + mathbfF(t) - Gamma(mathbfR) dotmathbfR","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"The first term on the right hand side of the equation corresponds to a conservative force associated with the potential energy surface (PES) as in the adiabatic case. The third term is the friction force and it comes from multiplication between the electronic friction object (Gamma(mathbfR)) and the velocity. Finally, the second term is a temperature and friction-dependent stochastic force which ensures detailed balance.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"This figure shows an atom moving near a metal surface M_A. When the atom moves into the region of electron density rho_0^M_A it experiences the forces described above. (Image: ldfa motion)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/#Simple-example","page":"Molecular dynamics with electronic friction (MDEF)","title":"Simple example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"We can explore the MDEF concept first by introducing a model system with non-physical parameters. This will demonstrate the general format and expected results from an MDEF simulation which can explore further in later sections using realistic systems.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"Here, we model a single hydrogen atom in a harmonic potential, where the electronic temperature is 300 K. The CompositeFrictionModel allows us to combine any AdiabaticModel with an ElectronicFrictionProvider  that will add electronic friction to an otherwise adiabatic system. RandomFriction is used for demonstration purposes only and provides a matrix of random numbers to use in place of the friction.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"using NQCDynamics\nusing Unitful\n\natoms = Atoms([:H])\nmodel = CompositeFrictionModel(Harmonic(dofs=3), RandomFriction(3))\nsim = Simulation{MDEF}(atoms, model; temperature=300u\"K\")","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"For simplicity, we initialise the system with zero velocity and position for each degree of freedom:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"z = DynamicsVariables(sim, zeros(size(sim)), zeros(size(sim)))","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"With these parameters, we can run a single trajectory and visualise the total energy as a function of time.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"using Plots\n\nsolution = run_dynamics(sim, (0.0, 100u\"fs\"), z, dt=0.5u\"fs\", output=OutputTotalEnergy)\nplot(solution, :OutputTotalEnergy)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"note: Note\n:hamiltonian in the output tuple refers to the classical Hamiltonian that generates the classical equations of motion. Since we are performing MDEF we see that the total energy fluctuates.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"Now let's see what happens if we make the electronic temperature a function of time. For any simulation, temperature can be provided as a time-dependent function which allows variable temperature simulations. In the context of MDEF, this temperature can be used to represent the use of lasers to provide extra energy to the electrons in the metal.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"temperature_function(t) = exp(-(t - 50u\"fs\")^2 / 20u\"fs^2\") * 300u\"K\"\nnothing # hide","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"warning: Warning\nThe time argument enters this function as a Unitful.jl quantity, and it is important to make sure the unit of the return value is temperature.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"Now we can re-simulate, replacing the fixed temperature with the function we have defined.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"sim = Simulation{MDEF}(atoms, model; temperature=temperature_function)\nsolution = run_dynamics(sim, (0.0, 100u\"fs\"), z, dt=0.5u\"fs\",\n    output=OutputTotalEnergy)\nplot(solution, :OutputTotalEnergy)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"This time we see a peak in the energy in the middle of the simulation which coincides with the peak in temperature at 50 fs. Having viewed this simple example, we can now explore the different ways the friction coefficient can be obtained from ab initio simulations. ","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/#Local-density-friction-approximation-(LDFA)","page":"Molecular dynamics with electronic friction (MDEF)","title":"Local density friction approximation (LDFA)","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"Local density friction approximation (LDFA) is a theoretical model which describes the electronic friction Gamma(mathbfR) term in the above equation based on the local electron density of the metal substrate. This approximation assumes a scalar friction coefficient (Gamma(R_i)) for each adsorbate atom. The underlying assumption to this approximation is that any atom only sees an anisotropic (scalar) density that only depends on the local surroundings. In the LDFA theoretical framework the above equation of motion is used, except the friction matrix is diagonal, each element coming from the local density of each atom.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"In our current LDFA implementation, a set of pre-calculated electronic friction coefficients (eta_ei) computed at different Wigner-Seitz radius (r_s) are used to fit and get an analytical expression to connect any r_s values with an single electronic friction coefficient by means of    cubic Spline functions. The Wigner-Seitz radius is connected to the metal substrate electron density by the following equation, ","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"   r_s(rho) = (frac34pi rho (mathbfr_i))^13","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"In this way, the electron density associated with the current substrate atom position is used to compute the respective friction coefficient through fitting function for each point of the trajectory. Visit the FrictionProviders.jl to learn more about how this is evaluated.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/#Time-dependent-Perturbation-theory-(TDPT)","page":"Molecular dynamics with electronic friction (MDEF)","title":"Time-dependent Perturbation theory (TDPT)","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"A more general formulation of the electronic friction object was also developed under the umbrella of electronic friction tensor(EFT) or orbital-dependent electronic friction (ODF) approaches. Both formulations are essentially equivalent and they incorporate the isotropy nature of the electronic friction object by a multidimentional tensor (Lambda_ij) instead of a single coefficient as usually computed at LDFA level.  The electronic friction elements can be computed by first-principle calculations in the context of first-order time-dependent perturbation theory (TDPT) at the density functional theory (DFT) level. Each electronic friction tensor (EFT) elements corresponds to relaxation rate due to electron-nuclear coupling along the Cartesian coordinate i due to motion in the j direction. The electronic friction tensor elements can be computed by using the Fermi's golden rule. Lambda_ij is an object with (3Ntimes3N)-dimension where N is often the total number of adsorbate atoms considered explicitly on the study system. View the friction models page to learn about how this can be used.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"tip: TDPT friction and LDFA in action?\nIf you would like to see an example using both LDFA and TDPT during full dimensional dynamics, refer to the reactive scattering example.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/#Use-of-Composite-models-for-phonon-thermostatting","page":"Molecular dynamics with electronic friction (MDEF)","title":"Use of Composite models for phonon thermostatting","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"# PES applies to all atoms\npes_subsystem = Subsystem(pes_model)\n\n# Electronic friction applies to adsorbate atoms 55,56\nelectronic_friction = Subsystem(adsorbate_friction_model, indices=[55,56])\n\n# Combine models and generate Simulation\ncombined_model = CompositeModel(pes_subsystem, electronic_friction)\n\nsim_T_el_only = Simulation{MDEF}(\n   atoms, \n   combined_model; \n   temperature = T_el_function, \n   cell=cell\n)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"See the example page for a longer explanation on how to compose multiple models. ","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"@info \"Expanding src/dynamicssimulations/dynamicsmethods/ehrenfest.md...\"\nstart_time = time()","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/#ehrenfest-dynamics","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"The Ehrenfest method is a mixed quantum-classical dynamics method in which the total wavefunction is factorized into slow (nuclear) variables, which are treated classically, and fast ones (electrons) which remain quantum-mechanical. In the Ehrenfest method, nuclei move according to classical mechanics on a potential energy surface given by the expectation value of the electronic Hamiltonian. ","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"The time dependence of the electronic wavefunction is expanded into an adiabatic basis and follows the time-dependent Schr\\\"odinger equation.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"ihbar dotc_i(t) = V_i(mathbfR) c_i (t)\n- ihbar sum_j dotmathbfR cdot mathbfd_ij(mathbfR)c_j(t)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/#Example","page":"Ehrenfest molecular dynamics","title":"Example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"Below the example of the Ehrenfest implementation is presented, using model from [5].","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"At the start, we assign atoms and initialise the simulation using the mass and model from NQCModels.jl.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"using NQCDynamics\n\natoms = Atoms(1980)\nsim = Simulation{Ehrenfest}(atoms, AnanthModelOne())","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"Next, the initial distribution is created:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"using Distributions\ne = 0.03\nk = sqrt(e*2*atoms.masses[1])\nr = Normal(-5, 1/sqrt(0.25))\nv = k / atoms.masses[1]\ndistribution = DynamicalDistribution(v, r, size(sim))* PureState(1, Adiabatic())","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"To run an ensemble simulation we additionally choose number of trajectories n_traj and timespan tspan and we pass all the established settings to the run_dynamics function. In this example we output velocities by specifying output=OutputVelocity and store the final values in the final_velocities array. Following that, we calculate final momenta.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"n_traj = 10\ntspan = (0.0, 3000.0)\nsolution = run_dynamics(sim, tspan, distribution; \n    trajectories=n_traj, output=OutputVelocity, dt=1.0)\nfinal_velocities = [r[:OutputVelocity][end] for r in solution]\nmomenta = reduce(vcat, final_velocities*atoms.masses[1])","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"using Plots\nhistogram(momenta)\nxlims!(-20,20)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"@info \"Expanding src/ensemble_simulations.md...\"\nstart_time = time()","category":"page"},{"location":"ensemble_simulations/#ensembles","page":"Ensemble simulations","title":"Ensemble simulations","text":"","category":"section"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"Typically we'll be interested in computing observables based upon the statistics obtained from many trajectories. Technically it is possible to manually run many trajectories using the single trajectory procedure introduced in the Getting started section. However, by using the methods introduced on this page it is possible to run many trajectories at once, using parallelism and computing ensemble observables automatically.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"The key function for performing ensemble simulations is run_dynamics.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"run_dynamics","category":"page"},{"location":"ensemble_simulations/#NQCDynamics.Ensembles.run_dynamics","page":"Ensemble simulations","title":"NQCDynamics.Ensembles.run_dynamics","text":"run_dynamics(sim::AbstractSimulation, tspan, distribution;\n    output,\n    selection::Union{Nothing,AbstractVector}=nothing,\n    reduction=AppendReduction(),\n    ensemble_algorithm=SciMLBase.EnsembleSerial(),\n    algorithm=DynamicsMethods.select_algorithm(sim),\n    trajectories=1,\n    kwargs...\n    )\n\nRun trajectories for timespan tspan sampling from distribution.\n\nKeywords\n\noutput either a single function or a Tuple of functions with the signature f(sol, i) that takes the DifferentialEquations solution and returns the desired output quantity.\nselection should be an AbstractVector containing the indices to sample from the distribution. By default, nothing leads to random sampling.\nreduction defines how the data is reduced across trajectories. Options are AppendReduction(), MeanReduction(), SumReduction and FileReduction(filename).\nensemble_algorithm is the algorithm from DifferentialEquations which determines which form of parallelism is used.\nalgorithm is the algorithm used to integrate the equations of motion.\ntrajectories is the number of trajectories to perform.\nkwargs... any additional keywords are passed to DifferentialEquations solve`.\n\n\n\n\n\n","category":"function"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"This is the same function used to perform single trajectory simulations, but by replacing the single initial condition with a distribution and changing the number of trajectories it is possible to run an ensemble of trajectories. The distributions are defined such that they can be sampled to provide initial conditions for each trajectory. The Storing and sampling distributions page details the format the distributions must take.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"Internally, the DifferentialEquations.jl ensemble infrastructure is used to handle per trajectory parallelism. The ensemble_algorithm keyword takes one of the EnsembleAlgorithms. To use these, you must first add using DiffEqBase to your script.","category":"page"},{"location":"ensemble_simulations/#Example","page":"Ensemble simulations","title":"Example","text":"","category":"section"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"To demonstrate usage of run_dynamics, let's investigate different ways to calculate the time-dependent population with FSSH.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"First, we set up our system using one of Tully's simple models ([1]).","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"using NQCDynamics\n\natoms = Atoms(2000)\nmodel = TullyModelOne()\nsim = Simulation{FSSH}(atoms, model)\nnothing # hide","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"As mentioned above, before running the ensemble, we must prepare a distribution to generate initial conditions for each trajectory. This procedure is detailed in the Storing and sampling distributions section.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"using Distributions: Normal # Import the Normal distribution\n\nk = 10 # Initial momentum = 10\nv = k / atoms.masses[1] # Convert momentum to velocity\nr = Normal(-8) # Create Normal distribution centred at -8 for sampling initial position\nnuclear_distribution = DynamicalDistribution(v, r, (1,1)) # Combine position and velocity\nelectronic_distribution = PureState(2) # Create nonequilibrium electronic distribution\nproduct_distribution = nuclear_distribution * electronic_distribution\nnothing # hide","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"In this case, we have used a deterministic momentum of 10 a.u. and a gaussian position distribution with width 1 centered at -8 a.u.. The electronic variables will be sampled such that the initial population is confined to the second state by PureState(2).","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"The final step before running the dynamics is to decide how to output the results. The simplest option is to use the built-in tuple format familiar from run_dynamics.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"ensemble = run_dynamics(sim, (0.0, 3000.0), product_distribution;\n    trajectories=20, output=OutputDiabaticPopulation)\nnothing # hide","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"This is equivalent to performing single trajectories in a loop and manually re-sampling the initial conditions each time. However, here we have been able to do this more concisely, using internal mechanisms for sampling from the product_distribution.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"The output of this function is a vector containing the output from each trajectory. Each entry is equivalent to the output from a call to run_dynamics and  can be plotted by iterating through ensemble.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"using Plots\n\np = plot(legend=false)\nfor traj in ensemble\n    plot!(traj[:Time], [population[2] - population[1] for population in traj[:OutputDiabaticPopulation]])\nend\np","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"This plot shows the population difference between the two states for each trajectory. To approximate the exact quantum dynamics for this model, the average over all trajectories should be computed. Instead of manually averaging the result, we can use reduction=MeanReduction() or reduction=SumReduction() which will reduce the data accordingly before outputting the result:","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"ensemble = run_dynamics(sim, (0.0, 3000.0), product_distribution;\n    trajectories=20, output=OutputDiabaticPopulation, reduction=MeanReduction(), saveat=0.0:10.0:3000.0)\nplot(ensemble, :OutputDiabaticPopulation)","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"note: Note\nHere we have also specified the saveat keyword to ensure the output is saved at the same points for every trajectory, otherwise the averaging will not work. This is necessary because we are using an integrator with adaptive timestepping that will save at different points for each trajectory.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"This workflow can be applied for any of the quantities defined in the DynamicsOutputs submodule. If we want a more complex output, such as a scattering probability or a time-correlation function, we can provide a function to the output argument as described in the DifferentialEquations.jl documentation. The advantage of this approach is that memory can be saved by reducing the data as the trajectories accumulate, it also allows greater flexibility when modifying the output.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"Inside the Ensembles submodule we define a few premade functions of this sort, but here we can demonstrate how to reformulate the previous simulation using the alternative format.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"function output_function(sol, i)\n    output = zeros(2,div(3000, 50) + 1)\n    for (i,u) in enumerate(sol.u)\n        output[:,i] .= Estimators.diabatic_population(sim, u)\n    end\n    return output\nend\n\nensemble = run_dynamics(sim, (0.0, 3000.0), product_distribution;\n    trajectories=20, output=output_function, reduction=MeanReduction(), saveat=50.0)","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"This function provides us the same output as above, but this gives us the flexibility to calculate any observable we want.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"Throughout the documentation, ensemble simulations like this one are used to demonstrate many of the dynamics methods. Now that you have understood the contents of this page, all of the ensemble simulations will appear familiar.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCDynamics/timecorrelationfunctions/","page":"TimeCorrelationFunctions","title":"TimeCorrelationFunctions","text":"@info \"Expanding src/api/NQCDynamics/timecorrelationfunctions.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCDynamics/timecorrelationfunctions/#TimeCorrelationFunctions","page":"TimeCorrelationFunctions","title":"TimeCorrelationFunctions","text":"","category":"section"},{"location":"api/NQCDynamics/timecorrelationfunctions/","page":"TimeCorrelationFunctions","title":"TimeCorrelationFunctions","text":"Modules=[NQCDynamics.TimeCorrelationFunctions]","category":"page"},{"location":"api/NQCDynamics/timecorrelationfunctions/#NQCDynamics.TimeCorrelationFunctions","page":"TimeCorrelationFunctions","title":"NQCDynamics.TimeCorrelationFunctions","text":"TimeCorrelationFunctions\n\nThis module defines extra types that can be used as Ensemble outputs when computing time-correlation functions. It hopes to provide a minimal interface that reduces code repetition when implementing different correlation functions.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/timecorrelationfunctions/#NQCDynamics.TimeCorrelationFunctions.PopulationCorrelationFunction","page":"TimeCorrelationFunctions","title":"NQCDynamics.TimeCorrelationFunctions.PopulationCorrelationFunction","text":"PopulationCorrelationFunction{T,S<:AbstractSimulation} <: TimeCorrelationFunction\n\nOutput type for computing the population correlation function. The statetype determines the population type (diabatic or adiabatic). sim must also be provided to access the parameters to compute the population.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/timecorrelationfunctions/#NQCDynamics.TimeCorrelationFunctions.TimeCorrelationFunction","page":"TimeCorrelationFunctions","title":"NQCDynamics.TimeCorrelationFunctions.TimeCorrelationFunction","text":"TimeCorrelationFunction\n\nAbstract type for defining time correlation functions\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/timecorrelationfunctions/","page":"TimeCorrelationFunctions","title":"TimeCorrelationFunctions","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"@info \"Expanding src/saving_loading.md...\"\nstart_time = time()","category":"page"},{"location":"saving_loading/#saving-and-loading","page":"Saving and loading","title":"Saving and loading","text":"","category":"section"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"If you would like to split your workflow into multiple scripts (e.g. separately generating initial conditions and running dynamics) it is necessary to be able to store intermediate data in files.","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"When this data is atomic configurations or trajectories, it can be useful to use standard file formats such as those mentioned in the Atoms section previously. However, often it is more convenient to directly save and load Julia objects between sessions. For this purpose, we recommend using FileIO.jl with JLD2.jl.","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"note: Note\nJLD2 can be used independently of FileIO. However, FileIO provides a unified interface for many file types and allows you to save data to lots of formats with consistent syntax.","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"As a simple example, suppose that we want the same system parameters across multiple scripts:","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"using NQCDynamics\n\natoms = Atoms([:H, :H, :C, :C])\ncell = PeriodicCell([10.0 0 0; 0 10.0 0; 0 0 10.0])\nmodel = Harmonic()\nnothing # hide","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"Instead of redefining these in every script, we can save them to a file, then load them back in whenever we need them using FileIO.","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"This creates a file \"parameters.jld2\" containing all of our system parameters:","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"using FileIO\nsave(\"parameters.jld2\", Dict(\"atoms\"=>atoms, \"cell\"=>cell, \"model\"=>model))","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"In a separate Julia session we can re-load these parameters. As detailed in the JLD2 documentation we can select the data to load by specifying extra arguments to load.","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"using NQCDynamics, FileIO\n\nparameters = load(\"parameters.jld2\")\natoms = load(\"parameters.jld2\", \"atoms\")\ncell = load(\"parameters.jld2\", \"cell\")\nmodel = load(\"parameters.jld2\", \"model\")","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"JLD2 is compatible with any Julia type so it widely usable for most of the types you encounter is NQCDynamics.jl and across all Julia packages.","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCModels/adiabaticmodels/","page":"AdiabaticModels","title":"AdiabaticModels","text":"@info \"Expanding src/api/NQCModels/adiabaticmodels.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCModels/adiabaticmodels/#AdiabaticModels","page":"AdiabaticModels","title":"AdiabaticModels","text":"","category":"section"},{"location":"api/NQCModels/adiabaticmodels/","page":"AdiabaticModels","title":"AdiabaticModels","text":"Modules=[NQCModels.AdiabaticModels]","category":"page"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels","text":"AdiabaticModels\n\nAll models defined within this module have only a single electronic state and return potentials as scalars and derivatives as simple arrays.\n\nThe central abstract type is the AdiabaticModel, which all models should subtype.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.AdiabaticASEModel","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.AdiabaticASEModel","text":"AdiabaticASEModel{A} <: AdiabaticModel\n\nWrapper for an ase.Atoms object that has a calculator attached. This Model will synchronise the positions with the ase object and handle the unit conversions.\n\nImplements both potential and derivative!.\n\nNotes on calling Python from Julia\n\nBoth PyCall.jl and PythonCall.jl can be used to create the ase.Atoms object, but PythonCall.jl is preferred.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.AdiabaticModel","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.AdiabaticModel","text":"AdiabaticModel <: Model\n\nAdiabaticModels represent the potentials from classical molecular dynamics where the potential is a function of the position.\n\nImplementation\n\nAdiabaticModels should implement:\n\npotential(model, R)\nderivative!(model, D, R) (this is the derivative of the potential energy with respect to the positions)\nndofs(model) (these are the degrees of freedom)\n\nExample\n\nThis example creates a 2 dimensional adiabatic model MyModel. We implement the 3 compulsory functions then evaluate the potential. Here, the argument R is an AbstractMatrix since this is a 2D model that can accept multiple atoms.\n\nstruct MyModel{P} <: NQCModels.AdiabaticModels.AdiabaticModel\n    param::P\nend\n\nNQCModels.ndofs(::MyModel) = 2\n\nNQCModels.potential(model::MyModel, R::AbstractMatrix) = model.param*sum(R.^2)\nNQCModels.derivative!(model::MyModel, D, R::AbstractMatrix) = D .= model.param*2R\n\nmodel = MyModel(10)\n\nNQCModels.potential(model, [1 2; 3 4])\n\n# output\n\n300\n\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.DarlingHollowayElbow","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.DarlingHollowayElbow","text":"DarlingHollowayElbow()\n\nAdiabatic elbow potential from Darling and Holloway: Faraday Discuss., 1993, 96, 43-54\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.DiatomicHarmonic","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.DiatomicHarmonic","text":"DiatomicHarmonic(r₀=1.0)\n\nHarmonic interaction between two particles.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.Free","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.Free","text":"Free()\n\nZero external potential everywhere. Useful for modelling free particles.\n\njulia> model, R = Free(3), rand(3, 10);\n\njulia> potential(model, R)\n0.0\n\njulia> derivative(model, R)\n3×10 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.Harmonic","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.Harmonic","text":"Harmonic(m=1.0, ω=1.0, r₀=0.0)\n\nAdiabatic harmonic potential. V(x) = mω^2(x-r₀)^2  2\n\nm, ω, r₀ are the mass, frequency, and equilibrium position respectively and can be supplied as  numbers or Matrices to create a compound model for multiple particles. \n\njulia> using Symbolics;\n\njulia> @variables x, m, ω, r₀;\n\njulia> model = Harmonic(m=m, ω=ω, r₀=r₀);\n\njulia> potential(model, hcat(x))\n0.5m*(ω^2)*((x - r₀)^2)\n\njulia> derivative(model, hcat(x))\n1×1 Matrix{Num}:\n m*(x - r₀)*(ω^2)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.JuLIPModel","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.JuLIPModel","text":"struct JuLIPModel{T} <: AdiabaticModel\n\nModel for interfacing with JuLIP potentials.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.Morse","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.Morse","text":"Parameters.@with_kw struct Morse{T} <: AdiabaticModel\n\nReferences\n\nJ. Chem. Phys. 88, 4535 (1988)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.eigenenergy-Tuple{Morse, Any}","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.eigenenergy","text":"Eq. 43\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.getλ-Tuple{Morse}","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.getλ","text":"Eq. 36\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.getω₀-Tuple{Morse}","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.getω₀","text":"Eq. 44\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/adiabaticmodels/","page":"AdiabaticModels","title":"AdiabaticModels","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"@info \"Expanding src/atoms.md...\"\nstart_time = time()","category":"page"},{"location":"atoms/#atoms","page":"Atoms","title":"Handling Atoms","text":"","category":"section"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"tip: Tip: NQCDynamics.jl handles atoms differently to `ase`\nThis package makes the choice to separate the atomic parameters from their positions and velocities for ease of use with the differential equations solvers. This contrasts somewhat with most other software packages where these would be usually be joined together into a single object.","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"The atomic parameters here are contained within the Atoms type introduced earlier in the Getting started section. As mentioned previously, there exist some basic constructors which use either elemental symbols or numbers to initialise the parameters:","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"using NQCDynamics\nAtoms([:H, :H, :H])\nAtoms([1, 2, 3])","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"If there are many atoms, you can use Julia's array manipulation utilities to create large vectors with many atoms types. For example, if adding an adsorbate to a metal surface, it could be initialised as:","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"au = fill(:Au, 40)\nno = [:N, :O]\nauno = [au; no]\nAtoms(auno)","category":"page"},{"location":"atoms/#atoms-base","page":"Atoms","title":"Manipulating atomic structures with AtomsBase.jl","text":"","category":"section"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"AtomsBase provides a convenient format for representing atomic geometries, facilitating interoperability between a collection of different packages.","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"When working with NQCDynamics, the most useful packages are AtomsIO for reading and writing structures and trajectories, and ASEconvert for working with ASE from within Julia.","category":"page"},{"location":"atoms/#Using-Python's-ase-package-from-Julia","page":"Atoms","title":"Using Python's ase package from Julia","text":"","category":"section"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"Julia provides multiple options to run Python-based code from Julia scripts. The NQCD packages provide compatibility with PythonCall.jl, and some deprecated interfaces for PyCall.jl exist as well.  While both of these packages function similarly, PythonCall forces you as a user to think more about when data is copied in memory between Python and Julia, enabling more efficient code. ","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"This example shows how ase.build can be used to build a structure from within Julia, then convert from the ASE format into the required objects for atoms, positions and unit cell for an NQCD simulation:","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"using PythonCall\nusing NQCBase\n\nase_build = pyimport(\"ase.build\")\n\n# Make a silicon supercell using ASE\natoms_ase = ase_build.bulk(\"Si\") * pytuple((4, 1, 1))","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"It is currently not possible to use an AtomsBase system directly with NQCDynamics, but can be quickly converted to the correct format:","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"using NQCDynamics\n\natoms_nqcd, positions_nqcd, cell_nqcd = convert_from_ase_atoms(atoms_ase)\n\nprintln(atoms_nqcd)\nprintln(positions_nqcd)\nprintln(cell_nqcd)","category":"page"},{"location":"atoms/#Saving-and-loading-with-AtomsIO.jl","page":"Atoms","title":"Saving and loading with AtomsIO.jl","text":"","category":"section"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"After running a simulation it often desirable to save the trajectory in a standard format for visualization. For this, convert the NQCDynamics output into the AtomsBase format, then use AtomsIO to write the file in your chosen format.","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"using AtomsIO\n\nsystem = System(atoms_nqcd, r, v, c)\n\nAtomsIO.save_system(\"Si.xyz\", system) # Save a single image\n\ntrajectory = Trajectory(atoms_nqcd, [r, r, r, r], [v, v, v, v], c)\nAtomsIO.save_trajectory(\"Si.xyz\", trajectory) # Save a trajectory","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"AtomsIO also provides load_system and load_trajectory which can be converted to the NQCDynamics format as above to initialise simulations. Refer to AtomsIO for more information.","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCBase/nqcbase/","page":"NQCBase","title":"NQCBase","text":"@info \"Expanding src/api/NQCBase/nqcbase.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCBase/nqcbase/#NQCBase","page":"NQCBase","title":"NQCBase","text":"","category":"section"},{"location":"api/NQCBase/nqcbase/","page":"NQCBase","title":"NQCBase","text":"Modules=[NQCBase]","category":"page"},{"location":"api/NQCBase/nqcbase/#NQCBase.Atoms","page":"NQCBase","title":"NQCBase.Atoms","text":"Atoms{T<:AbstractFloat}\n\nBasic atomic parameters: element symbols, numbers and masses\n\nMasses are converted to atomic units. Constructed using either element symbols or masses.\n\njulia> Atoms(:H)\nAtoms{Float64}([:H], [1], [1837.4715941070515])\n\njulia> Atoms([:H, :H, :H, :C])\nAtoms{Float64}([:H, :H, :H, :C], [1, 1, 1, 6], [1837.4715941070515, 1837.4715941070515, 1837.4715941070515, 21894.713607956142])\n\njulia> Atoms([100, 200])\nAtoms{Float64}([:X, :X], [0, 0], [100.0, 200.0])\n\n\n\n\n\n","category":"type"},{"location":"api/NQCBase/nqcbase/#NQCBase.PeriodicCell","page":"NQCBase","title":"NQCBase.PeriodicCell","text":"PeriodicCell{T<:AbstractFloat} <: AbstractCell\n\nOptionally periodic cell\n\n\n\n\n\n","category":"type"},{"location":"api/NQCBase/nqcbase/#NQCBase.check_atoms_in_cell-Tuple{PeriodicCell, AbstractMatrix}","page":"NQCBase","title":"NQCBase.check_atoms_in_cell","text":"check_atoms_in_cell(cell::PeriodicCell, R::AbstractMatrix)::Bool\n\nTrue if all atoms are inside the cell, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCBase/nqcbase/#NQCBase.read_extxyz-Tuple{Any}","page":"NQCBase","title":"NQCBase.read_extxyz","text":"read_extxyz(file)\n\nUses ExtXYZ.jl to read a .extxyz file\n\n\n\n\n\n","category":"method"},{"location":"api/NQCBase/nqcbase/#NQCBase.write_extxyz-Tuple{Any, Any, Matrix, Any}","page":"NQCBase","title":"NQCBase.write_extxyz","text":"write_extxyz(file, atoms, R, cell)\n\nUses ExtXYZ.jl to write a .extxyz file\n\nR can be either a single configuration (Matrix) or many (Vector{<:Matrix}).\n\n\n\n\n\n","category":"method"},{"location":"api/NQCBase/nqcbase/","page":"NQCBase","title":"NQCBase","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"@info \"Expanding src/NQCDistributions/overview.md...\"\nstart_time = time()","category":"page"},{"location":"NQCDistributions/overview/#NQCDistributions.jl","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"","category":"section"},{"location":"NQCDistributions/overview/#Storing-and-sampling-distributions","page":"NQCDistributions.jl","title":"Storing and sampling distributions","text":"","category":"section"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"In order to perform ensembles of trajectories, it is useful to have a convenient way to generate distributions of velocities and positions which can be sampled to initialise trajectories. The NQCDistributions.jl package contains the types and functions that seek to address this requirement as painlessly as possible. ","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"For quantum classical nonadiabatic dynamics simulations, the initial distributions contain both nuclear and electronic degrees of freedom.","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"note: Note\nCurrently, we allow for product distributions only, where the nuclear and electronic distributions are separable. In the future it would be great to remove this restriction, if you are interested, please open an issue on GitHub.","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"This page describes the types that can be used to represent nuclear and electronic distributions and demonstrates how they can be combined into a product distribution.","category":"page"},{"location":"NQCDistributions/overview/#Nuclear-Distributions-using-DynamicalDistribution","page":"NQCDistributions.jl","title":"Nuclear Distributions using DynamicalDistribution","text":"","category":"section"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"When handling distributions for the nuclear degrees of freedom, the DynamicalDistribution type can be used to store initial velocities and positions:","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"using NQCDynamics","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"d = DynamicalDistribution(10, 5, (3, 2))\nnothing # hide","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"Here, we have created a delta distribution with fixed velocities and positions, the final argument specifies the size of each sample. The (3, 2) case shown here would be appropriate when using 2 atoms each with 3 degrees of freedom.","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"rand(d)","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"DynamicalDistribution is flexible and each of the first two arguments can be Real, Vector or Sampleable.","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"note: Note\nReals are used whenever the same value is desired for every sample, as above.\nVectors can be provided when sampling a provided vector of configurations.\nSampleables are provided by Distributions.jl and can be used when specifying an   analytic distribution such as the Maxwell-Boltzmann distribution for velocities.","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"Each of these options can be composed in any combination, let's see the case where we have an analytic distribution of positions and a preset collection of velocities:","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"using Distributions\n\nvelocity = [[1.0 1.0;1.0 1.0], [2.0 2.0; 2.0 2.0], [3.0 3.0; 3.0 3.0]] \nposition = Normal()\nd = DynamicalDistribution(velocity, position, (2, 2))\nrand(d)","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"This has generated normally distributed positions along with one of the three velocities we provided.","category":"page"},{"location":"NQCDistributions/overview/#Sampling-the-nuclear-distribution","page":"NQCDistributions.jl","title":"Sampling the nuclear distribution","text":"","category":"section"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"To learn how to generate configurations to use with the DynamicalDistribution, read on to the next sections about the included sampling methods.","category":"page"},{"location":"NQCDistributions/overview/#VelocityBoltzmann","page":"NQCDistributions.jl","title":"VelocityBoltzmann","text":"","category":"section"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"When performing equilibrium simulations it is often desirable to initialise trajectories with thermal velocities, e.g. in combination with positions obtained from Monte Carlo sampling. These can be obtained for each atom from a gaussian distribution of the appropriate width, or alternatively, using the VelocityBoltzmann distribution which simplifies the process. This takes the temperature, masses and size of the system and ensures the samples you obtain are of the correct shape:","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"using NQCDynamics\nusing Unitful\n\nvelocity = VelocityBoltzmann(300u\"K\", rand(10), (3, 10))\nrand(velocity)","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"VelocityBoltzmann can also be called with a Simulation, since this contains  both the atomic masses and the desired dimensions of the system.","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"If the Simulation was set up with a Model which implements NQCModels.mobileatoms, immobile atoms  are correctly initialised with zero velocity. ","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"The resulting distribution can be handed directly to the DynamicalDistribution when Boltzmann velocities are required.","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"distribution = DynamicalDistribution(velocity, 1, (3, 10))\nrand(distribution)","category":"page"},{"location":"NQCDistributions/overview/#Wigner-distributions","page":"NQCDistributions.jl","title":"Wigner distributions","text":"","category":"section"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"For harmonic oscillator systems, we have implemented the analytic Wigner distribution. These are just mormal distributions of the appropriate width but can be accessed easily as in the following:","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"using NQCDistributions \n\nomega = 1.0;\nbeta = 1e-3;\nmass = 10;\n\ndist = PositionHarmonicWigner(omega, beta, mass, centre=0.0)\nrand(dist)\ndist = VelocityHarmonicWigner(omega, beta, mass)\nrand(dist)","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"These can also be given to the DynamicalDistribution since they are just univariate normal distributions.","category":"page"},{"location":"NQCDistributions/overview/#Nuclear-distributions-for-Ring-polymer-simulations","page":"NQCDistributions.jl","title":"Nuclear distributions for Ring polymer simulations","text":"","category":"section"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"The components making up a DynamicalDistribution can all be adapted for use in Ring Polymer simulations. ","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"For samplable components based on nuclear configurations, simply use three-dimensional arrays instead of two-dimensional ones. ","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"Pre-defined distribution functions such as VelocityBoltzmann can be turned into a three-dimensional version using the RingPolymerWrapper:","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"velocity = VelocityBoltzmann(300u\"K\", rand(10), (3, 10))\nvelocity_ring_polymer = RingPolymerWrapper(velocity, n_beads, Int[]) # RingPolymerWrapper(Distribution, number of ring-polymer beads, indices of atoms to treat classically)","category":"page"},{"location":"NQCDistributions/overview/#Electronic-distributions","page":"NQCDistributions.jl","title":"Electronic distributions","text":"","category":"section"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"For nonadiabatic dynamics, the initial electronic variables must also be sampled. For this, we can use an ElectronicDistribution which will tell our simulation how we want to sample the initial variables. Currently, two of these are provided, the PureState and the MixedState. The PureState is used for nonequilibrium simulations when the population is confined to a single state, whereas MixedState allows for a mixed state distribution.","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"using NQCDistributions \n\nPureState(1, Diabatic())\nPureState(2, Adiabatic())\nMixedState([1, 2], Diabatic())","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"These structs contain only the minimal information about the distributions, whereas the sampling of the distribution is handled separately by each of the different methods.","category":"page"},{"location":"NQCDistributions/overview/#Product-distributions-Combining-Nuclear-and-electronic-distributions","page":"NQCDistributions.jl","title":"Product distributions - Combining Nuclear and electronic distributions","text":"","category":"section"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"The initial nuclear and electronic states of a system can be combined in a product distribution, which can be used in place of a purely nuclear distribution for methods considering electronic dynamics.","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"nuclear_dist = DynamicalDistribution(velocity, position, (2, 2))\nelectronic_dist = PureState(2, Adiabatic())\n\ntotal_dist = nuclear_dist * electronic_dist\n\nrand(total_dist.nuclear) # Returns a random nuclear configuration\n\ntotal_dist.electronic.state # Returns the chosen electronic state. \n","category":"page"},{"location":"NQCDistributions/overview/","page":"NQCDistributions.jl","title":"NQCDistributions.jl","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCDynamics/initialconditions/","page":"InitialConditions","title":"InitialConditions","text":"@info \"Expanding src/api/NQCDynamics/initialconditions.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCDynamics/initialconditions/#InitialConditions","page":"InitialConditions","title":"InitialConditions","text":"","category":"section"},{"location":"api/NQCDynamics/initialconditions/","page":"InitialConditions","title":"InitialConditions","text":"Modules=[NQCDynamics.InitialConditions]","category":"page"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions","page":"InitialConditions","title":"NQCDynamics.InitialConditions","text":"InitialConditions\n\nFunctions and types for generating initial conditions for simulations.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/initialconditions/#ThermalMonteCarlo","page":"InitialConditions","title":"ThermalMonteCarlo","text":"","category":"section"},{"location":"api/NQCDynamics/initialconditions/","page":"InitialConditions","title":"InitialConditions","text":"Modules=[NQCDynamics.InitialConditions.ThermalMonteCarlo]","category":"page"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.ThermalMonteCarlo.run_advancedhmc_sampling-Tuple{Simulation, Any, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.ThermalMonteCarlo.run_advancedhmc_sampling","text":"run_advancedhmc_sampling(sim::Simulation, r, n_samples;\n    target_acceptance=0.5, kwargs...)\n\nPerform Hamiltonian Monte Carlo sampling for the simulation sim using AdvancedHMC.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.ThermalMonteCarlo.run_advancedmh_sampling-Tuple{NQCDynamics.AbstractSimulation, Any, Real, Dict{Symbol, <:Real}}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.ThermalMonteCarlo.run_advancedmh_sampling","text":"run_advancedmh_sampling(sim, r, steps, σ; movement_ratio=nothing, movement_ratio_internal=nothing, kwargs...)\n\nSample the configuration space for the simulation sim starting from r.\n\nTotal number of steps is given by steps and σ is the dictionary of step sizes for each species.\n\nmovement_ratio denotes the fraction of system moved each step. internal_ratio works as for movement_ratio but for the internal modes of the ring polymer. For movement_ratio = 0, every degree of freedom is moved at each step, if movement_ratio = 1, then nothing will happen. \n\nIf neither arguments are defined, default behaviour is to move one atom (and one ring polymer normal mode) per step on average. \n\nFurther kwargs are passed to AdvancedMH.sample to allow for extra functionality.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#QuantisedDiatomic","page":"InitialConditions","title":"QuantisedDiatomic","text":"","category":"section"},{"location":"api/NQCDynamics/initialconditions/","page":"InitialConditions","title":"InitialConditions","text":"Modules=[NQCDynamics.InitialConditions.QuantisedDiatomic]","category":"page"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic","text":"QuantisedDiatomic\n\nThis module exports two user facing functions:\n\ngenerate_configurations   Creates a set of velocities and positions for diatomic molecule with specified   vibrational ν and rotational J quantum numbers.\nquantise_diatomic   Obtains vibrational ν and rotational J quantum numbers for a diatomic molecule   with a given set of velocities and positions.\n\nThe central concept of this module is the EBK procedure which is nicely detailed here: [4]\n\nInspired by VENUS96: [29]\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.apply_random_rotation!-Tuple{Any, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.apply_random_rotation!","text":"Randomly rotate each column of two 3*N matrix, same rotation for all columns.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.calculate_diatomic_energy-Tuple{Real, NQCModels.AdiabaticModels.AdiabaticModel, NQCDynamics.InitialConditions.QuantisedDiatomic.EvaluationEnvironment}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.calculate_diatomic_energy","text":"calculate_diatomic_energy(model::AdiabaticModel, bond_length::Real;\n    height=10, normal_vector=[0, 0, 1])\n\nReturns potential energy of diatomic with bond_length at height from surface.\n\nOrients molecule parallel to the surface at the specified height within the simulation cell,  assuming the height has already been adjusted to include that of the surface. \n\n(this is checked in the EvaluationEnvironment constructor)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.classical_rotation_energy-Tuple{Union{Int64, CartesianIndex}, Any, Union{Int64, CartesianIndex}, Union{Int64, CartesianIndex}, Simulation}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.classical_rotation_energy","text":"classical_rotation_energy(J::Union{Int, CartesianIndex}, config::Any, ind1::Union{Int, CartesianIndex}, ind2::Union{Int, CartesianIndex}, sim::Simulation)\n\nClassical rotation energy of a rigid diatomic rotor in Hartree\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.classical_translational_energy-Tuple{Any, Union{Int64, CartesianIndex}, Union{Int64, CartesianIndex}, Simulation}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.classical_translational_energy","text":"classical_translational_energy(config::Any, ind1::Union{Int, CartesianIndex}, ind2::Union{Int, CartesianIndex}, sim::Simulation)\n\nReturns the classical translational energy in Hartree\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.combine_slab_and_molecule-Tuple{Any, Any, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.combine_slab_and_molecule","text":"combine_slab_and_molecule(atom_indices, molecule, slab)\n\nRevert the transformation separate_slab_and_molecule\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.configure_diatomic-Tuple{Any, Any, Any, Any, NQCDynamics.InitialConditions.QuantisedDiatomic.EvaluationEnvironment, NQCDynamics.InitialConditions.QuantisedDiatomic.GenerationParameters, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.configure_diatomic","text":"Randomly orient molecule in space for a given bond length and radial momentum\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.find_total_energy-Tuple{NQCDynamics.InitialConditions.QuantisedDiatomic.EffectivePotential, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.find_total_energy","text":"find_total_energy(V::EffectivePotential, ν)\n\nReturns the energy associated with the specified quantum numbers\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.generate_configurations-Tuple{Any, Any, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.generate_configurations","text":"generate_configurations(sim, ν, J; samples=1000, height=10, normal_vector=[0, 0, 1],\n    translational_energy=0, direction=[0, 0, -1], position=[0, 0, height])\n\nGenerate positions and momenta for given quantum numbers\n\ntranslational_energy, direction and position specify the kinetic energy in a specific direction with the molecule placed with centre of mass at position.\n\nKeyword arguments height and normal_vector become relevant if the potential requires specific placement of the molecule. These allow the molecule to be placed at a distance height in the direction normal_vector when performing potential evaluations.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.harmonic_vibration_energy-Tuple{Union{Int64, CartesianIndex}, Float64, Union{Int64, CartesianIndex}, Union{Int64, CartesianIndex}, Simulation}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.harmonic_vibration_energy","text":"harmonic_vibration_energy(ν::Union{Int, CartesianIndex}, k::Float, ind1::Union{Int, CartesianIndex}=1, ind2::Union{Int, CartesianIndex}=2, sim::Simulation)\n\nVibrational energy of a harmonic oscillator with the force constant k and vibrational level ν. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.quantise_diatomic-Tuple{Simulation, Matrix, Matrix, NQCDynamics.InitialConditions.QuantisedDiatomic.BindingCurve}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.quantise_diatomic","text":"quantise_diatomic(sim::Simulation, v::Matrix, r::Matrix, binding_curve::BindingCurve;\nshow_timer=false, reset_timer=false,\nheight=10, normal_vector=[0, 0, 1], atom_indices=[1,2], max_translation=1)\n)\n\nQuantise the vibrational and rotational degrees of freedom for the specified positions and velocities using the BindingCurve specified. A binding curve will be automatically generated if you do not supply one.\n\nIf the potential can be evaluated for the diatomic only, independent of position, supplying a Simulation for just the diatomic will speed up evaluation.\n\nWhen evaluating the potential, the molecule is moved to height in direction normal_vector. If the potential is independent of centre of mass position, this has no effect. Otherwise, be sure to modify these parameters to give the intended behaviour.\n\nIf a Simulation with a PeriodicCell is supplied, periodic copies of the diatomic atoms will be used if positions are close to cell boundaries. Set max_translation to the radius of surrounding unit cells to search. (e.g. 1 if positions are already wrapped around cell boundaries)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.quantise_diatomic-Tuple{Simulation, Matrix, Matrix}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.quantise_diatomic","text":"quantise_diatomic(sim::Simulation, v::Matrix, r::Matrix;\nbond_lengths=0.5:0.01:5.0,\nheight=10.0,\nsurface_normal=[0, 0, 1.0],\natom_indices=[1, 2],\nmax_translation=1,\nshow_timer=false, reset_timer=false\n)\n\nQuantise the vibrational and rotational degrees of freedom for the specified positions and velocities.\n\nIf the potential can be evaluated for the diatomic only, independent of position, supplying a Simulation for just the diatomic will speed up evaluation.\n\nWhen evaluating the potential, the molecule is moved to height in direction normal_vector. If the potential is independent of centre of mass position, this has no effect. Otherwise, be sure to modify these parameters to give the intended behaviour.\n\nIf a Simulation with a PeriodicCell is supplied, periodic copies of the diatomic atoms will be used if positions are close to cell boundaries. Set max_translation to the radius of surrounding unit cells to search. (e.g. 1 if positions are already wrapped around cell boundaries)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.quantise_diatomic-Tuple{Simulation, Vector{<:Matrix}, Vector{<:Matrix}}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.quantise_diatomic","text":"quantise_diatomic(sim::Simulation, v::Vector{Matrix}, r::Vector{Matrix};\nbond_lengths=0.5:0.01:5.0,\nheight=10.0,\nsurface_normal=[0, 0, 1.0],\natom_indices=[1, 2],\nshow_timer=false, reset_timer=false\n)\n\nQuantise the vibrational and rotational degrees of freedom of multiple atomic configurations given as a vector of velocity matrices and a vector of position matrices.\n\nIf the potential can be evaluated for the diatomic only, independent of position, supplying a Simulation for just the diatomic will speed up evaluation.\n\nWhen evaluating the potential, the molecule is moved to height in direction normal_vector. If the potential is independent of centre of mass position, this has no effect. Otherwise, be sure to modify these parameters to give the intended behaviour.\n\nIf a Simulation with a PeriodicCell is supplied, periodic copies of the diatomic atoms will be used if positions are close to cell boundaries. Set max_translation to the radius of surrounding unit cells to search. (e.g. 1 if positions are already wrapped around cell boundaries)\n\nSpecify show_timer=true for performance timings of the EBK quantisation process and reset_timer=true to see timings for each individual quantisation.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.select_random_bond_lengths-Tuple{Any, Any, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.select_random_bond_lengths","text":"Pick a random bond length and corresponding radial momentum that matches the radial probability distribution.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.separate_slab_and_molecule-Tuple{Any, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.separate_slab_and_molecule","text":"separate_slab_and_molecule(atom_indices, r)\n\nGet the coordinates of the molecule and slab separately.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.sqrt_avoid_negatives-Tuple{Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.sqrt_avoid_negatives","text":"sqrt_avoid_negatives(x)\n\nSame as sqrt but returns zero(x) if x is negative. Used here just in case the endpoints are a little off.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#MetropolisHastings","page":"InitialConditions","title":"MetropolisHastings","text":"","category":"section"},{"location":"api/NQCDynamics/initialconditions/","page":"InitialConditions","title":"InitialConditions","text":"Modules=[NQCDynamics.InitialConditions.MetropolisHastings]","category":"page"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings","text":"MetropolisHastings\n\nSampling of the initial conditions using the Metropolis-Hastings Markov chain Monte Carlo method.\n\nIncluded within is the ability to sample the canonical distribution for adiabatic classical and ring polymer systems.\n\nUsage involves creating an instance of an AbstractSystem{MonteCarlo} and calling run_monte_carlo_sampling.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.MonteCarlo","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.MonteCarlo","text":"Parameters for Monte carlo simulations.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.MonteCarloOutput","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.MonteCarloOutput","text":"Container for storing simulation quantities\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.acceptance_probability-Tuple{Simulation, NQCDynamics.InitialConditions.MetropolisHastings.MonteCarlo}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.acceptance_probability","text":"acceptance_probability(system::AbstractSystem{MonteCarlo})\n\nReturn the Metropolis-Hastings acceptance probability.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.apply_random_perturbation!-Tuple{Atoms, NQCDynamics.InitialConditions.MetropolisHastings.MonteCarloParameters, AbstractMatrix, Integer, Integer}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.apply_random_perturbation!","text":"apply_random_perturbation!(system::AbstractSystem{MonteCarlo}, R::AbstractMatrix, atom::Integer)\n\nRandomly perturb the xyz coordinates of a single atom.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.assess_proposal!-Tuple{NQCDynamics.AbstractSimulation, NQCDynamics.InitialConditions.MetropolisHastings.MonteCarloParameters, Any, Any, Any, Integer}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.assess_proposal!","text":"assess_proposal!(system::AbstractSystem{MonteCarlo}, Rᵢ, Rₚ, output, i)\n\nUpdate the energy, check for acceptance, and update the output. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.propose_centroid_move!-Union{Tuple{T}, Tuple{RingPolymerSimulation, NQCDynamics.InitialConditions.MetropolisHastings.PathIntegralMonteCarlo, Array{T, 3}, Array{T, 3}, Integer}} where T<:AbstractFloat","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.propose_centroid_move!","text":"propose_centroid_move!(system::RingPolymerSystem{MonteCarlo}, Rᵢ::Array{T, 3}, Rₚ::Array{T, 3}) where {T<:AbstractFloat}\n\nPropose a move for the ring polymer centroid for one atom.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.propose_move!-Tuple{Simulation, NQCDynamics.InitialConditions.MetropolisHastings.MonteCarlo, Matrix, Matrix, Integer}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.propose_move!","text":"propose_move!(system::System{MonteCarlo}, Rᵢ::Matrix{T}, Rₚ::Matrix{T}) where {T<:AbstractFloat}\n\nPropose simple cartesian move for a single atom.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.propose_normal_mode_move!-Union{Tuple{T}, Tuple{RingPolymerSimulation, NQCDynamics.InitialConditions.MetropolisHastings.PathIntegralMonteCarlo, Array{T, 3}, Array{T, 3}, Integer}} where T","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.propose_normal_mode_move!","text":"propose_normal_mode_move!(system::RingPolymerSystem{MonteCarlo}, Rᵢ::Array{T, 3}, Rₚ::Array{T, 3}) where {T}\n\nPropose a move for a single normal mode for a single atom.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.run_main_loop!-Tuple{Simulation, NQCDynamics.InitialConditions.MetropolisHastings.MonteCarlo, Matrix, Matrix, NQCDynamics.InitialConditions.MetropolisHastings.MonteCarloOutput}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.run_main_loop!","text":"run_main_loop!(system::System{MonteCarlo}, Rᵢ::Matrix, Rₚ::Matrix, output::MonteCarloOutput)\n\nMain loop for classical systems.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.run_main_loop!-Union{Tuple{T}, Tuple{RingPolymerSimulation, NQCDynamics.InitialConditions.MetropolisHastings.PathIntegralMonteCarlo, Array{T, 3}, Array{T, 3}, NQCDynamics.InitialConditions.MetropolisHastings.MonteCarloOutput}} where T","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.run_main_loop!","text":"Main loop for ring polymer systems.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.run_monte_carlo_sampling-Union{Tuple{T}, Tuple{Simulation, Matrix{T}, Dict{Symbol, T}, Real}} where T","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.run_monte_carlo_sampling","text":"run_monte_carlo_sampling(sim::AbstractSimulation, monte::MonteCarloParameters, R0)\n\nPerform Monte Carlo sampling for the system defined by the sim and monte parameters.\n\nFrom the initial positions specified R0 the system will be explored using the Metropolis-Hastings algorithm.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.write_output!-Tuple{NQCDynamics.InitialConditions.MetropolisHastings.MonteCarloOutput, AbstractArray, AbstractFloat}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.write_output!","text":"write_output!(output::MonteCarloOutput, Rᵢ::AbstractArray, energy::AbstractFloat, i::Integer)\n\nStore the current configuration and associated energy.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/","page":"InitialConditions","title":"InitialConditions","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"@info \"Expanding src/examples/reactive_scattering.md...\"\nstart_time = time()","category":"page"},{"location":"examples/reactive_scattering/#example-h2scattering","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"","category":"section"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"Our implementation allows us to simulate vibrational de-excitation probability during reactive scattering events at metal surfaces for any diatomic molecule  with a suitable model to describe energies and forces (and friction coefficients for MDEF simulations).  Here, we investigate the reactive scattering of hydrogen on a Cu(111) metal surface as a prototypical example.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"To run this kind of simulation, a set of initial positions and velocities (mathbfR and mathbfdotR) with ro-vibrational quantum states nu and j have to be generated (see EBK quantisation). With a specific ro-vibrational quantum state it is possible to compute different properties after molecular collision and energy transfer with the metal surface like the vibrational de-excitation probabilities discussed here.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"In order to reproduce the state-to-state vibrational de-excitation probability results presented originally by [22] for this system, the same initial conditions were generated with QuantisedDiatomic.generate_configurations setting the initial ro-vibrational quantum state to (nu=2 j=0) as was explored in the original paper. ","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"As shown earlier in the EBK documentation we are able to generate a semiclassically quantised distribution for a diatomic molecule on a collision course with a metal surface. In this example we follow the EBK example using machine learning potential to prepare our initial distribution and run our simulation.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"Specifically, we have produced a set of initial conditions with different translational energy (translational_energy keyword) ranging from 0.2 to 1.4 eV, locating the hydrogen molecule 8 Å away from the metal surface (height keyword) with a normal incidence.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"note: Atomic units\nAs usual, all quantities default to atomic units. Here we use Unitful to input the translational energy and height using different units, where they are later converted internally.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"julia @example h2scatter using NQCDynamics using Unitful using NQCDynamics.InitialConditions: QuantisedDiatomic using JLD2 using PythonCall","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"mace_calc = pyimport(\"mace.calculators\")","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"atoms = Atoms([:H, :H]) cell = PeriodicCell([11.1175 -5.5588 0.0; 0.0 9.628 0.0; 0.0 0.0 70.3079]) positions = [0.0 0.0; 0.0 0.0; 0.0 0.73] atomsase = NQCDynamics.convertfromaseatoms(atoms, positions, cell) ids_adsorbate = [55,56]","category":"page"},{"location":"examples/reactive_scattering/#load-PES-model","page":"Reactive scattering from a metal surface","title":"load PES model","text":"","category":"section"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"calculator = macecalc.MACECalculator(modelpath=\"../assets/mace/h2cu.model\", device=\"cpu\", defaultdtype=\"float32\") atomsase.setcalculator(calculator) model = AdiabaticASEModel(atomsase)","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"sim = Simulation(atoms, model; cell=cell)","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"ν, J = 2, 0     # selected ro-vibrational quantum states   nsamples = 10  # number of configurations       Ek = 0.5u\"eV\"   # Translational energy [eV] ; range considered [0.2-1.4] eV z = 8.0u\"Å\"     # Height [Å]  ; fixed at 8 Å z = angtoau(z)","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"configurations = QuantisedDiatomic.generateconfigurations(sim, ν, J;     samples=nsamples, translationalenergy=Ek, height=z) vh2 = first.(configurations) rh2 = last.(configurations)","category":"page"},{"location":"examples/reactive_scattering/#Re-build-the-position-and-velocities-for-the-whole-system-Cu56H2","page":"Reactive scattering from a metal surface","title":"Re build the position and velocities for the whole system Cu56H2","text":"","category":"section"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"dof = 3 aseio = pyimport(\"ase.io\") surfacease = aseio.read(\"../assets/h2cu/h2cusurf.traj@:nsamples\")","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"natoms = length(atoms) v = [zeros(dof,natoms) for i=1:length(rh2)] r = [zeros(dof,natoms) for i=1:length(r_h2)]","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"for i in 1:length(rh2)     surfatoms, surfpositions, surfcell = NQCDynamics.convertfromaseatoms(surfacease[i])     r[i][:,1:natoms-2] .= surfpositions     r[i][:,natoms-1:natoms] .= r_h2[i]  ","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"v[i][:,1:n_atoms-2] .= austrip.(transpose(surface_ase[i].get_velocities().*ase_units.fs)*u\"Å/fs\")\nv[i][:,n_atoms-1:n_atoms] .= v_h2[i]","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"end","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"atomsase = aseio.read(\"../assets/h2cu/h2cuinit.in\") atoms, positions, cell = convertfromaseatoms(atoms_ase)","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"distribution = DynamicalDistribution(v, r, (dof,length(atoms_ase))) nothing # hide","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"\n!!! tip \"Saving the distribution\"\n\n    Generally it will be desirable to generate a distribution once and re-use it for multiple dynamics simulations.\n    The simplest way to do this is to save the distribution using [JLD2.jl](https://juliaio.github.io/JLD2.jl/dev/).\n    Refer to [Saving and loading](@ref saving-and-loading) to learn more.\n\nIn order to produce an unweighted distribution, the lateral and angular orientation are randomly selected within the unit cell.\nAs an example of the spacial and orientation distribution generated with this module, a subset of data (300 configurations) is shown below.\nTo run our production simulations, however, a set of 80,000 initial velocities and positions were used.\n\n![initial conditions](../assets/figures/icond_scatter.png)\n\n## Data analysis and truncation function\n\nSince we are interested in the dynamics only when the molecule is close to the surface,\nwe can use a callback to terminate the simulation early to save us some time.\nThis requires defining a function that returns `true` when we want the simulation to\nterminate.\nThis means we can set our time span relatively long since we expect most simulations to\nterminate before reaching the time limit.\n","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"julia @example h2scatter using Statistics: mean using LinearAlgebra: norm","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"h2distance(p) = norm(p[:,idsadsorbate[1]] .- p[:,idsadsorbate[2]])","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"\"Terminates simulation if returns true.\"  mutable struct TrajectoryTerminator     h2indices     adsheightcutoff     adsdistcutoff     natomslayer end function (t::TrajectoryTerminator)(u, t, integrator)::Bool     R = getpositions(u)     comh2z = minimum(R[3,t.h2indices[1]:t.h2indices[2]])     topsurfaceavgz = mean(R[3,end-Int(t.natomslayer)-1:end-2])     zcom = autoang(comh2z-topsurfaceavgz) # Convert vertical centre of mass to angstrom     if zcom > t.adsheightcutoff                         # Scattering event         return true     elseif autoang(h2distance(R)) > t.adsdistcutoff   # Reactive event         return true     else         return false     end end","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"terminationcondition = TrajectoryTerminator(idsadsorbate, 8.1, 2.5, 9) terminate = DynamicsUtils.TerminatingCallback(termination_condition) tspan = (0.0, 420.0u\"fs\") nothing # hide","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"In this example, we consider the outcome a reactive event if the H-H\nbond length is larger than 2.5 Å in any point of during the trajectory and a\nscattering event if the molecule rebounds to a vertical distance from the metal\nsurface greater than 8.1 Å.\n\n## MDEF with the LDFA\n\nNow that we have set up the initial distribution and some of our simulation parameters,\nwe can choose which form of friction we would like use.\nFirst, let's use the cube-based density implementation for LDFA friction provided by the\n[FrictionProviders.jl](@ref friction-providers).\nThis takes a `.cube` file containing the electron density and will provide the friction\nduring the dynamics.\nHere we initialize the MACE-based interatomic potential, together with the cube-based calculator.\n","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"julia @example h2scatter","category":"page"},{"location":"examples/reactive_scattering/#load-PES-model-2","page":"Reactive scattering from a metal surface","title":"load PES model","text":"","category":"section"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"calculator = macecalc.MACECalculator(modelpath=\"../assets/mace/h2cu.model\", device=\"cpu\", defaultdtype=\"float32\") atomsase.setcalculator(calculator) modelpes = AdiabaticASEModel(atoms_ase)","category":"page"},{"location":"examples/reactive_scattering/#load-cube-EFT-calculator","page":"Reactive scattering from a metal surface","title":"load cube EFT calculator","text":"","category":"section"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"using FrictionProviders densitymodel = CubeLDFA(\"../assets/friction/test.cube\", cell) modeleft = LDFAFriction(densitymodel, atoms; frictionatoms=ids_adsorbate)","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"\nNow we can pass all the variables defined so far to the `Simulation` and run multiple\ntrajectories using [`run_dynamics`](@ref).\n","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"julia model = CompositeFrictionModel(modelpes, modeleft) sim = Simulation{MDEF}(atoms, model, cell=cell, temperature=300u\"K\") ensemble = run_dynamics(sim, tspan, distribution; selection=1:nsamples,     dt=0.1u\"fs\", output=OutputPosition, trajectories=nsamples, callback=terminate)","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"\n\n\n## MDEF with machine-learned LDFA \n\nAbove, we used the cube-based LDFA interpretation of MDEF to perform the simulation.\nHowever, in this scheme, surface atoms have to stay fixed to match the cube densities. To include surface temperature effects machine learning models can be trained that predict densities at any surface configuration.\nHere, we run MDEF simulation employing two machine learning models, to predict adiabatic PES (based on [MACE](https://github.com/ACEsuit/mace)) and surface electron density (based on [ACEpotentials.jl](https://github.com/ACEsuit/ACEpotentials.jl)), utilizing [FrictionProviders.jl](https://github.com/NQCD/FrictionProviders.jl), to run MDEF simulation.\n","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"julia using ACEpotentials acemodel, acemodelmeta = ACEpotentials.loadmodel(\"../assets/aceldfa/model.json\") densitymodel = AdiabaticModels.ACEpotentialsModel(atoms, cell, acemodel)  acedensitymodel = AceLDFA(densitymodel) modeleft = LDFAFriction(acedensitymodel, atoms; frictionatoms=ids_adsorbate)","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"model = CompositeFrictionModel(modelpes, modeleft)","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"sim = Simulation{MDEF}(atoms, model, cell=cell, temperature=300u\"K\") ensemble = run_dynamics(sim, tspan, distribution; selection=1:nsamples,     dt=0.1u\"fs\", output=OutputPosition, trajectories=nsamples, callback=terminate)","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"\n## MDEF with machine-learned TDPT (ODF)\n\nAbove, we used the LDFA interpretation of MDEF to perform the simulation. However, an alternative, TDPT (otherwise known as ODF) method can be used that provides full friction tensor. TDPT ML models can be incorporated in our simulation in a similar way as LDFA models, through (FrictionProviders.jl)[https://github.com/NQCD/FrictionProviders.jl]. Here, we show how this can be done for (ACEds)[https://github.com/ACEsuit/ACEds.jl] models. Such models require the usage of (JuLIP)[https://github.com/JuliaMolSim/JuLIP.jl]-type atoms. We can easily convert our ASE-type atoms into such format:\n","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"julia using ASE, JuLIP atomsasejl = ASE.ASEAtoms(atomsase) atomsjulip = JuLIP.Atoms(atomsasejl)","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"\nHaving our atoms, ACEds EFT models can be then initialized and combined with previously loaded potential model.\n","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"julia using ACE using ACEds.FrictionModels using ACEds.FrictionModels: Gamma acedsmodel = ACEdsODF(readdict(loaddict(\"../assets/acefriction/eftac.model\")), Gamma, atomsjulip) modeleft = ODFriction(acemodel; frictionatoms=idsadsorbate)","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"model = CompositeFrictionModel(modelpes, modeleft)","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"sim = Simulation{MDEF}(atoms, model, cell=cell, temperature=300u\"K\") ensemble = run_dynamics(sim, tspan, distribution; selection=1:nsamples,     dt=0.1u\"fs\", output=OutputPosition, trajectories=nsamples, callback=terminate)","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"\n## Visualisation\n\nTo show the effect of the truncation procedure, we have run 20 trajectories with and without the truncation\nfunction starting with an initial translation energy at 1.0 eV. For both figures, the total and kinetic energies are shown in\nthe top panels along with the H-H distance and centre of mass z coordinate for each\nindividual trajectory.\n\n![truncation](../assets/figures/scattering_truncation.png)\n\n\n","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"@setup logging runtime = round(time() - start_time; digits=2) @info \"...done after runtime s.\" ```","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"@info \"Expanding src/NQCModels/overview.md...\"\nstart_time = time()","category":"page"},{"location":"NQCModels/overview/#NQCModels.jl","page":"NQCModels.jl","title":"NQCModels.jl","text":"","category":"section"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"details: Overview of all model types currently implemented.\n<img src=\"../assets/figures/Model_types.svg\"  width=100% caption=\"Overview of all Model types currently implemented.\">","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"To perform nonadiabatic molecular dynamics simulations, it is necessary to define the system Hamiltonian. For simple models, this often comes in the form of small matrix in the diabatic representation but equally the electronic Hamiltonian could be obtained directly from ab initio electronic structure theory.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"NQCModels.jl is a package that aims to provide a common interface for defining these models that is flexible enough to allow for a wide range of specifications and requirements. NQCDynamics.jl uses this interface to obtain the potentials and couplings necessary to perform the dynamics simulations. Along with the minimal interface, NQCModels.jl also provides a small set of popular models often used in the field of nonadiabatic dynamics.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"note: Note\nTaking advantages of Julia's seamless modularity, NQCModels.jl is designed as a separate package so that it can also be used independently from the main package.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"Depending on the quantities provided by the Model, we use Julia's abstract type system to group models that provide the same quantities. Currently, there are two top-level abstract types: AdiabaticModel and DiabaticModel. The AdiabaticModel is used for adiabatic dynamics, providing only the potential and force used in classical mechanics. The DiabaticModel is used for nonadiabatic dynamics, where the potential is instead a Hermitian matrix.","category":"page"},{"location":"NQCModels/overview/#Using-Models","page":"NQCModels.jl","title":"Using Models","text":"","category":"section"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"In the Getting started section we briefly touched on how the AdiabaticModel works and introduced one of the included models. Here let's take a look at a DiabaticModel, which is more appropriate for nonadiabatic dynamics.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"The DoubleWell is a two state, 1 dimensional model where each state is harmonic with linear coupling to the single degree of freedom.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"using NQCModels\n\nmodel = DoubleWell()","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"Our DoubleWell implements the functions potential, derivative, nstates and ndofs that return the potential, the derivative of the potential, the number of states, and the number of degrees of freedom, respectively.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"potential(model, 0.2)\nderivative(model, 0.2)\nnstates(model)\nndofs(model)","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"Since this is a 1D model, the position argument that appears in the derivative and the potential is a real number. For higher dimensional models with multiple atoms, the position will need to be provided as an AbstractMatrix.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"To understand how this can extend to another dimension, we can take a quick look at the GatesHollowayElbow model which is another two state diabatic model, but this one uses two dimensions to model a diatomic molecule interacting with a surface. The two coordinates are the molecular bond length and the distance from the surface. Technically, the model has been defined such that there are two atoms, each with only a single degree of freedom. This allows us to use different masses for each of the coordinates when performing dynamics.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"model = GatesHollowayElbow()\npotential(model, [1.0 1.0])\nderivative(model, [1.0 1.0])\nnstates(model)\nndofs(model)","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"Here we see how the derivative now becomes a Matrix with size matching our input, but each entry is a Hermitian containing the elementwise derivative of the potential with respect to each degree of freedom. In this case, the Matrix has size = (1, 2), but it should be clear how this can extend to arbitrary numbers of atoms and degrees of freedom for complex models.","category":"page"},{"location":"NQCModels/overview/#Included-models","page":"NQCModels.jl","title":"Included models","text":"","category":"section"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"NQCModels.jl includes both analytical models as well as interfaces to connect to full-dimensional potential energy surfaces. An overview of the implemented analytical models can be seen in the Analytic model library and many shall return later when we investigate the dynamics methods. An overview of interfaces to full-dimensional potential energy surfaces can be seen in the Full dimensional model library.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"note: Contributing new models\nTo learn more about NQCModels.jl and learn how to implement new models, visit the developer documentation.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"@info \"Expanding src/devdocs/new_methods.md...\"\nstart_time = time()","category":"page"},{"location":"devdocs/new_methods/#Contributing-a-new-method","page":"Contributing a new method","title":"Contributing a new method","text":"","category":"section"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"A key goal of NQCDynamics.jl is to provide an accessible toolkit for implementing new nonadiabatic dynamics methods. This page details the steps you must take in order to create a new dynamics method. The existing methods are stored inside the DynamicsMethods submodule, and this is where new methods should be implemented. Technically, it is possible to implement new methods completely separately from the package by importing and extending the relevant functions but if you would like to include your method in the package, it should be added within this submodule.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"note: Note\nGenerally, each method has its own file, though similar methods are grouped into submodules and share functionality across files. For example, multiple surface hopping methods have been implemented in the submodule DynamicsMethods.SurfaceHoppingMethods, where some functions are shared across the files. ","category":"page"},{"location":"devdocs/new_methods/#Basic-implementation","page":"Contributing a new method","title":"Basic implementation","text":"","category":"section"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"To implement a new dynamics method, the necessary steps are:","category":"page"},{"location":"devdocs/new_methods/#Create-a-new-subtype-of-DynamicsMethods.Method.","page":"Contributing a new method","title":"Create a new subtype of DynamicsMethods.Method.","text":"","category":"section"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"This Method acts as an extra parameter inside the simulation that allows us to specify any extra information needed for our dynamics method. This can be a good place to include any temporary arrays and parameters for the simulation. Refer to the Julia manual section on Composite Types to learn how this types are created. Here, our type is called MyMethod and we have included an a parameter that will influence our dynamics:","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"using NQCDynamics\n\nstruct MyMethod <: DynamicsMethods.Method\n    a::Float64\nend","category":"page"},{"location":"devdocs/new_methods/#Implement-DynamicsVariables","page":"Contributing a new method","title":"Implement DynamicsVariables","text":"","category":"section"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"This function returns an AbstractArray of the variables to be used as the initial condition for the simulation. The array should contain all of the variables that will change during the dynamics.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"tip: Choosing an array format\nThe only constraint on the array type is that they are AbstractArrays. It could be a simple matrix or vector, but usually we use ComponentArrays.jl to structure the variables. The ComponentVector allows us to collect variables of different types into a convenient format to perform dynamics.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"For classical dynamics, this would include only the positions and velocities, however, for FSSH we must also include the continuous electronic variables and the discrete state.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"note: Discrete variables\nSome methods such as FSSH have discontinuous variables, like the current occupied state. Discrete variables be handled separately using DEDataArrays.jl. For surface hopping methods, we have the SurfaceHoppingVariables type that uses this to combine a ComponentVector containing the continuous variables and the discrete state label.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"For our new method, MyMethod, we implement the DynamicsVariables function and return a ComponentVector containing the velocities, positions and extra variables x. Inside this function we are free to take any inputs and manipulate them before returning the result. As an example, suppose that our x variables are randomly generated each time we run the dynamics, this could be done as follows:","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"using ComponentArrays\n\nfunction DynamicsMethods.DynamicsVariables(sim::Simulation{<:MyMethod}, v, r, k)\n    return ComponentVector(v=v, r=r, x=rand()*k)\nend","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"Here, we take the velocities v, positions r and assign them to the output as we would for classical dynamics, but we also generate a random between 0 and k, where k was given as input.","category":"page"},{"location":"devdocs/new_methods/#Implement-motion!(du,-u,-sim,-t)","page":"Contributing a new method","title":"Implement motion!(du, u, sim, t)","text":"","category":"section"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"This function should fill du with the time-derivative of the dynamics variables u in the usual way expected by DifferentialEquations.jl. We use the in-place version, where each element of du is filled with the time derivative of the correponding element in u.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"Inside the DynamicsUtils submodule there are some useful functions like velocity! and divide_by_mass! which can handle some of the common parts of the motion! function. You are free to perform whatever manipulations you like inside this function, but note that motion! is a performance critical function, called numerous times during the simulation, so you should attempt to minimise allocations inside this function.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"note: Note\nBy convention in Julia, functions that end with the ! modify at least one of their arguments.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"function DynamicsMethods.motion!(du, u, sim::Simulation{MyMethod}, t)\n\n    DynamicsUtils.velocity!(du.r, u.v, u.r, sim, t) # Set du.r equal to the velocity\n\n    # Set the acceleration of the particles\n    du.v .= -sim.method.a .* u.r # Use the `a` parameter we stored in the `method`.\n    DynamicsUtils.divide_by_mass!(du.v, sim.atoms.masses) # Divide du.v by the mass\n\n    du.x .= 1 ./ u.x # Set time derivative of `x`.\n\n    return nothing # The return of this function is not used so the return is unimportant\nend","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"Here we have set the time derivative of the positions equal to the velocity, the time derivative of the velocities equal to the acceleration where the force involves the parameter a. Finally, the time derivative of the extra x variable is also set.","category":"page"},{"location":"devdocs/new_methods/#Solve-a-trajectory","page":"Contributing a new method","title":"Solve a trajectory","text":"","category":"section"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"To perform a simulation with our new method, we can write a script in the usual format and run the dynamics. In this script, we have a single atom with a mass of 1 with a single degree of freedom. We match this by initialising the positions and velocities equal to random 1x1 matrices.  The a parameter of the method has been set equal to 2.0, and the initial value of x has been set to 0.5.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"sim = Simulation(Atoms(1), Free(), MyMethod(2.0))\nu = DynamicsVariables(sim, rand(1,1), rand(1,1), [0.5])\n\nsol = run_dynamics(sim, (0.0, 5.0), u, output=(OutputPosition, OutputVelocity, OutputDynamicsVariables))","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"note: Note\nIn the definition of our motion! method, we have accessed only the atoms field of the simulation. This means that the model we pass to the Simulation constructor is not used. Generally the model is accessed through the calculator interface and examples of its usage can be found by referring the implementations of the existing methods.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"To visualise the result we can plot each of the quantities from the output table:","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"using Plots\n\nplot(sol, :OutputPosition, label=\"Position\")\nplot!(sol, :OutputVelocity, label=\"Velocity\")\nplot!(sol, :OutputDynamicsVariables, label=\"Dynamics variables\", legend=true)\nylabel!(\"Value(t)\")","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"note: Note\nThe additional x parameter that we created cannot be accessed in the output tuple with a pre-existing function as with position and velocity since it is not a standard quantity. Instead, we request OutputDynamicsVariables which contains all of the dynamical variables. In the plot, two of the lines labelled DynamicsVariables overlap the position and velocity result. The unique line labelled Dynamics variables is the x variable. When implementing your method, if you want to add new output quantities you should do this inside the DynamicsOutputs submodule.","category":"page"},{"location":"devdocs/new_methods/#Advanced-tips","page":"Contributing a new method","title":"Advanced tips","text":"","category":"section"},{"location":"devdocs/new_methods/#Is-there-a-custom-algorithm-you-can-implement?","page":"Contributing a new method","title":"Is there a custom algorithm you can implement?","text":"","category":"section"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"Some dynamics methods have special algorithms that are tailored to the specific problem and achieve better performance than the general algorithms include in DifferentialEquations.jl. For example, ring polymer methods typically use a symplectic scheme to solve for the internal modes of the ring polymer, allowing much larger timesteps. The DifferentialEquations.jl framework provides a simple interface for adding new algorithms, check out the developer documentation to learn how it works. You can also find some examples of custom algorithms in the DynamicsMethods.IntegrationAlgorithms module.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"@info \"Expanding src/devdocs/models.md...\"\nstart_time = time()","category":"page"},{"location":"devdocs/models/#devdocs-model","page":"Implementing a new model","title":"Implementing a new model","text":"","category":"section"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"NQCModels.jl aims to provide a unified interface for defining model Hamiltonians for nonadiabatic dynamics simulations.","category":"page"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"Here, we walk through the implementation of a few different types of model to explain the interface.","category":"page"},{"location":"devdocs/models/#Abstract-types","page":"Implementing a new model","title":"Abstract types","text":"","category":"section"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"Julia's abstract type system can be likened to the inheritance concept from object-oriented programming or the trait system from Rust. It allows us to defined shared behaviour for a groups of structs and allows us to define a common set of functions that all of the concrete types must implement.","category":"page"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"In NQCModels.jl the top level abstract type is the Model, under which all of our models must fall. The second tier below this includes the two abstract types AdiabaticModel and DiabaticModel. These form the two distinct branches within the NQCModels type hierachy and the shared behaviour across the branches is minimal. The AdiabaticModel describes the familiar form from molecular dynamics that provides a single potential energy surface. The DiabaticModel instead provides  multiple potential energy surfaces with couplings between them. As implied by the name, these are in the diabatic representation. If the desired model does not fall under either of these branches, a new abstract type should be created.","category":"page"},{"location":"devdocs/models/#Minor-branches","page":"Implementing a new model","title":"Minor branches","text":"","category":"section"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"Under the two main branches there also exists some specialised abstract types that are useful in some cases, such as when using many electronic states, or when implementing extra functions is required. See the docstrings for more info:","category":"page"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"AdiabaticFrictionModel\nLargeDiabaticModel\nDiabaticFrictionModel","category":"page"},{"location":"devdocs/models/#Example-implementations","page":"Implementing a new model","title":"Example implementations","text":"","category":"section"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"To implement a new model, you first select the abstract type, where you should first take a look at the docstring for the abstract type (click on the links above). There, a list of the functions  that need to be implemented along with an example implementation are provided.","category":"page"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"For further examples, you can also take a look into the source code of the NQCModels.jl package to see how the analytic models have been implemented.  If you have any issues or questions about implementing a new model, open up an issue on Github and we can work together to resolve the problem. ","category":"page"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCModels/mace/","page":"MACEModels.jl","title":"MACEModels.jl","text":"@info \"Expanding src/api/NQCModels/mace.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCModels/mace/#MACEModels.jl","page":"MACEModels.jl","title":"MACEModels.jl","text":"","category":"section"},{"location":"api/NQCModels/mace/","page":"MACEModels.jl","title":"MACEModels.jl","text":"Modules = [MACEModels, MACEModels.Ensemble]\nPrivate = true","category":"page"},{"location":"api/NQCModels/mace/#MACEModels.MACEModel","page":"MACEModels.jl","title":"MACEModels.MACEModel","text":"MACE interface with support for ensemble of models and batch size selection for potentially faster inference.\n\nDOFs currently hardcoded at 3.\n\nFields\n\nmodel_paths::Vector{String}: Model paths to load. If multiple paths are given, an ensemble of models is used and mean energies/forces used to propagate dynamics.\nmodels::Vector: Loaded models.\ndevice::Vector{String}: Device to use for inference. If a single device is given, all models will be loaded on that device. If multiple devices are given, each model will be loaded on the corresponding device. Default is \"cpu\".\ndefault_dtype::Type{T}: Default data type for inference. Default is Float32.\nbatch_size::Union{Int,Nothing}: Batch size for inference. Default is 1.\ncutoff_radius::T: Cutoff radius for the models.\nlast_eval_cache::MACEPredictionCache: Cache for the last evaluation.\nz_table: Table of atomic numbers.\natoms::Atoms: Atoms object for the system.\ncell::PeriodicCell: Periodic cell for the system.\nndofs::Int: Number of degrees of freedom in the system.\nmobile_atoms::Vector{Int}: Indices of mobile atoms in the system.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/mace/#MACEModels.MACEModel-Tuple{Atoms, AbstractCell, Vector{String}}","page":"MACEModels.jl","title":"MACEModels.MACEModel","text":"MACEModel(\natoms::Atoms,\ncell::AbstractCell,\nmodel_paths::Vector{String};\ndevice::Union{String,Vector{String}}=\"cpu\",\ndefault_dtype::Type=Float32,\nbatch_size::Int=1,\nmobile_atoms::Vector{Int}=collect(1:length(atoms)),\n\n)     modelpaths::Vector{String},     device::Union{String, Vector{String}}=\"cpu\",     defaultdtype::Type=Float64,     batch_size::Int=1,     atoms,     cell, )\n\nInterface to MACE machine learning interatomic potentials with support for ensemble of models and batch size selection for potentially faster inference.\n\nArguments\n\natoms: Atoms object for the system. predict! can be called with a Vector of different Atoms objects to evaluate different structures.\ncell: Cell object for the system. predict! can be called with a Vector of different Cell objects to evaluate different structures.\nmodel_paths::Vector{String}: Model paths to load. If multiple paths are given, an ensemble of models is used and mean energies/forces used to propagate dynamics.\ndevice::Union{String, Vector{String}}: Device to use for inference. If a single device is given, all models will be loaded on that device. If multiple devices are given, each model will be loaded on the corresponding device. Default is \"cpu\".\ndefault_dtype::Type: Default data type for PyTorch (usually Float32)\nbatch_size::Int: Batch size for inference. Can be set to nothing to always adapt batch size to the number of structures provided. Ring-polymer methods benefit from this.\nmobile_atoms::Vector{Int}: Indices of mobile atoms in the system. Default is all atoms.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#MACEModels.MACEPredictionCache","page":"MACEModels.jl","title":"MACEModels.MACEPredictionCache","text":"Cache which stores the results of the last evaluation of the MACE model. This is used to speed up concurrent energy and force evaluations, as well as to give access to ensemble predictions.\n\nUse e.g. get_energy_mean(MACEModel.last_eval_cache) to access results of the last prediction made by the model.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/mace/#MACEModels.get_energy_ensemble-Tuple{MACEPredictionCache}","page":"MACEModels.jl","title":"MACEModels.get_energy_ensemble","text":"get_energy_ensemble(mace_cache::MACEPredictionCache)\n\nReturns the potential energy evaluated by each model in the ensemble in units of Hartree.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#MACEModels.get_energy_mean-Tuple{MACEPredictionCache}","page":"MACEModels.jl","title":"MACEModels.get_energy_mean","text":"get_energy_mean(mace_cache::MACEPredictionCache)\n\nReturns the mean potential energy of the structures stored in the evaluation cache.\n\nEnergy is returned in units of Hartree.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#MACEModels.get_energy_variance-Tuple{MACEPredictionCache}","page":"MACEModels.jl","title":"MACEModels.get_energy_variance","text":"get_energy_variance(mace_cache::MACEPredictionCache)\n\nReturns the variance of the potential energy in Hartree².\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#MACEModels.get_forces_ensemble-Tuple{MACEPredictionCache}","page":"MACEModels.jl","title":"MACEModels.get_forces_ensemble","text":"get_forces_ensemble(mace_cache::MACEPredictionCache)\n\nReturns the forces evaluated by each model in the ensemble in units of Hartree/Bohr.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#MACEModels.get_forces_mean-Tuple{MACEPredictionCache}","page":"MACEModels.jl","title":"MACEModels.get_forces_mean","text":"get_forces_mean(mace_cache::MACEPredictionCache)\n\nReturns the mean forces of the structures stored in the evaluation cache. Forces are returned in units of Hartree/Bohr.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#MACEModels.get_forces_variance-Tuple{MACEPredictionCache}","page":"MACEModels.jl","title":"MACEModels.get_forces_variance","text":"get_forces_variance(mace_cache::MACEPredictionCache)\n\nReturns the force variance of the structures stored in the evaluation cache. Forces are returned in units of Hartree²/Bohr².\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#MACEModels.mace_configuration_from_nqcd_configuration-Tuple{Atoms, AbstractCell, AbstractMatrix}","page":"MACEModels.jl","title":"MACEModels.mace_configuration_from_nqcd_configuration","text":"mace_configuration_from_nqcd_configuration(\natoms::Atoms,\ncell::Union{InfiniteCell, PeriodicCell},\nR::AbstractMatrix,\n\n)\n\nConverter into a single mace.data.utils.Configuration to make use of MACE's data loading.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#MACEModels.predict!-Tuple{MACEModel, Union{Atoms, Vector{<:Atoms}}, Vector{<:AbstractMatrix}, Union{AbstractCell, Vector{<:AbstractCell}}}","page":"MACEModels.jl","title":"MACEModels.predict!","text":"predict!(\nmace_interface::MACEModel,\natoms::Union{Vector{<:Atoms}, Atoms},\nR::Vector{<:AbstractMatrix},\ncell::Union{Vector{<:AbstractCell}, AbstractCell},\n)\n\nEvaluate the MACE model on a set of structures if they haven't already been evaluated. The results are stored in mace_interface.last_eval_cache.\n\nUse methodswith(MACEPredictionCache) to see what data is provided from the results\n\nArguments\n\nmace_interface: MACEModel to evaluate with.\n\natoms: Atoms object for the structures passed for evaluation. Can be either a vector of different Atoms objects or a single Atoms object.\n\nR: Vector of structures to evaluate.\n\ncell: Cell object for the structures passed for evaluation. Can be either a vector of different Cell objects or a single Cell object.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#MACEModels.predict-Tuple{MACEModel, Union{Atoms, Vector{<:Atoms}}, Vector{<:AbstractMatrix}, Union{AbstractCell, Vector{<:AbstractCell}}}","page":"MACEModels.jl","title":"MACEModels.predict","text":"predict(\nmace_interface::MACEModel,\natoms::Union{Vector{<:Atoms}, Atoms},\nR::Vector{<:AbstractMatrix},\ncell::Union{Vector{<:AbstractCell}, AbstractCell},\n)\n\nEvaluate the MACE model on a set of structures if they haven't already been evaluated. The results are returned as a MACEPredictionCache.\n\nUse methodswith(MACEPredictionCache) to see what data can be provided from the results.\n\nArguments\n\nmace_interface: MACEModel to evaluate with.\n\natoms: Atoms object for the structures passed for evaluation. Can be either a vector of different Atoms objects or a single Atoms object.\n\nR: Vector of structures to evaluate.\n\ncell: Cell object for the structures passed for evaluation. Can be either a vector of different Cell objects or a single Cell object.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#NQCModels.derivative!-Union{Tuple{T}, Tuple{MACEModel, Atoms, AbstractArray{T, 3}, Vector{<:AbstractMatrix}, Union{InfiniteCell, PeriodicCell}}} where T","page":"MACEModels.jl","title":"NQCModels.derivative!","text":"NQCModels.derivative(model::MACEModel, atoms::Atoms, R::AbstractArray{T,3}, cell::Union{InfiniteCell, PeriodicCell})\n\nThis variant of NQCModels.derivative can make use of batch evaluation to speed up inference for multiple structures.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#NQCModels.derivative-Tuple{MACEModel, Atoms, Vector{<:AbstractMatrix}, Union{InfiniteCell, PeriodicCell}}","page":"MACEModels.jl","title":"NQCModels.derivative","text":"NQCModels.derivative(model::MACEModel, atoms::Atoms, R::Vector{<:AbstractMatrix}, cell::Union{InfiniteCell, PeriodicCell})\n\nThis variant of NQCModels.derivative can make use of batch evaluation to speed up inference for multiple structures.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#NQCModels.potential-Tuple{MACEModel, Atoms, Vector{<:AbstractMatrix}, AbstractCell}","page":"MACEModels.jl","title":"NQCModels.potential","text":"NQCModels.potential(model::MACEModel, atoms::Atoms, R::Vector{<:AbstractMatrix}, cell::AbstractCell)\n\nThis variant of NQCModels.potential can make use of batch evaluation to speed up inference for multiple structures.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#MACEModels.Ensemble.CustomSplitDistributed","page":"MACEModels.jl","title":"MACEModels.Ensemble.CustomSplitDistributed","text":"Ensemble algorithm which enforces the split between dynamics and inference workers provided.\n\nEven when specifying this EnsembleAlgorithm, you still need to manually dispatch\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/mace/#MACEModels.Ensemble.EnergyForcesCache","page":"MACEModels.jl","title":"MACEModels.Ensemble.EnergyForcesCache","text":"Containers for energy and forces, to be used in the RemoteModel.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/mace/#MACEModels.Ensemble.MultiProcessConfig-Tuple{Any, Any, Function, Any}","page":"MACEModels.jl","title":"MACEModels.Ensemble.MultiProcessConfig","text":"MultiProcessConfig(runners, evaluators, model_load_function::Function, positions_prototype; model_listener::Function=batch_evaluation_loop)\n\nConfiguration for distributed execution dynamics propagation and model evaluation.\n\nArguments\n\nrunners::Vector{Int}: Process IDs of the NQCDynamics workers.\nevaluators::Vector{Int}: Process IDs of the model evaluators.\nmodel_load_function::Function: Function ()->x<:Model that can load the model to be evaluated on any process. (i.e. not specific to a process)\nmodel_listener::Function: Function that listens for structures on the input channels and outputs the results on the output channels. Default is batch_evaluation_loop. (model, input_channels, output_channels)->()\npositions_prototype: Sample atomic positions to determine system size.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#MACEModels.Ensemble.RemoteModel-Tuple{MACEModels.Ensemble.MultiProcessConfig, Any}","page":"MACEModels.jl","title":"MACEModels.Ensemble.RemoteModel","text":"RemoteModel(config::MultiProcessConfig, structure_prototype)\n\nCreates a RemoteModel that can be used to evaluate structures on a remote process.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/#MACEModels.Ensemble.batch_evaluation_loop-Tuple{Function, Vector{Distributed.RemoteChannel}, Vector{Distributed.RemoteChannel}}","page":"MACEModels.jl","title":"MACEModels.Ensemble.batch_evaluation_loop","text":"batch_evaluation_loop(model<:Model, input_channels::Vector{RemoteChannel}, output_channels::Vector{RemoteChannel}; user_model_function::Function=mace_batch_predict, max_delay = 1000)\n\nThis doesn't know how to use your model most efficiently, it only handles I/O between processes!\n\nTo use this communication wrapper, you need to define a function that evaluates your model and returns a tuple of energies and forces, as shown in the example:\n\nfunction user_model_function(model<:Model, structures::AbstractVector{AbstractMatrix{Number}})\n    MACEModels.predict!(model, model.atoms, structures, model.cell)\n    energies = MACEModels.get_energy_mean(model.last_eval_cache) # This is a Vector{Number} type\n    forces = MACEModels.get_forces_mean(model.last_eval_cache) # This is a Vector{Matrix{Number}} type\n    return (energies, forces)\nend\n\nIt polls the input channels for new structures, and when it finds them, it evaluates them using the user-defined model function. The results are then put back into the correct output channels.\n\nArguments\n\nmodel::Model: The model that will be used for evaluation.\ninput_channels::Vector{RemoteChannel}: The input channels that will be used to receive structures.\noutput_channels::Vector{RemoteChannel}: The output channels that will be used to send the results.\nuser_model_function::Function: The user-defined function that will be used to evaluate the model.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/mace/","page":"MACEModels.jl","title":"MACEModels.jl","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"initialconditions/langevin/","page":"Thermal Langevin dynamics","title":"Thermal Langevin dynamics","text":"@info \"Expanding src/initialconditions/langevin.md...\"\nstart_time = time()","category":"page"},{"location":"initialconditions/langevin/#langevin-sampling","page":"Thermal Langevin dynamics","title":"Thermal Langevin dynamics","text":"","category":"section"},{"location":"initialconditions/langevin/","page":"Thermal Langevin dynamics","title":"Thermal Langevin dynamics","text":"Thermal initial conditions can be obtained directly from a Langevin dynamics simulations. See the Langevin dynamics page for more info.","category":"page"},{"location":"initialconditions/langevin/","page":"Thermal Langevin dynamics","title":"Thermal Langevin dynamics","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCDynamics/estimators/","page":"Estimators","title":"Estimators","text":"@info \"Expanding src/api/NQCDynamics/estimators.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCDynamics/estimators/#Estimators","page":"Estimators","title":"Estimators","text":"","category":"section"},{"location":"api/NQCDynamics/estimators/","page":"Estimators","title":"Estimators","text":"Modules=[NQCDynamics.Estimators]","category":"page"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators","page":"Estimators","title":"NQCDynamics.Estimators","text":"Estimators\n\nFunctions for computing thermal expectation values as ensemble averages.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators.adiabatic_population","page":"Estimators","title":"NQCDynamics.Estimators.adiabatic_population","text":"adiabatic_population\n\n\n\n\n\n","category":"function"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators.diabatic_population","page":"Estimators","title":"NQCDynamics.Estimators.diabatic_population","text":"diabatic_population\n\n\n\n\n\n","category":"function"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators.kinetic_energy-Tuple{Simulation, Any}","page":"Estimators","title":"NQCDynamics.Estimators.kinetic_energy","text":"kinetic_energy(sim, u)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators.potential_energy-Tuple{NQCDynamics.AbstractSimulation, Any}","page":"Estimators","title":"NQCDynamics.Estimators.potential_energy","text":"potential_energy(sim, u)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators.radius_of_gyration-Union{Tuple{T}, Tuple{RingPolymerSimulation, AbstractArray{T, 3}}} where T","page":"Estimators","title":"NQCDynamics.Estimators.radius_of_gyration","text":"radius_of_gyration(sim, r)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators.total_energy-Tuple{NQCDynamics.AbstractSimulation, Any}","page":"Estimators","title":"NQCDynamics.Estimators.total_energy","text":"total_energy(sim, u)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators.@estimate-Tuple{Any}","page":"Estimators","title":"NQCDynamics.Estimators.@estimate","text":"@estimate f(simulation, vector)\n\nEvaluate f(simulation, vector[i]) for all i and return the average.\n\nCan be used for any function defined in Estimators.jl.\n\n\n\n\n\n","category":"macro"},{"location":"api/NQCDynamics/estimators/","page":"Estimators","title":"Estimators","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"@info \"Expanding src/NQCModels/fullsizemodels.md...\"\nstart_time = time()","category":"page"},{"location":"NQCModels/fullsizemodels/#Full-dimensional-model-library","page":"Full dimensional model library","title":"Full dimensional model library","text":"","category":"section"},{"location":"NQCModels/fullsizemodels/#ASE-interface","page":"Full dimensional model library","title":"ASE interface","text":"","category":"section"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"The easiest way to obtain potentials and forces from established codes is to use the interfaces implemented in ASE.","category":"page"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"We provide the AdiabaticASEModel which wraps an ASE atoms object and its associated calculator to implement the required potential and derivative functions. Several examples for connecting common machine-learning interatomic potentials to NQCModels.jl through the ASE interface are shown in the MLIP examples section.","category":"page"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"note: Note\nThe interface works by calling the relevant Python functions using PyCall. To use PyCall, you must make sure that your python version contains all the relevant packages, such as ase. PyCall can be configured to use a particular pre-installed Python or install its own. Refer to the PyCall README for installation and configuration instructions.","category":"page"},{"location":"NQCModels/fullsizemodels/#Example","page":"Full dimensional model library","title":"Example","text":"","category":"section"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"First, it is necessary to import ase and create the ase.Atoms object and attach the desired calculator. This works exactly as in Python:","category":"page"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"using PythonCall: pyimport, pylist\nusing ASEconvert\n\nemt = pyimport(\"ase.calculators.emt\")\n\nh2 = ase.Atoms(\"H2\", pylist([(0, 0, 0), (0, 0, 0.74)]))\nh2.calc = emt.EMT()\nnothing # hide","category":"page"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"Next, the AdiabaticASEModel is created by passing the ase.Atoms object directly to the model:","category":"page"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"using NQCModels\nmodel = AdiabaticASEModel(h2)","category":"page"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"Now the model can be used in the same way as any of the previously introduced analytic models.","category":"page"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"potential(model, rand(3, 2))\nderivative(model, rand(3, 2))","category":"page"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"tip: Tip\nIn theory, this should work with any of the ASE calculators that correctly implement the get_potential_energy and get_forces functions. For instance, you can use SchNetPack (SPK) by passing their ASE calculator to the AdiabaticASEModel. Take a look at MLIP examples to learn more.","category":"page"},{"location":"NQCModels/fullsizemodels/#MACE-interface","page":"Full dimensional model library","title":"MACE interface","text":"","category":"section"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"MACEModels.jl is an interface to the MACE code. The package attempts to improve calculation speeds by directly interfacing with MACE, instead of going through ase.","category":"page"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"More information on how to use MACE models is available in the MACEModels.jl API documentation. ","category":"page"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"tip: Tip\nTo make the installation of a python environment to execute MACE in optional, the MACEModel is provided in a separate package, which needs to be installed with ]add MACEModels. ","category":"page"},{"location":"NQCModels/fullsizemodels/#Example-2","page":"Full dimensional model library","title":"Example","text":"","category":"section"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"using NQCModels, PyCall, NQCDynamics.jl, MACEModels\n\nensemble_paths = [\n    \"model01.model\",\n    \"model02.model\",\n    \"model03.model\",\n]\n\nstructure = Atoms([:N, :H, :H, :H]) # Define the structure\ncell = InfiniteCell() # Set periodicity (none in this case)\n\n# Create the MACE model\nmodel = MACEModel(\n    atoms, # Atoms (used for neighbour lists)\n    cell, # Cell (used for neighbour lists)\n    ensemble_paths; # Vector containing paths to one or more models\n    device = \"cpu\", # Device (or vector of devices) to use\n    default_dtype = Float32, # Data type of the models (Float32 or Float64)\n    batch_size = 1, # Number of structures to evaluate at once (improves overall throughput)\n)","category":"page"},{"location":"NQCModels/fullsizemodels/","page":"Full dimensional model library","title":"Full dimensional model library","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"@info \"Expanding src/NQCModels/analyticmodels.md...\"\nstart_time = time()","category":"page"},{"location":"NQCModels/analyticmodels/#Analytic-model-library","page":"Analytic model library","title":"Analytic model library","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"This page plots many of the analytic models included in NQCDynamics.","category":"page"},{"location":"NQCModels/analyticmodels/#[AdiabaticModels](@ref-NQCModels.AdiabaticModels)","page":"Analytic model library","title":"AdiabaticModels","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"These models are used for classical dynamics and provide a single potential energy surface.","category":"page"},{"location":"NQCModels/analyticmodels/#[Harmonic](@ref)","page":"Analytic model library","title":"Harmonic","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nplot(-10:0.1:10, Harmonic())","category":"page"},{"location":"NQCModels/analyticmodels/#[DiatomicHarmonic](@ref)","page":"Analytic model library","title":"DiatomicHarmonic","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\n\nmodel = DiatomicHarmonic(r₀=10.0)\nf(x,y) = potential(model, [x y 0])\ncontour(-10:0.1:10, -10:0.1:10, f, fill=true)\nxlabel!(\"x coordinate /a₀\")\nylabel!(\"y coordinate /a₀\")","category":"page"},{"location":"NQCModels/analyticmodels/#[DarlingHollowayElbow](@ref)","page":"Analytic model library","title":"DarlingHollowayElbow","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nusing NQCBase: eV_to_au\n\nmodel = DarlingHollowayElbow()\nV(x,z) = potential(model, [x, z])\n\nx = range(-0.5, 3.5, length=200)\nz = range(-0.5, 4.5, length=200)\n\nplot(\n    xlabel=\"Bond length /a₀\",\n    ylabel=\"Surface molecule distance /a₀\",\n    xlims=(-0.5, 3.5),\n    ylims=(-0.5, 4.5)\n)\n\ncontourf!(x, z, V)","category":"page"},{"location":"NQCModels/analyticmodels/#[DiabaticModels](@ref-NQCModels.DiabaticModels)","page":"Analytic model library","title":"DiabaticModels","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"These models define a Hermitian potential operator in a diabatic basis. These can be used for various forms of nonadiabatic dynamics.","category":"page"},{"location":"NQCModels/analyticmodels/#[TullyModelOne](@ref)","page":"Analytic model library","title":"TullyModelOne","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nplot(-10:0.1:10, TullyModelOne(); coupling=true)","category":"page"},{"location":"NQCModels/analyticmodels/#[TullyModelTwo](@ref)","page":"Analytic model library","title":"TullyModelTwo","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nplot(-10:0.1:10, TullyModelTwo(); coupling=true)","category":"page"},{"location":"NQCModels/analyticmodels/#[TullyModelThree](@ref)","page":"Analytic model library","title":"TullyModelThree","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nplot(-10:0.1:10, TullyModelThree(); coupling=true)","category":"page"},{"location":"NQCModels/analyticmodels/#[ThreeStateMorse](@ref)","page":"Analytic model library","title":"ThreeStateMorse","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nplot(2:0.01:12, ThreeStateMorse(), ylims=(0, 0.06), coupling=true)","category":"page"},{"location":"NQCModels/analyticmodels/#[OuyangModelOne](@ref)","page":"Analytic model library","title":"OuyangModelOne","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nplot(-10:0.1:10, OuyangModelOne())","category":"page"},{"location":"NQCModels/analyticmodels/#[DoubleWell](@ref)","page":"Analytic model library","title":"DoubleWell","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nplot(-5:0.1:5, DoubleWell(); coupling=true)","category":"page"},{"location":"NQCModels/analyticmodels/#[GatesHollowayElbow](@ref)","page":"Analytic model library","title":"GatesHollowayElbow","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\n\nmodel = GatesHollowayElbow()\nv1(x,z) = potential(model, [x z])[1,1]\nv2(x,z) = potential(model, [x z])[2,2]\n\nx = range(-0.5, 4.0, length=200)\nz = range(-0.5, 4.0, length=200)\n\ncontour(x, z, v1, color=:blue, levels=0:0.01:0.1, label=\"V11\", colorbar=false)\ncontour!(x, z, v2, color=:red, levels=0:0.01:0.1, label=\"V22\")","category":"page"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"NQCModels/analyticmodels/#[ErpenbeckThoss](@ref)","page":"Analytic model library","title":"ErpenbeckThoss","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\n\nmodel = ErpenbeckThoss(;Γ=0.01)\nε₀(r) = potential(model, hcat(r))[1,1]\nε₁(r) = potential(model, hcat(r))[2,2]\nVₖ(r) = potential(model, hcat(r))[1,2]\n\nr = range(1.89, 9.45, length=200)\n\nplot(r, [ε₀, ε₁, Vₖ], label=[\"ε₀(r)\" \"ε₁(r)\" \"Vₖ(r)\"], xlabel=\"r (a₀)\", ylabel=\"V(r) (Eₕ)\"; coupling=true)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@info \"Expanding src/index.md...\"\nstart_time = time()","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the documentation for NQCDynamics,  a package for performing nonadiabatic molecular dynamics simulations. The documentation covers both how to use the existing code and describes the intricacies of the implementations, hoping to make further contributions as simple as possible.","category":"page"},{"location":"#Objectives","page":"Introduction","title":"Objectives","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Achieve high performance along with good readability, extensibility, maintainability\nHandle both simple models and high-dimensional systems\nHighlight the advantages of Julia in the field of nonadiabatic dynamics\nEncourage code sharing and reuse within the nonadiabatic dynamics community","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Reproducibility is a pressing issue in the field of theoretical chemistry and physics as often studies either do not attempt to provide all necessary data or code for full reproducibility of the work. This can lead to difficulties when attempting to better understand the theory and implementation of the method and makes it difficult for students not only to learn existing models and theories, but also to improve and extend these.  This project provides implementations for existing dynamics methods along with a framework that can be used for future research with the goal of encouraging greater code sharing and reuse within the nonadiabatic dynamics community.","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Here we provide a list of currently implemented features of the code. We encourage contributions and implementations of methods. To do so, please open up an issue/pull request on Github!","category":"page"},{"location":"#Dynamics-methods","page":"Introduction","title":"Dynamics methods","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Classical molecular dynamics\nClassical Langevin dynamics\nFewest-switches surface hopping (FSSH)\nMolecular dynamics with electronic friction (MDEF)\nRing polymer molecular dynamics (RPMD)\nNonadiabatic ring polymer molecular dynamics (NRPMD)\nRing polymer surface hopping (RPSH)\nEhrenfest molecular dynamics","category":"page"},{"location":"#Generating-initial-conditions","page":"Introduction","title":"Generating initial conditions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Thermal Metropolis-Hastings Monte Carlo\nThermal Hamiltonian Monte Carlo\nLangevin dynamics\nSemiclassical EBK quantisation","category":"page"},{"location":"#Dynamics-with-DifferentialEquations.jl","page":"Introduction","title":"Dynamics with DifferentialEquations.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The DifferentialEquations ecosystem from the SciML organisation provides a large library of integration algorithms along with a simple interface for implementing new algorithms that can be tailored for specific nonadiabatic dynamics methods. Further, they provide helpful utilities for introducing discontinuities through the  callback interface or handling many trajectories at once to obtain ensemble averaged observables with the ensemble interface. We can take advantage of these utilities by basing our dynamics setup on this framework which significantly simplifies the implementation of new methods.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#1.-Install-Julia","page":"Introduction","title":"1. Install Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Download and install the current stable release from the Julia website. For most platforms julia is provided as a precompiled binary and do not require any installation procedure. However, you need to specify the path to julia or create a symbolic link to the executable that is in your systempath. ","category":"page"},{"location":"#2.-Install-the-NQCRegistry","page":"Introduction","title":"2. Install the NQCRegistry","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Since the package is not included in the default registry (General), we must first install the NQCRegistry. This gives access to the core NQCDynamics package along with some dependencies and add-ons. First, enter the Julia REPL by executing julia from the command line. Then press ] to enter pkg mode. The prompt should change from julia> to pkg>. Install the registry directly from Github with: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> registry add \"https://github.com/NQCD/NQCRegistry\"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nIf this is the first time you're using Julia there's a chance that the General registry will not have been installed. Run pkg> registry status to view the installed registries. If General is not present, run pkg> registry add General before proceeding to the next step.","category":"page"},{"location":"#3.-Install-the-package","page":"Introduction","title":"3. Install the package","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Now that the registry has been added, the package can be installed in the same way as any other registered Julia package:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add NQCDynamics","category":"page"},{"location":"#4.-Use-the-package!","page":"Introduction","title":"4. Use the package!","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using NQCDynamics","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You are now free to proceed to the next section and learn how to use the package. If you would like you can complete step 5 to double check your installation.","category":"page"},{"location":"#5.-Run-the-tests-(optional)","page":"Introduction","title":"5. Run the tests (optional)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To check the package has been installed correctly and everything is working, you can execute the tests with:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> test NQCDynamics","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nThe tests use some extra functionality from the JuliaMolSim registry which can be added directly from Github with pkg> registry add \"https://github.com/JuliaMolSim/MolSim\". Without this, the tests will not run successfully.","category":"page"},{"location":"#How-to-use-this-documentation","page":"Introduction","title":"How to use this documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The first page to read is the Getting started section which walks through all the ingredients needed to perform a conventional classical molecular dynamics simulation. After this, the reader is free to explore at their leisure since everything else builds directly upon sections from the Getting started page.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"@info \"Expanding src/dynamicssimulations/dynamicsmethods/rpsh.md...\"\nstart_time = time()","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/#rpsh-dynamics","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"Ring polymer surface hopping was one of the early attempts to extend RPMD to the realm of nonadiabatic dynamics [17]. On the surface, the concept is reasonably simple. Since RPMD proceeds on a single adiabatic surface, it should be possible to directly combine the FSSH scheme with ring polymer dynamics to approximately include nuclear quantum effects in the surface hopping dynamics. However, there are some ambiguities surrounding the exact implementation when considering how to couple the electronic equations to the nuclear equations and how the velocity rescaling should be implemented.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"Originally, two varieties were proposed: the bead approximation and the centroid approximation. The centroid approximation is the simpler of the two and involves directly replacing the classical particle in the FSSH algorithm with the ring polymer centroid. This means that the nonadiabatic couplings evaluated at the centroid and the centroid velocity are used to propagate the electronic equations, and the kinetic energy is conserved on the centroid level. This is the version that is implemented here.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"The bead approximation involves evaluating the nonadiabatic couplings for every bead and using these contributions from every bead to propagate the electronics. This version acts to conserve the kinetic energy for the entire ring polymer. [17] describes both the centroid and bead approximations, [18] uses the centroid approximation.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/#Example","page":"Ring polymer surface hopping (RPSH)","title":"Example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"In this example we can apply RPSH to the ThreeStateMorse model as shown in the supporting info of [18]. This model has a single particle with mass of 20000 a.u. and we use 4 beads for the ring polymer.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"using NQCDynamics\nusing Unitful\n\natoms = Atoms(20000)\nmodel = ThreeStateMorse()\nsim = RingPolymerSimulation{FSSH}(atoms, model, 4; temperature=300u\"K\")\nnothing # hide","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"For our initial conditions let's use a position distribution centred at 2.1 a.u. with Boltzmann velocities at 300 K.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"using Distributions: Normal\n\nposition = Normal(2.1, 1 / sqrt(20000 * 0.005))\nvelocity = VelocityBoltzmann(300u\"K\" * nbeads(sim), masses(sim), (1,1))\ndistribution = DynamicalDistribution(velocity, position, size(sim)) * PureState(1)\nnothing # hide","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"Now let's run an ensemble of trajectories that sample from this distribution. For the output we will receive the diabatic population at intervals of t=50 and it will be averaged over all trajectories by the :mean keyword.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"solution = run_dynamics(sim, (0.0, 3000.0), distribution;\n    saveat=50, trajectories=50, dt=1,\n    output=TimeCorrelationFunctions.PopulationCorrelationFunction(sim, Diabatic()),\n    reduction=MeanReduction())","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"note: Note\nIn the examples section at the end of the documentation we will return to this model and compare the performance of multiple methods.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"Here we plot diabatic population of each state as a function of time. The result closely resembles the literature reference ([18]). The small discrepancy that occurs at around t=2000 is due to our use of an alternative method to calculate the diabatic populations. A discussion on this topic is available from [19].","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"using Plots\n\nplot(0:50:3000, [p[1,1] for p in solution[:PopulationCorrelationFunction]], label=\"State 1\")\nplot!(0:50:3000, [p[1,2] for p in solution[:PopulationCorrelationFunction]], label=\"State 2\")\nplot!(0:50:3000, [p[1,3] for p in solution[:PopulationCorrelationFunction]], label=\"State 3\")\nxlabel!(\"Time /a.u.\")\nylabel!(\"Population\")","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"For our simulation we are using a Normal distribution to initialise our ring polymer configuration. Since ring polymer surface hopping has not been rigorously derived, this choice is somewhat arbitrary and it is possible that better results could be achieved using a free ring polymer distribution instead. [20] provides a theoretical description of how nonequilibrium simulations using RPMD should be performed. This techniques here should likely be applied to RPSH too.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"references/","page":"References","title":"References","text":"@info \"Expanding src/references.md...\"\nstart_time = time()","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"J. C. Tully. Molecular dynamics with electronic transitions. The Journal of Chemical Physics 93, 1061–1071 (1990), arXiv:https://doi.org/10.1063/1.459170.\n\n\n\nN. Gerrits, J. I. Juaristi and J. Meyer. Electronic friction coefficients from the atom-in-jellium model for Z=1--92. Phys. Rev. B 102, 155130 (2020).\n\n\n\nC. L. Box, Y. Zhang, R. Yin, B. Jiang and R. J. Maurer. Determining the Effect of Hot Electron Dissipation on Molecular Scattering Experiments at Metal Surfaces. JACS Au 1, 164–173 (2021), arXiv: https://doi.org/10.1021/jacsau.0c00066.\n\n\n\nA. J. Larkoski, D. G. Ellis and L. J. Curtis. Numerical implementation of Einstein-Brillouin-Keller quantization for arbitrary potentials. American Journal of Physics 74, 572–577 (2006), arXiv:https://doi.org/10.1119/1.2192788.\n\n\n\nN. Ananth, C. Venkataraman and W. H. Miller. Semiclassical description of electronically nonadiabatic dynamics via the initial value representation. The Journal of Chemical Physics 127, 1–10 (2007), arXiv:  https://doi.org/10.1063/1.2759932.\n\n\n\nJ. E. Subotnik, A. Jain, B. Landry, A. Petit, W. Ouyang and N. Bellonzi. Understanding the Surface Hopping View of Electronic Transitions and Decoherence. Annual Review of Physical Chemistry 67, 387–417 (2016), arXiv:https://doi.org/10.1146/annurev-physchem-040215-112245. PMID: 27215818.\n\n\n\nB. Leimkuhler and C. Matthews. Rational Construction of Stochastic Numerical Methods for Molecular Sampling. Applied Mathematics Research eXpress 2013, 34–56 (2012), arXiv:https://academic.oup.com/amrx/article-pdf/2013/1/34/397230/abs010.pdf.\n\n\n\nH. Risken and H. Haken. The Fokker-Planck Equation: Methods of Solution and Applications Second Edition (Springer, 1989).\n\n\n\nJ. O. Richardson and M. Thoss. Communication: Nonadiabatic ring-polymer molecular dynamics. The Journal of Chemical Physics 139, 031102 (2013), arXiv:https://doi.org/10.1063/1.4816124.\n\n\n\nJ. O. Richardson, P. Meyer, M.-O. Pleinert and M. Thoss. An analysis of nonadiabatic ring-polymer molecular dynamics and its application to vibronic spectra. Chemical Physics 482, 124–134 (2017). Electrons and nuclei in motion - correlation and dynamics in molecules (on the occasion of the 70th birthday of Lorenz S. Cederbaum).\n\n\n\nS. N. Chowdhury and P. Huo. State dependent ring polymer molecular dynamics for investigating excited nonadiabatic dynamics. The Journal of Chemical Physics 150, 244102 (2019), arXiv:https://doi.org/10.1063/1.5096276.\n\n\n\nS. N. Chowdhury and P. Huo. Non-adiabatic Matsubara dynamics and non-adiabatic ring-polymer molecular dynamics. The Journal of Chemical Physics 154, 124124 (2021), arXiv:https://doi.org/10.1063/5.0042136.\n\n\n\nM. S. Church, T. J. Hele, G. S. Ezra and N. Ananth. Nonadiabatic semiclassical dynamics in the mixed quantum-classical initial value representation. The Journal of Chemical Physics 148, 102326 (2018), arXiv:https://doi.org/10.1063/1.5005557.\n\n\n\nR. Korol, N. Bou-Rabee and T. F. Miller. Cayley modification for strongly stable path-integral and ring-polymer           molecular dynamics. The Journal of Chemical Physics 151, 124103 (2019), arXiv:https://doi.org/10.1063/1.5120282.\n\n\n\nI. R. Craig and D. E. Manolopoulos. Quantum statistics and classical mechanics: Real time correlation functions from ring polymer molecular dynamics. The Journal of Chemical Physics 121, 3368–3373 (2004), arXiv:https://doi.org/10.1063/1.1777575.\n\n\n\nM. Tuckerman. Statistical Mechanics: Theory and Molecular Simulation (Oxford University Press, 2010).\n\n\n\nP. Shushkov, R. Li and J. C. Tully. Ring polymer molecular dynamics with surface hopping. The Journal of Chemical Physics 137, 22A549 (2012), arXiv:https://doi.org/10.1063/1.4766449.\n\n\n\nF. A. Shakib and P. Huo. Ring Polymer Surface Hopping: Incorporating Nuclear Quantum Effects into Nonadiabatic Molecular Dynamics Simulations. The Journal of Physical Chemistry Letters 8, 3073–3080 (2017), arXiv:https://doi.org/10.1021/acs.jpclett.7b01343. PMID: 28629220.\n\n\n\nB. R. Landry, M. J. Falk and J. E. Subotnik. Communication: The Correct Interpretation of Surface Hopping Trajectories: How to Calculate Electronic Properties. The Journal of Chemical Physics 139, 211101 (2013).\n\n\n\nR. Welsch, K. Song, Q. Shi, S. C. Althorpe and T. F. Miller. Non-equilibrium dynamics from RPMD and CMD. The Journal of Chemical Physics 145, 204118 (2016), arXiv: https://doi.org/10.1063/1.4967958.\n\n\n\nR. Scholz, S. Lindner, I. Lončarić, J. C. Tremblay, J. I. Juaristi, M. Alducin and P. Saalfrank. Vibrational Response and Motion of Carbon Monoxide on Cu(100) Driven by Femtosecond Laser Pulses: Molecular Dynamics with Electronic Friction. Phys. Rev. B 100, 245431 (2019).\n\n\n\nY. Zhang, R. J. Maurer, H. Guo and B. Jiang. Hot-electron effects during reactive scattering of H2 from Ag(111): the interplay between mode-specific electronic friction and the potential energy landscape. Chem. Sci. 10, 1089–1097 (2019).\n\n\n\nX. Gao, M. A. Saller, Y. Liu, A. Kelly, J. O. Richardson and E. Geva. Benchmarking Quasiclassical Mapping Hamiltonian Methods for Simulating Electronically Nonadiabatic Molecular Dynamics. Journal of Chemical Theory and Computation, acs.jctc.9b01267 (2020).\n\n\n\nE. A. Coronado, J. Xing and W. H. Miller. Ultrafast non-adiabatic dynamics of systems with multiple surface crossings: a test of the Meyer–Miller Hamiltonian with semiclassical initial value representation methods. Chemical Physics Letters 349, 521–529 (2001).\n\n\n\nR. Korol, J. L. Rosa-Raíces, N. Bou-Rabee and T. F. Miller. Dimension-free path-integral molecular dynamics without preconditioning. The Journal of Chemical Physics 152, 104102 (2020), arXiv:https://doi.org/10.1063/1.5134810.\n\n\n\nX. He, Z. Gong, B. Wu and J. Liu. Negative Zero-Point-Energy Parameter in the Meyer–Miller Mapping Model for Nonadiabatic Dynamics. The Journal of Physical Chemistry Letters 12, 2496–2501 (2021), arXiv: https://doi.org/10.1021/acs.jpclett.1c00232. PMID: 33667108.\n\n\n\nX. He, B. Wu, Z. Gong and J. Liu. Commutator Matrix in Phase Space Mapping Models for Nonadiabatic Quantum Dynamics. The Journal of Physical Chemistry A 125, 6845–6863 (2021), arXiv: https://doi.org/10.1021/acs.jpca.1c04429. PMID: 34339600.\n\n\n\nS. Hammes‐Schiffer and J. C. Tully. Proton transfer in solution: Molecular dynamics with quantum transitions. The Journal of Chemical Physics 101, 4657–4667 (1994), arXiv: https://doi.org/10.1063/1.467455.\n\n\n\nW. L. Hase, R. J. Duchovic, X. Hu, A. Komornicki, K. F. Lim, D.-h. Lu, G. H. Peslherbe, K. N. Swamy, S. V. Linde, A. Varandas and others. VENUS96, A general chemical dynamics computer program. QCPE 16, 671 (1996).\n\n\n\n","category":"page"},{"location":"references/","page":"References","title":"References","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"@info \"Expanding src/examples/threestatemorse.md...\"\nstart_time = time()","category":"page"},{"location":"examples/threestatemorse/#Time-dependent-populations-with-the-ThreeStateMorse-model","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"","category":"section"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"In this example we investigate the time-dependent populations of the three state morse model parametrised to describe photodissociation processes ([24]). This reference introduces three versions of this model with different parameter sets. Our ThreeStateMorse model matches model C from the reference.","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"First let's visualise the diabats and couplings for the model. You can see two regions where the diabats cross with non-zero coupling where we can expect to see population transfer.","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"using NQCDynamics\nusing Plots\n\nx = range(2, 12, length=200)\nmodel = ThreeStateMorse()\nV = potential.(model, x)\n\nplot(\n    xlabel=\"Nuclear coordinate /a.u.\",\n    ylabel=\"Potential energy /a.u.\",\n    legend=true,\n    xlims=(2, 12),\n    ylims=(0, 0.06)\n)\n\nplot!(x, [v[1,1] for v in V], label=\"State 1\")\nplot!(x, [v[2,2] for v in V], label=\"State 2\")\nplot!(x, [v[3,3] for v in V], label=\"State 3\")\n\nplot!(x, [v[1,2] for v in V], label=\"Coupling 12\")\nplot!(x, [v[2,3] for v in V], label=\"Coupling 23\")\nplot!(x, [v[1,3] for v in V], label=\"Coupling 13\")","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"To this model we can apply any of the methods capable of starting the population on a single diabatic state and returning the population as a function of time. Here, let's use FSSH and Ehrenfest. We can expect the nuclear quantum effects here to be minimal since the nuclear mass is chosen to be 20000. ","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"m = 20000\natoms = Atoms(m)\nnothing # hide","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"For our initial conditions, we use the Wigner distribution for a Harmonic oscillator centred at 2.1 with a frequency of 5e-3 at a temperature of 300 K. This distribution is chosen to mimic a thermal ground state distribution before photoexcitation.","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"using Distributions: Normal\nusing Unitful, UnitfulAtomic\n\nω = 5e-3\nβ = 1/austrip(300u\"K\")\nposition = PositionHarmonicWigner(ω, β, m; centre=2.1)\nvelocity = VelocityHarmonicWigner(ω, β, m)\ndistribution = DynamicalDistribution(velocity, position, (1,1)) * PureState(1)\nnothing # hide","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"Now let's run the two simulations using Ehrenfest and FSSH. For both simulations we use the same initial distribution and average the results using reduction=:mean. TimeCorrelationFunctions.PopulationCorrelationFunction will correlate the intial population with the final population at each timestep.","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"sim = Simulation{FSSH}(atoms, model)\nfssh_result = run_dynamics(sim, (0.0, 3000.0), distribution;\n    saveat=10, trajectories=50,\n    output=TimeCorrelationFunctions.PopulationCorrelationFunction(sim, Diabatic()),\n    reduction=MeanReduction(), dt=1.0)\nsim = Simulation{Ehrenfest}(atoms, model)\nehrenfest_result = run_dynamics(sim, (0.0, 3000.0), distribution;\n    saveat=10, trajectories=50,\n    output=TimeCorrelationFunctions.PopulationCorrelationFunction(sim, Diabatic()),\n    reduction=MeanReduction(), dt=1.0)\n\nplot(\n    xlabel=\"Time /a.u.\",\n    ylabel=\"Population\"\n)\n\nx = 0:10:3000\ny = [p[1,1] for p in fssh_result[:PopulationCorrelationFunction]]\nplot!(x, y, label=\"FSSH State 1\", color=:red)\ny = [p[1,2] for p in fssh_result[:PopulationCorrelationFunction]]\nplot!(x, y, label=\"FSSH State 2\", color=:green)\ny = [p[1,3] for p in fssh_result[:PopulationCorrelationFunction]]\nplot!(x, y, label=\"FSSH State 3\", color=:blue)\n\ny = [p[1,1] for p in ehrenfest_result[:PopulationCorrelationFunction]]\nplot!(x, y, label=\"Ehrenfest State 1\", color=:red, linestyle=:dash)\ny = [p[1,2] for p in ehrenfest_result[:PopulationCorrelationFunction]]\nplot!(x, y, label=\"Ehrenfest State 2\", color=:green, linestyle=:dash)\ny = [p[1,3] for p in ehrenfest_result[:PopulationCorrelationFunction]]\nplot!(x, y, label=\"Ehrenfest State 3\", color=:blue, linestyle=:dash)","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"To reduce the build time for the documentation the results here are underconverged but already it is clear that both of these methods come close to the exact result shown by [24]. After performing enough trajectories to converge the population dynamics, we would be better able to judge the effectiveness of FSSH and Ehrenfest at reproducing the exact quantum dynamics for this model.","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"@info \"Expanding src/devdocs/diffeq.md...\"\nstart_time = time()","category":"page"},{"location":"devdocs/diffeq/#DifferentialEquations.jl-integration","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"","category":"section"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"NQCDynamics.jl is built directly on top of the established DifferentialEquations.jl that provides a vast array of features. By using DifferentialEquations.jl to perform the dynamics, we can immediately exploit many of these features to save us a lot of work. This page details some of the features from DifferentialEquations.jl that we have used.","category":"page"},{"location":"devdocs/diffeq/#devdocs-callbacks","page":"DifferentialEquations.jl integration","title":"Callbacks","text":"","category":"section"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"Callbacks allow us to introduce extra code during the dynamics without needing to meddle with the integration code directly. On the developer side, [Callbacks] is the mechanism used for the saving in the run_dynamics function and the surface hopping procedure during FSSH. The user can also write their own callbacks and give these to any of the dynamics functions to manipulate the progress of the dynamics or introduce their own saving mechanism.","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"We also provide two pre-made callbacks which can be given to the dynamics functions. These are the TerminatingCallback, for terminating the simulation early, and the CellBoundaryCallback that can be used to ensure the atoms obey the periodicity of the simulation cell.","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"Here, we can show how these callbacks can be used in tandem to alter the course of the simulation. Let's look at a classical dynamics simulation without any extra callbacks:","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"using NQCDynamics\nusing Plots\n\natoms = Atoms(:C)\nmodel = NQCModels.Harmonic()\ncell = PeriodicCell(hcat(50))\nsim = Simulation(atoms, model; cell=cell)\n\nz = DynamicsVariables(sim, hcat(1.0), zeros(1,1))\n\nsolution = run_dynamics(sim, (0.0, 300), z; dt=1.0, output=OutputPosition)\nplot(solution, :OutputPosition, label=\"No callbacks\", legend=true)","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"Now we can introduce callbacks and observe the difference:","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"solution = run_dynamics(sim, (0.0, 300), z; callback=DynamicsUtils.CellBoundaryCallback(), dt=1.0, output=OutputPosition)\nplot!(solution, :OutputPosition, label=\"Cell boundary\" )\n\nusing DiffEqBase: CallbackSet\nterminate(u, t, integrator) = t > 100\ncallbacks = CallbackSet(DynamicsUtils.CellBoundaryCallback(), DynamicsUtils.TerminatingCallback(terminate))\nsolution = run_dynamics(sim, (0.0, 300), z; callback=callbacks, dt=1.0, output=OutputPosition)\nplot!(solution, :OutputPosition, label=\"Cell + termination\")","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"See how the callbacks have altered the dynamics? The atom no longer leaves the simulation cell, and the termination caused the simulation to exit early. ","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"The callback setup we're using is exactly that provided by DifferentialEquations.jl, if you want more details on callbacks, please refer to their documentation.","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/classical/","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"@info \"Expanding src/dynamicssimulations/dynamicsmethods/classical.md...\"\nstart_time = time()","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/classical/#classical-dynamics","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/classical/","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"Classical (molecular) dynamics proceeds by solving the dynamics for a system governed by a classical Hamiltonian containing the kinetic energy of the particles and a potential energy function:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/classical/","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"H = fracP^22M + V(R)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/classical/","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"To integrate the equations we use the VelocityVerlet() algorithm from DifferentialEquations.jl, which is one of the most widely used algorithms for molecular dynamics.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/classical/#Example","page":"Classical molecular dynamics","title":"Example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/classical/","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"We can create two particles with mass = 1 and attach a DiatomicHarmonic interaction which provides a harmonic interatomic potential.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/classical/","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"note: Note\nRecall that the constructor for Simulation(...) when called without a type parameter as below defaults to Simulation{Classical}(...).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/classical/","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"using NQCDynamics\nusing Plots\n\nsim = Simulation(Atoms([1, 1]), DiatomicHarmonic())\nv = rand(3, 2)\nu0 = DynamicsVariables(sim, zeros(3, 2), hcat(randn(3), randn(3).+1))\n\ntraj = run_dynamics(sim, (0.0, 10.0), u0; dt=0.1, output=OutputPosition)\n\nplot(traj, :OutputPosition)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/classical/","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCDynamics/ringpolymers/","page":"RingPolymers","title":"RingPolymers","text":"@info \"Expanding src/api/NQCDynamics/ringpolymers.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCDynamics/ringpolymers/#RingPolymers","page":"RingPolymers","title":"RingPolymers","text":"","category":"section"},{"location":"api/NQCDynamics/ringpolymers/","page":"RingPolymers","title":"RingPolymers","text":"Modules=[NQCDynamics.RingPolymers]","category":"page"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.RingPolymerParameters-Union{Tuple{T}, Tuple{Integer, Real, AbstractVector{Symbol}, Vector{Symbol}}} where T","page":"RingPolymers","title":"NQCDynamics.RingPolymers.RingPolymerParameters","text":"Constructor for choosing specific elements to be quantum.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.RingPolymerParameters-Union{Tuple{T}, Tuple{Integer, Real, Integer}} where T","page":"RingPolymers","title":"NQCDynamics.RingPolymers.RingPolymerParameters","text":"Constructor for the case where all nuclei are quantum.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.cayley_propagator-Union{Tuple{T}, Tuple{NQCDynamics.RingPolymers.RingPolymerParameters{T}, Real}} where T","page":"RingPolymers","title":"NQCDynamics.RingPolymers.cayley_propagator","text":"cayley_propagator(beads::RingPolymerParameters{T}, dt::Real; half::Bool=true) where {T}\n\nJ. Chem. Phys. 151, 124103 (2019); doi: 10.1063/1.5120282\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.get_spring_energy-Tuple{NQCDynamics.RingPolymers.RingPolymerParameters, Any, Any}","page":"RingPolymers","title":"NQCDynamics.RingPolymers.get_spring_energy","text":"get_spring_energy(beads::RingPolymerParameters, masses, R)\n\nCalculate the ring polymer spring potential.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.get_spring_matrix-Tuple{Integer, Real}","page":"RingPolymers","title":"NQCDynamics.RingPolymers.get_spring_matrix","text":"get_L(n_beads, mass, ω_n)\n\nReturn the Circulant symmetric matrix for the ring polymer springs.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ringpolymers/","page":"RingPolymers","title":"RingPolymers","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCDynamics/ensembles/","page":"Ensembles","title":"Ensembles","text":"@info \"Expanding src/api/NQCDynamics/ensembles.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCDynamics/ensembles/#Ensembles","page":"Ensembles","title":"Ensembles","text":"","category":"section"},{"location":"api/NQCDynamics/ensembles/","page":"Ensembles","title":"Ensembles","text":"Modules=[NQCDynamics.Ensembles]","category":"page"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles","page":"Ensembles","title":"NQCDynamics.Ensembles","text":"Ensembles\n\nThis module provides the main function run_dynamics. This serves to run multiple trajectories for a given simulation type, sampling from an initial distribution.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.EnsembleSaver","page":"Ensembles","title":"NQCDynamics.Ensembles.EnsembleSaver","text":"EnsembleSaver{F<:Tuple}\n\nStore a tuple of functions with the signature f(sol) where sol is a DiffEq solution object. EnsembleSaver will evaluate each of these functions and return the result in a Dictionary.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.MeanReduction","page":"Ensembles","title":"NQCDynamics.Ensembles.MeanReduction","text":"Average the outputs over all trajectories.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.OrderedSelection","page":"Ensembles","title":"NQCDynamics.Ensembles.OrderedSelection","text":"Select the initial conditions from the distribution in order. \n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.RandomSelection","page":"Ensembles","title":"NQCDynamics.Ensembles.RandomSelection","text":"Obtain initial conditions by randomly sampling the distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.SumReduction","page":"Ensembles","title":"NQCDynamics.Ensembles.SumReduction","text":"Sum the outputs from each trajectory.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.run_dynamics-Tuple{NQCDynamics.AbstractSimulation, Any, Any}","page":"Ensembles","title":"NQCDynamics.Ensembles.run_dynamics","text":"run_dynamics(sim::AbstractSimulation, tspan, distribution;\n    output,\n    selection::Union{Nothing,AbstractVector}=nothing,\n    reduction=AppendReduction(),\n    ensemble_algorithm=SciMLBase.EnsembleSerial(),\n    algorithm=DynamicsMethods.select_algorithm(sim),\n    trajectories=1,\n    kwargs...\n    )\n\nRun trajectories for timespan tspan sampling from distribution.\n\nKeywords\n\noutput either a single function or a Tuple of functions with the signature f(sol, i) that takes the DifferentialEquations solution and returns the desired output quantity.\nselection should be an AbstractVector containing the indices to sample from the distribution. By default, nothing leads to random sampling.\nreduction defines how the data is reduced across trajectories. Options are AppendReduction(), MeanReduction(), SumReduction and FileReduction(filename).\nensemble_algorithm is the algorithm from DifferentialEquations which determines which form of parallelism is used.\nalgorithm is the algorithm used to integrate the equations of motion.\ntrajectories is the number of trajectories to perform.\nkwargs... any additional keywords are passed to DifferentialEquations solve`.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ensembles/","page":"Ensembles","title":"Ensembles","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"@info \"Expanding src/integration_algorithms.md...\"\nstart_time = time()","category":"page"},{"location":"integration_algorithms/#Integration-algorithms","page":"Integration algorithms","title":"Integration algorithms","text":"","category":"section"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"At the core of NQCDynamics.jl is the DifferentialEquations.jl package that performs all of the dynamics simulations. Within the sub-packages OrdinaryDiffEq.jl and StochasticDiffEq.jl, a variety of integration algorithms have been implemented that are available to use without needing to implement custom algorithms for specific applications.  However, in some cases it can be desirable to implement algorithms that can take advantage of the special structure of the dynamical system at hand. A key example in the field of molecular dynamics is the famous velocity Verlet algorithm that is extremely popular due to its requirement for only a single force evaluation during each time step and symplectic energy conservation properties. In fact, velocity Verlet, along with a variety of other symplectic solvers are also implemented within OrdinaryDiffEq.jl.","category":"page"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"For some problems encountered within semiclassical adiabatic and nonadiabatic dynamics, there are a few different algorithms that can be used to obtain improved performance. Ideally, these would be implemented using the DifferentialEquations.jl interface to allow for others to easily use these algorithms for their own problems. However, it can be challenging to implement algorithms with an appropriate level of generality. NQCDynamics.jl contains implementations for a few algorithms using the DifferentialEquations.jl interface but the implementations are not completely generic and are coupled to the rest of the package. In particular, the algorithms rely on specific formats for the dynamical arrays and use some functions that are not provided within the DEProblem. In future it would be great to try to decouple the algorithms and package them separately within the DifferentialEquations.jl ecosystem so that others can use them more easily.","category":"page"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"This page describes a few applications where special algorithms are available to enhance performance. In each section it is noted which algorithms are available within NQCDynamics.jl.","category":"page"},{"location":"integration_algorithms/#Ring-polymer-propagation","page":"Integration algorithms","title":"Ring polymer propagation","text":"","category":"section"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"Path integral molecular dynamics and ring polymer molecular dynamics involve solving Hamilton's equations for a classical ring polymer Hamiltonian. The ring polymer Hamiltonian describes many replicas of the system joined together by harmonic springs. The number of replicas or beads required must be increased until convergence is achieved. After adding many beads the ring polymer dynamics becomes hard to integrate, as the ring polymer internal modes become the highest frequency modes in the system, limiting the largest acceptable time step.","category":"page"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"To circumvent this difficulty, the ring polymer equations of motion can be partitioned to separate the free ring polymer dynamics from the influence of the external potential. Since the free ring polymer dynamics is entirely harmonic, it is possible to solve this part analytically, allowing for time steps that are not limited by the internal ring polymer frequencies. Recently, the symplectic Cayley modified algorithm has been demonstrated to exhibit strong stability and outperform the original algorithm.","category":"page"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"note: Note\nThe Cayley modified algorithm was originally introduced by [14]. This paper provides a detailed description of ring polymer dynamics, how the integration algorithm works,  and benchmarks the performance of the algorithms. ","category":"page"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"The Hamiltonian ring polymer integration algorithm has also been extended for thermostatted dynamics: such as for thermal sampling in path integral molecular dynamics, or in thermostatted ring polymer molecular dynamics. As an extension to the Cayley modified algorithm for the Hamiltonian dynamics, the work of [25] suggests the BCOCB algorithm as the most effective for ring polymer dynamics with Langevin thermostatting. The BCOCB nomenclature refers to the sub-steps within each time step. B is the external potential, C is the Cayley modified free ring polymer step, and O is the thermostat. In this nomenclature, the integration algorithm in the absence of the thermostat can be referred to as the BCB algorithm.","category":"page"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"tip: Tip\nNQCDynamics.jl implements both the BCOCB and BCB algorithms for Langevin and Hamiltonian dynamics, respectively. They are the default algorithms when performing adiabatic ring polymer dynamics.","category":"page"},{"location":"integration_algorithms/#Mixed-quantum-classical-propagation","page":"Integration algorithms","title":"Mixed quantum-classical propagation","text":"","category":"section"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"Mixed quantum-classical methods such as mean-field Ehrenfest dynamics or surface hopping dynamics involve simultaneous propagation of nuclear and electronic sub-systems. The two sub-systems evolve on different timescales and it can be advantageous to use different time steps or algorithms for each part. Commonly the nuclear part is solved using the velocity Verlet algorithm and the electronic part is handled using a Runge-Kutta method or an exponential integrator.","category":"page"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"note: Note\nSHARC and Newton-X, two popular surface hopping codes, use the split-algorithm approach. In SHARC, the nuclear degrees of freedom are propagated using the velocity Verlet algorithm, whilst the wavefunction is propagated using an exponential integrator with a smaller time step.  Since an exponential integrator is exact when the propagation operator is constant, reducing the time step would have no benefit if the nuclei remained fixed during the time step. SHARC instead linearly interpolates the propagation operator during the electronic steps so that the nuclei propagation operator changes smoothly during the nuclear time step. This procedure is explained in the SHARC manual. Newton-X allows a few choices for the wavefunction integration algorithm and the nuclear quantities are interpolated similarly to SHARC.","category":"page"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"NQCDynamics.jl uses the standard library of OrdinaryDiffEq.jl solvers to run the dynamics for mixed quantum-classical methods. For model Hamiltonians where the evaluation of the electronic quantities is fast it is not necessary to use an augmented Verlet algorithm, instead it is sufficient to use any of the adaptive solvers from OrdinaryDiffEq.jl. However, in future it would be useful to implement some of these partioned algorithms that are able to achieve enhanced performance for large, expensive systems.","category":"page"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"For ring polymer mixed quantum-classical methods, it is possible to combine the algorithms used for ring polymer propagation with the partitioning idea from the mixed quantum-classical solvers. Even for model systems, the performance is significantly improved when the ring polymer modes are solved separately such that larger time steps can be used. NQCDynamics.jl implements an augmented form of the BCB algorithm that uses the BCB algorithm for the ring polymer degrees of freedom and uses the Tsit5 algorithm from OrdinaryDiffEq.jl for the electronic part. Currently the time steps for both sub-systems are fixed to be the same, but in future this constraint should be removed. In fact, it would even be possible to use an adaptive solver for the electronic part that can automatically adjust the time step as necessary.","category":"page"},{"location":"integration_algorithms/#Semiclassical-mapping-variable-propagation","page":"Integration algorithms","title":"Semiclassical mapping variable propagation","text":"","category":"section"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"Mapping variable methods describe the coupled nuclear-electronic problem using a classical Hamiltonian, where additional variables have been introduced to represent the electronic populations. As is the case with the ring polymer methods, it is possible to construct symplectic algorithms where each timestep is partitioned into exactly soluble sub-steps. Of particular note is the MInt algorithm described by [13]. The algorithm is symplectic, symmetric and time-reversible and can also be combined with the ring polymer algorithms for ring polymer dynamics with mapping variables. NQCDynamics.jl implements the MInt algorithm and a variant of the MInt algorithm for ring polymer systems that combines the BCB algorithm for the nuclei with the MInt algorithm for the mapping variables.","category":"page"},{"location":"integration_algorithms/#Electronic-friction-propagation","page":"Integration algorithms","title":"Electronic friction propagation","text":"","category":"section"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"Molecular dynamics with electronic friction is described by Langevin equations of motion, equivalent to classical Hamiltonian dynamics with an additional drag force and stochastic force. In the case of Langevin dynamics with a constant friction coefficient, there has been much interest in developing algorithms of low order that can be used for large molecular dynamics simulations. The work of [7] has demonstrated that, although a few choices exist, the BAOAB algorithm performs most favourably.","category":"page"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"tip: Tip\nThe BAOAB algorithm uses the same nomenclature as the ring polymer algorithms introduced in Ring polymer propagation. Each letter represents one component of a single time step. B is the external force step that updates the velocities, A is the position update, and O is the thermostatting step. For ring polymer dynamics the A step encompasses the free ring polymer step.","category":"page"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"For electronic friction dynamics, the friction is described by a tensor, not a single number as for traditional Langevin dynamics. However, the BAOAB algorithm is still applicable, but the O step requires the matrix exponential of the friction tensor. Since the tensor is positive semi-definite, it is possible to perform the exponentiation by first diagonalising the tensor. Using this approach, NQCDynamics.jl implements the BAOAB algorithm for tensorial friction and the BCOCB when using a ring polymer system. ","category":"page"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"note: Note\nThe DynamicalSDEProblem in StochasticDiffEq.jl represents systems that contain positions and velocities and have a stochastic component. The DynamicalSDEProblem was originally implemented for performing Langevin thermostatted dynamics simulations using the BAOAB algorithm. At the time of writing, BAOAB is the only algorithm implemented in StochasticDiffEq.jl for these problems. In future it would be useful to implement further algorithms and allow for more general noise profiles.","category":"page"},{"location":"integration_algorithms/","page":"Integration algorithms","title":"Integration algorithms","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCDistributions/nqcdistributions/","page":"NQCDistributions","title":"NQCDistributions","text":"@info \"Expanding src/api/NQCDistributions/nqcdistributions.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions","page":"NQCDistributions","title":"NQCDistributions","text":"","category":"section"},{"location":"api/NQCDistributions/nqcdistributions/","page":"NQCDistributions","title":"NQCDistributions","text":"Modules=[NQCDistributions]","category":"page"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.Adiabatic","page":"NQCDistributions","title":"NQCDistributions.Adiabatic","text":"Singleton type for labelling states as adiabatic.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.ConfigurationVector","page":"NQCDistributions","title":"NQCDistributions.ConfigurationVector","text":"ConfigurationVector{S<:AbstractVector}\n\nSample from a provided vector of configurations.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.Diabatic","page":"NQCDistributions","title":"NQCDistributions.Diabatic","text":"Singleton type for labelling states as diabatic.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.DynamicalDistribution","page":"NQCDistributions","title":"NQCDistributions.DynamicalDistribution","text":"DynamicalDistribution(velocity, position, dims)\n\nSampleable struct containing distributions for velocity and position. dims determines the size of each sample and should match the size of the system: (ndofs, natoms).\n\nExample\n\njulia> using NQCDistributions: DynamicalDistribution;\n\njulia> d = DynamicalDistribution([[1.0;;], [2.0;;], [3.0;;]], 0.1, (1, 1));\n\njulia> rand(d)\nComponentVector{Float64}(v = [1.0;;], r = [0.1;;])\n\njulia> d[2]\nComponentVector{Float64}(v = [2.0;;], r = [0.1;;])\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.ElectronicDistribution","page":"NQCDistributions","title":"NQCDistributions.ElectronicDistribution","text":"ElectronicDistribution{S}\n\nAbstract type for distributions of electronic degrees of freedom only.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.FermiDiracState","page":"NQCDistributions","title":"NQCDistributions.FermiDiracState","text":"FermiDiracState{S,T,A} <: ElectronicDistribution{S}\n\nElectronic distribution for Fermions following Fermi-Dirac distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.FixedArray","page":"NQCDistributions","title":"NQCDistributions.FixedArray","text":"FixedArray{S<:AbstractArray}\n\nReturn the same configuration every time.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.FixedFill","page":"NQCDistributions","title":"NQCDistributions.FixedFill","text":"FixedFill{S<:Real}\n\nFill all degrees of freedom with the same value every time.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.MixedState","page":"NQCDistributions","title":"NQCDistributions.MixedState","text":"MixedState{T,S} <: ElectronicDistribution{S}\n\nElectronic distribution for representing a mixed state with non-zero population in multiple states.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.PositionHarmonicRingPolymer-Union{Tuple{T}, Tuple{Any, Any, Any, Tuple{Int64, Int64, Int64}}} where T","page":"NQCDistributions","title":"NQCDistributions.PositionHarmonicRingPolymer","text":"PositionHarmonicRingPolymer{T}(ω, β, m, dims::Dims{3}; centre=0, classical=Int[])\n\nRing polymer position distribution in a 1D harmonic potential\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.PureState","page":"NQCDistributions","title":"NQCDistributions.PureState","text":"PureState{S} <: ElectronicDistribution{S}\n\nElectronic distribution for representing a system confined to a single state.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.RingPolymerWrapper","page":"NQCDistributions","title":"NQCDistributions.RingPolymerWrapper","text":"RingPolymerWrapper{S}\n\nWrap other distributions to convert them to ring polymer distributions.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.SampleableComponent","page":"NQCDistributions","title":"NQCDistributions.SampleableComponent","text":"SampleableComponent(sampleable, dims)\n\nConverts a general sampleable that provides configurations into one of the component types defined below.  dims should be the size of the desired samples and must be consistent with the provided sampleable.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.UnivariateArray","page":"NQCDistributions","title":"NQCDistributions.UnivariateArray","text":"UnivariateArray{N,S<:Sampleable{Univariate}}\n\nFill each degree of freedom from a different Univariate distribution.\n\nThe size of the matrix of sampleables should match the system size.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.UnivariateFill","page":"NQCDistributions","title":"NQCDistributions.UnivariateFill","text":"UnivariateFill{S<:Sampleable{Univariate}}\n\nFill all degrees of freedom from single Univariate distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.MomentumHarmonicWigner-Tuple{Any, Any, Any}","page":"NQCDistributions","title":"NQCDistributions.MomentumHarmonicWigner","text":"MomentumHarmonicWigner(ω, β, m)\n\nWigner distribution in a 1D harmonic potential for the momentum\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.PositionHarmonicWigner-Tuple{Any, Any, Any}","page":"NQCDistributions","title":"NQCDistributions.PositionHarmonicWigner","text":"PositionHarmonicWigner(ω, β)\n\nWigner distribution in a 1D harmonic potential for the position\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.Q-Tuple{Any, Any}","page":"NQCDistributions","title":"NQCDistributions.Q","text":"Quantum corrector for the Wigner distribution\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.VelocityBoltzmann-Tuple{Number, AbstractVector{<:Number}, Tuple{Int64, Int64}}","page":"NQCDistributions","title":"NQCDistributions.VelocityBoltzmann","text":"VelocityBoltzmann(temperature::Number, masses::AbstractVector{<:Number}, dims::Dims{2};  center::AbstractMatrix{<:Number} = zeros(dims))\n\nGenerate a Boltzmann distribution of velocities for each degree of freedom.\n\nArguments\n\ntemperature - Atomic units or Unitful\nmasses - Vector of masses for each atom\ndims - (ndofs, natoms). natoms must equal length(masses)\ncenter - Vector of dimension ndofs that provides centre of mass velocity offset\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.VelocityBoltzmann-Tuple{Number, Number}","page":"NQCDistributions","title":"NQCDistributions.VelocityBoltzmann","text":"VelocityBoltzmann(temperature, mass; center = 0)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDistributions/nqcdistributions/#NQCDistributions.VelocityHarmonicWigner-Tuple{Any, Any, Any}","page":"NQCDistributions","title":"NQCDistributions.VelocityHarmonicWigner","text":"VelocityHarmonicWigner(ω, β, m)\n\nWigner distribution in a 1D harmonic potential for the velocity\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDistributions/nqcdistributions/","page":"NQCDistributions","title":"NQCDistributions","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCDynamics/nonadiabaticmoleculardynamics/","page":"NQCDynamics","title":"NQCDynamics","text":"@info \"Expanding src/api/NQCDynamics/nonadiabaticmoleculardynamics.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCDynamics/nonadiabaticmoleculardynamics/#NQCDynamics","page":"NQCDynamics","title":"NQCDynamics","text":"","category":"section"},{"location":"api/NQCDynamics/nonadiabaticmoleculardynamics/","page":"NQCDynamics","title":"NQCDynamics","text":"Modules=[NQCDynamics]","category":"page"},{"location":"api/NQCDynamics/nonadiabaticmoleculardynamics/#NQCDynamics.Simulation-Union{Tuple{T}, Tuple{M}, Tuple{Atoms{T}, NQCModels.Model, M}} where {M, T}","page":"NQCDynamics","title":"NQCDynamics.Simulation","text":"Simulation(atoms::Atoms{T}, model::Model, method::M;\n    temperature=0u\"K\", cell::AbstractCell=InfiniteCell()) where {M,S,T}\n\nSimulation parameters that controls the types of atoms, interactions, dynamics method, temperature and simulation cell.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/nonadiabaticmoleculardynamics/#NQCDynamics.TemperatureSetting","page":"NQCDynamics","title":"NQCDynamics.TemperatureSetting","text":"A TemperatureSetting contains both temperature information and the atom indices within a Simulation that it is applied to. \n\nIf you don't need to apply different temperatures to different parts of your Simulation, assign the temperature keyword argument of your simulation to a number or function.\n\nParameters\n\nvalue: A temperature function. This can be a Number type for constant temperatures, or a function taking the time in Unitful u\"ps\" as input and giving a temperature in Unitful u\"K\" as output. \n\nindices: Indices of the atoms to which this thermostat is applied. Can be a range of indices, a single Int, or a Vector{Int}.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/nonadiabaticmoleculardynamics/#NQCDynamics.TemperatureSetting-Tuple{Any, Subsystem}","page":"NQCDynamics","title":"NQCDynamics.TemperatureSetting","text":"TemperatureSetting(temperature, subsystem::NQCModels.Subsystem)\n\nApply a TemperatureSetting to all atoms in a Subsystem. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/nonadiabaticmoleculardynamics/#NQCDistributions.VelocityBoltzmann-Tuple{Any, NQCDynamics.AbstractSimulation}","page":"NQCDynamics","title":"NQCDistributions.VelocityBoltzmann","text":"VelocityBoltzmann(temperature, sim::AbstractSimulation; center = zeros(size(sim)))\n\nGenerates a VelocityBoltzmann distribution covering an entire Simulation. If NQCModels.mobileatoms is modified, velocities for immobile atoms will always be zero.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/nonadiabaticmoleculardynamics/#NQCDynamics.get_temperature","page":"NQCDynamics","title":"NQCDynamics.get_temperature","text":"get_temperature(thermostats::Vector{<:TemperatureSetting}, t=0u\"fs\")\n\nGets the temperature from multiple TemperatureSettings and returns a vector of the temperature applied to each atom. \n\n\n\n\n\n","category":"function"},{"location":"api/NQCDynamics/nonadiabaticmoleculardynamics/","page":"NQCDynamics","title":"NQCDynamics","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"@info \"Expanding src/dynamicssimulations/dynamicsmethods/fssh.md...\"\nstart_time = time()","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/#fssh-dynamics","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Tully's FSSH [1] is one of the most popular methods for nonadiabatic molecular dynamics and is classified as a mixed-quantum classical method, where the nuclei are treated classically and the electrons are treated quantum mechanically.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"The central concept that governs surface hopping methods is that the nuclei evolve on a single adiabatic potential energy surface at any given moment. At each timestep, a hopping probability is evaluated. If the hopping probability is larger than a uniform random number between 0 and 1, the active state is switched and the adiabatic propagation continues on the new electronic state. When this algorithm is applied to an ensemble of trajectories, the discrete adiabatic state  populations approximate the quantum mechanical populations for each state.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"The surface hopping classical Hamiltonian can be written as","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"H(t) = frac12 mathbfP^T mathbfM^-1 mathbfP + sum_i delta(s(t) - i) E_i(mathbfR)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"where mathbfP is the vector of momenta, mathbfR the positions, and mathbfM the diagonal mass matrix. s(t) can be viewed as a digital signal that takes on the value of the currently occupied adiabatic state. As such, this Hamiltonian describes classical dynamics that proceeds under the influence of the potential E_i(mathbfR) when s(t) = i. The summation runs over all adiabatic states.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Of course, to integrate the associated equations of motion, s(t) must be obtained. This quantity is obtained stochastically for each trajectory by making probabilistic hops between surfaces. The probabilities are obtained by integrating the electronic Schrödinger equation alongside the dynamics as","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"ihbar dotc_i(t) = E_i(mathbfR) c_i (t)\n- ihbar sum_j dotmathbfR cdot mathbfd_ij(mathbfR)c_j(t)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"In this equation, c_i(t) are the complex coefficients for state i and mathbfd_ij is the nonadiabatic coupling between adiabatic states i and j. The hopping probability is calculated as","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"gamma_i to j = sum_alpha 2 fracP_alphaM_alpha\nRe(fracsigma_jisigma_ii) d_alpha ij dt","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"At each timestep, a random number between 0 and 1 is generated which is compared to the probabilities. If the probability is higher than the random number, then a hop is attempted.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Additionally in the fewest-switches scheme, the energy is conserved for each trajectory by rescaling the momenta whenever a hop is performed. As such, when a hop is attempted, it will only be successful when there is sufficient kinetic energy for the energy to be conserved after the hop. If there is insufficient kinetic energy, this is termed a frustrated hop, and the dynamics proceeds without performing a hop. When a hop is successful, the kinetic energy is adjusted and s(t) takes on the value of the newly occupied state. For a more detailed description of the algorithm and the momentum rescaling procedure, please refer to [6].  In this reference, the notion of reversing the momenta during frustrated hops is discussed. In our implementation we leave the frustrated trajectories unchanged, though it is suggested that the momentum reversal procedure may lead to better results in some cases.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/#Algorithm","page":"Fewest-switches surface hopping (FSSH)","title":"Algorithm","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Integrate classical dynamics for one timestep\nIntegrate electronic dynamics for one timestep\nEvaluate hopping probability\nPerform hop if sufficient probability and kinetic energy\nRescale velocity if hop is performed\nReturn to step 1","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"note: Note\nWith DifferentialEquations.jl we use a callback to perform the surface hopping procedure such that steps 1 and 2 are performed by the DifferentialEquations solvers and steps 3, 4, 5 are performed by the callback.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/#Example","page":"Fewest-switches surface hopping (FSSH)","title":"Example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"In this section we can investigate the results obtained for a single trajectory using FSSH.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"First, the simulation parameters are created. Here, we have a single atom with a mass of 2000 a.u. and we are using Tully's third model ([1]), provided by NQCModels.jl.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"using Random; Random.seed!(10) # hide\nusing NQCDynamics\n\natoms = Atoms(2000)\nsim = Simulation{FSSH}(atoms, TullyModelThree())","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"The DynamicsVariables constructor has some extra arguments for FSSH. The first three match the classical case, but we also provide the initial state and whether we want this state to be Adiabatic() or Diabatic(). The type of state can be important when considering the ordering of the states. The adiabatic states are always arranged from lowest to highest energy, whereas the diabatic states will be ordered as defined in the model. You can inspect the fields of u to ensure the initialisation has proceeded as you intend.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"u = DynamicsVariables(sim, [20/2000;;], [-10.;;], PureState(1, Adiabatic()))","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Finally, the trajectory can be run by passing all the parameters we have set up so far. Here, we request both the OutputDiscreteState output which is equal to s(t) and  OutputDiabaticPopulation, which gives us the population of each diabatic state along the trajectory.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"traj = run_dynamics(sim, (0.0, 2000.0), u, output=(OutputDiscreteState, OutputDiabaticPopulation))","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Now we can plot s(t) throughout the trajectory. The FSSH algorithm attempts to minimise the total number of hops; in the limit of infinite hops the result would tend to the mean-field (Ehrenfest) result, which is what FSSH attempts to avoid.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"using Plots\nplot(traj, :OutputDiscreteState)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Similarly, we can plot the diabatic populations. Since FSSH is performed in the adiabatic representation, even in the case of few hops, the diabatic populations can look dramatically different depending on the complexity of the model Hamiltonian. ","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"plot(traj, :OutputDiabaticPopulation)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Another example is available where we use FSSH and other methods to reproduce some of the results from [1].","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCModels/nonadiabaticmodels/","page":"NQCModels","title":"NQCModels","text":"@info \"Expanding src/api/NQCModels/nonadiabaticmodels.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels","page":"NQCModels","title":"NQCModels","text":"","category":"section"},{"location":"api/NQCModels/nonadiabaticmodels/","page":"NQCModels","title":"NQCModels","text":"Modules=[NQCModels]","category":"page"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.NQCModels","page":"NQCModels","title":"NQCModels.NQCModels","text":"NQCModels define the potentials and derivatives that govern the dynamics of the particles. These can exist as analytic models or as interfaces to other codes. \n\n\n\n\n\n","category":"module"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.CompositeModel","page":"NQCModels","title":"NQCModels.CompositeModel","text":"CompositeModel(Subsystems...)\n\nA CompositeModel is composed of multiple Subsystems, creating an effective model which evaluates each Subsystem for its respective indices. \n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.CompositeModel-Tuple{Vararg{Subsystem}}","page":"NQCModels","title":"NQCModels.CompositeModel","text":"CompositeModel(subsystems::Subsystem...)\n\nCombine multiple Subsystems into a single model to be handled by NQCDynamics.jl in simulations.  Any calls made to potential, derivative and friction will apply each subsystem's model to the respective atoms while ignoring any other atoms. \n\nSome checks are made to ensure each atom is affected by a model and that each model is applied over the same degrees of freedom, but no other sanity checks are made. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.Model","page":"NQCModels","title":"NQCModels.Model","text":"Top-level type for models.\n\nImplementation\n\nWhen adding new models, this should not be directly subtyped. Instead, depending on the intended functionality of the model, one of the child abstract types should be subtyped. If an appropriate type is not already available, a new abstract subtype should be created. \n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.Subsystem","page":"NQCModels","title":"NQCModels.Subsystem","text":"Subsystem(M, indices)\n\nA subsystem is a Model which only applies to a subset of the degrees of freedom of the original model. \n\nWhen combined in a CompositeModel, potential(), derivative!() and friction!() will be sourced from the respective Subsystems. \n\nCalling potential(), derivative!(), or friction!() on a subsystem directly will output the respective values for the entire system. \n\nThe Model specified will be supplied with the positions of the entire system for evaluation. \n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.check_models-Tuple{Vararg{Subsystem}}","page":"NQCModels","title":"NQCModels.check_models","text":"Subsystem combination logic - We only want to allow combination of subsystems:\n\n? 1. with the same number of degrees of freedom\n\nwithout overlapping indices (Build a different type of CompositeModel) to handle these cases separately. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.derivative!-Tuple{NQCModels.Model, Any, AbstractMatrix}","page":"NQCModels","title":"NQCModels.derivative!","text":"derivative!(model::Model, D, R::AbstractMatrix)\n\nFill D with the derivative of the electronic potential as a function of the positions R.\n\nThis must be implemented for all models.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.derivative-Tuple{NQCModels.Model, Any}","page":"NQCModels","title":"NQCModels.derivative","text":"derivative(model::Model, R)\n\nAllocating version of derivative!, this definition should be suitable for all models.\n\nImplement zero_derivative to allocate an appropriate array then implement derivative! to fill the array.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.ndofs-Tuple{NQCModels.Model}","page":"NQCModels","title":"NQCModels.ndofs","text":"ndofs(::Model)\n\nGet the number of degrees of freedom for every atom in the model. Usually 1 or 3.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.nstates-Tuple{NQCModels.Model}","page":"NQCModels","title":"NQCModels.nstates","text":"nstates(::Model)\n\nGet the number of electronic states in the model.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.potential!-Tuple{NQCModels.Model, Any, AbstractMatrix}","page":"NQCModels","title":"NQCModels.potential!","text":"potential!(model::Model, V, R::AbstractMatrix)\n\nIn-place version of potential, used only when mutable arrays are preferred.\n\nCurrently used only for LargeDiabaticModels, see diabatic/DiabaticModels.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.potential-Tuple{NQCModels.Model, AbstractMatrix}","page":"NQCModels","title":"NQCModels.potential","text":"potential(model::Model, R::AbstractMatrix)\n\nEvaluate the potential at position R for the given model.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.zero_derivative","page":"NQCModels","title":"NQCModels.zero_derivative","text":"zero_derivative(model::Model, R)\n\nCreate an zeroed array of the right size to match the derivative.\n\n\n\n\n\n","category":"function"},{"location":"api/NQCModels/nonadiabaticmodels/","page":"NQCModels","title":"NQCModels","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCDynamics/dynamicsutils/","page":"DynamicsUtils","title":"DynamicsUtils","text":"@info \"Expanding src/api/NQCDynamics/dynamicsutils.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCDynamics/dynamicsutils/#DynamicsUtils","page":"DynamicsUtils","title":"DynamicsUtils","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsutils/","page":"DynamicsUtils","title":"DynamicsUtils","text":"Modules=[NQCDynamics.DynamicsUtils]","category":"page"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils","text":"DynamicsUtils\n\nUtilities for dynamics simulations. Includes:\n\nBasic dynamics variables functions\nDensity matrix dynamics functions\nStandard callbacks to use during dynamics\nPlotting recipes for outputs\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.CellBoundaryCallback-Tuple{}","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils.CellBoundaryCallback","text":"CellBoundaryCallback()\n\nWhenever atoms leave the simulation cell, enforce the periodicity by wrapping the positions at the cell boundary.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.TerminateCellCallback-Tuple{}","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils.TerminateCellCallback","text":"TerminateCellCallback()\n\nIf the atoms leave the simulation cell, terminate the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.TerminatingCallback-Tuple{Any}","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils.TerminatingCallback","text":"TerminatingCallback(func)\n\nProvide a function that returns true when the simulation should terminate.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.apply_interbead_coupling!-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}, RingPolymerSimulation}} where T","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils.apply_interbead_coupling!","text":"apply_interbead_coupling!(du::DynamicalVariables, u::DynamicalVariables,\n                          sim::RingPolymerSimulation)\n\nApplies the force that arises from the harmonic springs between adjacent beads.\n\nOnly applies the force for atoms labelled as quantum within the RingPolymerParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.commutator!-Tuple{Any, Any, Any}","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils.commutator!","text":"commutator!(C, A, B)\n\nCalculate C = AB - BA.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.divide_by_mass!-Tuple{Any, Any}","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils.divide_by_mass!","text":"divide_by_mass!(dv, masses)\n\nDivide the contents of dv by the masses. Assumes dv is an array of size (dofs, atoms) or (dofs, atoms, beads). masses is the vector of masses for each atom that matches length with the second dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.velocity!-NTuple{5, Any}","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils.velocity!","text":"velocity!(dr, v, r, sim, t)\n\nWrite the velocity v into dr. Has extra arguments to work with Dynamical(O/S)DEProblems.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsutils/","page":"DynamicsUtils","title":"DynamicsUtils","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"@info \"Expanding src/dynamicssimulations/dynamicsmethods/nrpmd.md...\"\nstart_time = time()","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/#nrpmd-dynamics","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/#Theory","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Theory","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"Nonadiabatic ring polymer molecular dynamics (NRPMD) is a method that uses the ring polymer formalism to include quantum effects in the nuclear dynamics and mapping variables for the electronic degrees of freedom. ([9], [10], [11]) This results in a classical dynamics in an extended phasespace of the ring polymer with each bead coupled to a set of classical mapping variables. Originally, this method was proposed as a simple combination of the  Meyer-Miller-Stock-Thoss mapping formalism with RPMD but has since been rigorously derived from nonadiabatic Matsubara dynamics ([12]).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"The classical Hamiltonian conserved by NRPMD is given by","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"H_N = sum_alpha=1^N left\nfracP_alpha^22M + V_0(R_alpha)\n+ fracM2beta_N^2hbar^2 (R_alpha - R_alpha-1)^2\n+ frac1hbar sum_nmV_nm(R_alpha)\n(q_alpha_nq_alpha_m + p_alpha_np_alpha_m - delta_nmhbar)\nright","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"which contains N replicas with positions R_alpha and momenta P_alpha joined by harmonic springs. M is the mass, beta_N = beta  N is the inverse temperature scaled by the number of beads. V_0(R_alpha) is the state independent potential. V_nm are the matrix elements of the diabatic potential. The sum runs over all pairs of states. Each replica has a set of mapping variables q_alpha_n and p_alpha_n that interact only within the set associated with a single replica. The consequence of this is that the electronic dynamics is not contaminated by interbead  coupling.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"The equations of motion obtained from this Hamiltonian are","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"beginaligned\ndotR_alpha = fracP_alphaM\n\ndotP_alpha =\n- fracMbeta_N^2 hbar^2(2 R_alpha - R_alpha+1 - R_alpha-1)\n- nabla_R_alpha V_0(R_alpha)\n- frac12hbarsum_nm nabla_R_alpha V_nm(R_alpha)\n(q_alpha_nq_alpha_m + p_alpha_np_alpha_m - delta_nmhbar)\n\ndotq_alpha_n =\nfrac1hbar sum_m V_nm(R_alpha)p_alpha_m\n\ndotp_alpha_n =\n-frac1hbar sum_m V_nm(R_alpha)q_alpha_m\nendaligned","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/#Implementation-details","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Implementation details","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/#Solving-the-differential-equations","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Solving the differential equations","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"For mapping variable methods of this type, a symplectic algorithm ([13]) exists. This algorithm has the advantage of long time stability and can be easily combined with the standard algorithms for ring polymer time-evolution. For NRPMD we have implemented this algorithm using the Cayley modified ring polymer propagator ([14]) and obtain accurate and efficient dynamics. For few beads, similar performance to the OrdinaryDiffEq.jl algorithms is obtained, but as the number of beads increases this algorithm becomes more effective.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/#Generating-the-initial-distribution","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Generating the initial distribution","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"Currently, we provide this functionality only for nonequilibrium simulations where the nuclear part of the distribution is separable from the electronic part. Typically, the nuclear distribution will be sampled using Langevin dynamics or Monte Carlo sampling and the electronic variables are confined to a single electronic state. This is appropriate for modelling photoexcitation dynamics but is not yet suitable for equilibrium simulations. Equilibrium dynamics would require also sampling a thermal distribution for the mapping variables.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/#Form-of-the-Hamiltonian","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Form of the Hamiltonian","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"The diabatic models defined in NQCModels.jl are of the appropriate form for this method though they provide the potential as a single matrix, rather than separating the state-dependent and independent parts. It has been suggested that defining the Hamiltonian such that the lowest eigenvalue of the diabatic matrix is zero everywhere leads to improved convergence in the sampling ([9]). However, here we have not done this for simplicity when defining the models.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/#Example","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"Using NRPMD we can reproduce the Fig. 3a in the 2019 paper of Chowdhury and Huo ([11]).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"First we generate a thermal ring polymer distribution in a harmonic potential. A simple way to do this is to use Monte Carlo sampling for the positions and obtain velocities from a Boltzmann distribution.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"using NQCDynamics\n\natom = Atoms(1)\n\nsim = RingPolymerSimulation(atom, Harmonic(dofs=1), 4; temperature=1/16)\n\nr0 = zeros(size(sim))\nsteps = 5e3 # Number of Monte Carlo steps\nstep_size = Dict(:X=>1.0) # Monte Carlo step size for species :X\noutput = InitialConditions.ThermalMonteCarlo.run_advancedmh_sampling(sim, r0, steps, step_size)\nvelocities = VelocityBoltzmann(1/16, masses(sim), (1,1))\n\ndistribution = DynamicalDistribution(velocities, output, size(sim)) * PureState(1)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"note: `size(sim)`\nsize(sim) returns the system size as (degrees of freedom, number of atoms, number of beads).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"tip: Monte Carlo sampling\nFurther information on Monte Carlo sampling can be found here.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"We can check the distribution by plotting the phasespace diagram for each of the points in our distribution:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"using Plots\n\nnuclear = distribution.nuclear\nflat_position = reduce(vcat, (nuclear.position[i][:] for i in 1:length(nuclear)))\nflat_velocity = reduce(vcat, (rand(nuclear.velocity)[:] for _ in 1:length(nuclear)))\nscatter(flat_position, flat_velocity)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"note: `reduce(vcat, ...)`\nHere we have used reduce in combination with vcat to vertically concatenate all of the information into a single array for plotting.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"The simulation method is given as the type parameter {NRPMD} and the simulation constructor is given the atoms, model, number of beads, temperature and degrees of freedom.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"sim = RingPolymerSimulation{NRPMD}(atom, DoubleWell(γ=0.1), 4; temperature=1/16)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"Next, we can use this distribution as a starting point for the dynamics simulations. This will result in each trajectory starting from a random configuration in the distribution. For NRPMD, the electronic variables are sampled from a Gaussian, independent of the initial electronic state. The electronic state is introduced in the correlation function expression when correlating the initial and final populations.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"The quantities output by the ensemble simulation are specified by the output and the reduction. The output follows the DifferentialEquations format where we provide a function that determines the output of each trajectory. The reduction can be one of :mean, :append, or :sum, which will determine how the data from each trajectory is combined.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"note: Ensemble simulations\nFurther details on ensemble simulations are available here.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"output = TimeCorrelationFunctions.PopulationCorrelationFunction(sim, Diabatic())\nnothing # hide","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"Finally, we can combine the parameters and run the simulation. The resulting plot shows the time dependent population difference and closely matches the figure from the paper we were attempting to reproduce. Nice!","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"ensemble = run_dynamics(sim, (0.0, 30.0), distribution;\n    trajectories=100, output, reduction=MeanReduction(), dt=0.1)\n\nplot(0:0.1:30, [p[1,1]-p[2,1] for p in ensemble[:PopulationCorrelationFunction]])\nxlabel!(\"Time\")\nylabel!(\"Population difference\")","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"@info \"Expanding src/dynamicssimulations/dynamicsmethods/rpmd.md...\"\nstart_time = time()","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/#rpmd-dynamics","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"Ring polymer molecular dynamics is a quantum dynamics methods that attempts to approximate Kubo-transformed real-time correlation functions ([15]).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"The idea is to exploit the classical isomorphism that maps a quantum particle onto the extended phasespace of a classical ring polymer. It can be shown that the quantum partition function for a system can be manipulated such that it resembles the classical partition function of a system containing many replicas of the original particle joined to together with harmonic springs in a ring. In the limit of infinite beads or replicas in the ring polymer, the isomorphism becomes exact and it is possible to evaluate quantum expectation values by evaluating ensemble averages for the classical ring polymer system. This is referred to as the field of imaginary-time path integrals and the techniques used are Path Integral Monte Carlo (PIMC) and Path Integral Molecular Dynamics (PIMD) depending on whether molecular dynamics or Monte Carlo methods are used to explore the phasespace ([16]).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"RPMD was proposed as a heuristic extension of imaginary-time path integrals to evaluate real-time dynamical quantities. To perform RPMD, it is necessary to solve Hamilton's equations for the ring polymer Hamiltonian:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"H = sum_alpha^N frac12 mathbfP_alpha^T mathbfM mathbfP_alpha\n+ frac12 omega_N^2\n(mathbfR_alpha - mathbfR_alpha+1)^T\nmathbfM\n(mathbfR_alpha - mathbfR_alpha+1)\n+ V(mathbfR_alpha)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"where the ring polymer spring constant omega_N = 1  hbarbeta_N and beta_N = beta  N.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"When the initial distribution is taken as the thermal ring polymer distribution and this Hamiltonian is used to generate configurations at later times, the correlation functions obtained can be used to approximate real-time quantum correlation functions.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/#Example","page":"Ring polymer molecular dynamics (RPMD)","title":"Example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"Let us perform some simple adiabatic ring polymer dynamics to get a feel for what the ring polymer dynamics looks like.  We set up a 2D system for one hydrogen atom by giving the Free model 2 degrees of freedom and specify that the ring polymer should have 50 beads.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"using NQCDynamics\nusing Unitful\n\natoms = Atoms([:H])\nsim = RingPolymerSimulation(atoms, Free(2), 50; temperature=100u\"K\")","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"note: Atomic units\nRecall that the quantities are always in atomic units unless Unitful.jl has been used to specify alternative units. The temperature here has been specified using Kelvin.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"We initialise the simulation with zero velocity and a random distribution for the ring polymer bead positions. For a real RPMD simulation you will use the thermal ring polymer distribution obtained from a PIMC or Langevin simulation but here for simplicity we use a normally distributed configuration.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"u = DynamicsVariables(sim, zeros(size(sim)), randn(size(sim)))\nnothing # hide","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"tip: Tip\nTo learn how to work with the thermal ring polymer phase space, refer to the Storing and sampling distributions section.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"Now we can run the simulation, for which we use the time interval 0.0 to 500.0 and a time  step of dt = 2.5:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"dt = 2.5\ntraj = run_dynamics(sim, (0.0, 500.0), u; output=OutputPosition, dt=dt)\nnothing # hide","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"We can visualise this ring polymer trajectory with a 2D scatter plot that shows how the ring polymer evolves in time. Here, we have joined the adjacent beads together with lines, with the end and start beads joined with a different color. This animation shows the cyclic nature of the ring polymer, and how every bead is connected to its two neighbours.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"using Plots\n\nrs = traj[:OutputPosition]\n\ntimestamps = 1:length(traj[:OutputPosition])\n@gif for i in timestamps\n    xs = rs[i][1,1,:]\n    ys = rs[i][2,1,:]\n    close_loop_x = [rs[i][1,1,end], rs[i][1,1,begin]]\n    close_loop_y = [rs[i][2,1,end], rs[i][2,1,begin]]\n\n    plot(\n        xlims=(-3, 3),\n        ylims=(-3, 3),\n        legend=false\n    )\n\n    plot!(xs, ys, color=:black)\n    scatter!(xs, ys)\n    plot!(close_loop_x, close_loop_y)\nend","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"Since this package is focused on nonadiabatic dynamics, you won't see much adiabatic RPMD elsewhere in the documentation, but it's useful to understand how the original adiabatic version works before moving on to the nonadiabatic extensions.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"@info \"Expanding src/initialconditions/metropolishastings.md...\"\nstart_time = time()","category":"page"},{"location":"initialconditions/metropolishastings/#mhmc-sampling","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"","category":"section"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Metropolis-Hastings Monte Carlo is a popular method for sampling the canonical distribution for a molecular system. Our implementations uses AdvancedMH.jl from the Turing organisation.","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"For a classical Simulation, the algorithm involves proposing new configurations in a random walk starting from an initial configuration. These are accepted or rejected based upon the Metropolis-Hastings criteria. The result is a Markov chain that samples the canonical distribution.","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"!!! Legacy version","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Prior to the use of [`AdvancedMH.jl`](https://github.com/TuringLang/AdvancedMH.jl),\nan alternative version of the algorithm was implemented that works for both classical\nand ring polymer systems: `MetropolisHastings.run_monte_carlo_sampling(sim, R0, Δ, passes)`\n\nThis is currently still included in the code but should be regarded as deprecated and\nwill likely be removed/combined with the [`AdvancedMH.jl`](https://github.com/TuringLang/AdvancedMH.jl)\nversion.","category":"page"},{"location":"initialconditions/metropolishastings/#Example-1","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Example 1","text":"","category":"section"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"We can perform the sampling by setting up a classical simulation in the usual way and providing an appropriate initial configuration.","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"using NQCDynamics\nsim = Simulation(Atoms([:H, :H, :H, :H, :H]), Harmonic(); temperature=15)\nr0 = zeros(size(sim))","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Then we must also specify the total number of steps and the size of each step. These can be provided in a dictionary for each species to allow for different step sizes depending on the element in the simulation.","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"steps = 1e4\nstep_size = Dict(:H=>1)","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Now we can run the sampling. The extra keyword argument movement_ratio is used to specify the fraction of the system moved during each Monte Carlo step. If we attempt to move the entire system at once, we can expect a very low acceptance ratio, whereas is we move only a single atom, the sampling will take much longer. You will likely have to experiment with this parameter to achieve optimal sampling.","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"note: Note\nKeyword arguments relating to how much of the system to sample were recently changed. The existing move_ratio and internal_ratio arguments are no longer used. Instead, there are now two options to specify how much of the system to move:movement_ratio: Defines which fraction of the system to move. 1 moves the entire system. stop_ratio: Defines which fraction of the system not to move. 1 stops the entire system. movement_ratio_internal: Defines which proportion of ring polymer normal modes to perturb. 1 moves the entire system. stop_ratio_internal: Defines which proportion of ring polymer normal modes not to perturb. 1 stops the entire system. ","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"using NQCDynamics.InitialConditions: ThermalMonteCarlo\nchain = ThermalMonteCarlo.run_advancedmh_sampling(sim, r0, steps, step_size; movement_ratio=0.5)","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Now that our sampling is complete we can evaluate the potential energy expectation value. Here we use the @estimate macro which will evaluate the given function for every configuration inside chain and return the average. Here we can see that the energy we obtain closely matches that predicted by the equipartition theorem.","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Estimators.@estimate potential_energy(sim, chain)\nsim.temperature / 2 * 5","category":"page"},{"location":"initialconditions/metropolishastings/#Example-2","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Example 2","text":"","category":"section"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Here, we obtain a thermal distribution in a simple model system with some additional tweaks to  try and sample a larger configuration space.","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"using NQCDynamics\nusing Plots","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"First we set up the system in the usual way, here we're using an NO molecule with a harmonic interaction between the atoms. Notice that we use Unitful.jl to specify the temperature.","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"using Unitful\n\natoms = Atoms([:N, :O])\nmodel = DiatomicHarmonic(1.0)\n\nsim = Simulation{Classical}(atoms, model; temperature=300u\"K\")\nnothing # hide","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Then we have to specify the parameters for the Monte Carlo simulation and perform the sampling. Δ contains the step sizes for each of the species, R0 the initial geometry and samples the number of configurations we want to obtain. ","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"AdvancedMH.jl provides some additional options to control the sampling process. To (hopefully) include  a larger configuration space in the final results, we set a thinning of 10, meaning that we only keep   every 10th proposed configuration. In addition, we discard the first 100 samples, since our initial configuration might not  lie in the equilibrium. This is set with discard_initial.  Further explanations of the keyword arguments can be found in the AbstractMCMC.jl documentation.","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Δ = Dict(:N => 0.1, :O => 0.1)\nR0 = [1.0 0.0; 0.0 0.0; 0.0 0.0]\nsamples = 1000\noutput = InitialConditions.ThermalMonteCarlo.run_advancedmh_sampling(sim, R0, samples, Δ; movement_ratio=0.5, thinning=10, discard_initial=100)\nnothing # hide","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"We can calculate the distance between each atom and plot the bond length throughout the sampling.","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"using LinearAlgebra\nplot([norm(R[:,1] .- R[:,2]) for R in output])\nxlabel!(\"Step\") # hide\nylabel!(\"Bond length\") # hide","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"The result of this simulation seamlessly interfaces with the DynamicalDistribution presented in the previous section and output can be readily passed to provide the position distribution. The Monte Carlo sampling does not include velocities but these can be readily obtained from the Maxwell-Boltzmann distribution.","category":"page"},{"location":"initialconditions/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCDynamics/dynamicsoutputs/","page":"DynamicsOutputs","title":"DynamicsOutputs","text":"@info \"Expanding src/api/NQCDynamics/dynamicsoutputs.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCDynamics/dynamicsoutputs/#DynamicsOutputs","page":"DynamicsOutputs","title":"DynamicsOutputs","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsoutputs/","page":"DynamicsOutputs","title":"DynamicsOutputs","text":"Here are all the functions that you can specify in the output tuple when using run_dynamics. To add more, simply add a new function in the DynamicsOutputs module. ","category":"page"},{"location":"api/NQCDynamics/dynamicsoutputs/","page":"DynamicsOutputs","title":"DynamicsOutputs","text":"Modules=[NQCDynamics.DynamicsOutputs]\nPrivate=false","category":"page"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs","text":"DynamicsOutputs\n\nDefines a set of functions that can be used to calculate outputs for dynamics simulations.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputDesorptionAngle","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputDesorptionAngle","text":"Outputs the desorption angle in degrees (relative to the surface normal) if a desorption event is detected.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputDesorptionAngle-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputDesorptionAngle","text":"(output::OutputDesorptionAngle)(sol, i)\n\nOutputs the desorption angle in degrees (relative to the surface normal) if a desorption event was detected.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputDesorptionAngle-Tuple{Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputDesorptionAngle","text":"OutputDesorptionAngle(indices; surface_normal=[0, 0, 1], surface_distance_threshold=austrip(5.0u\"Å\"))\n\nOutputs the desorption angle in degrees (relative to the surface normal) if a desorption event is detected. Use surface_normal to define the direction \"away\" from the surface. Most commonly, this would be in positive z direction.\n\nA desorption is detected if the centre of mass of the molecule defined with indices is above surface_distance_threshold from the closest surface atom. This is calculated with respect to surface_normal and will take into account periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputDesorptionSnapshot-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputDesorptionSnapshot","text":"(output::OutputDesorptionTrajectory)(sol, i)\n\nOnly output trajectory snapshot where desorption begins. (Centre of mass velocity projected onto surface normal changes sign)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputDesorptionSnapshot-Tuple{Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputDesorptionSnapshot","text":"OutputDesorptionSnapshot(indices; surface_normal=[0, 0, 1], surface_distance_threshold=austrip(5.0u\"Å\"))\n\nSave DynamicsVariables where desorption starts. (Same conditions as for OutputDesorptionTrajectory)\n\nUse surface_normal to define the direction \"away\" from the surface. Most commonly, this would be in positive z direction.\n\nUse extra_frames to save additional steps before the desorption event begins.\n\nA desorption is detected if the centre of mass of the molecule defined with indices is above surface_distance_threshold from the closest surface atom. This is calculated with respect to surface_normal and will take into account periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputDesorptionTrajectory-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputDesorptionTrajectory","text":"(output::OutputDesorptionTrajectory)(sol, i)\n\nOnly output parts of the trajectory where desorption is occurring.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputDesorptionTrajectory-Tuple{Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputDesorptionTrajectory","text":"OutputDesorptionTrajectory(indices; surface_normal=[0, 0, 1], surface_distance_threshold=austrip(5.0u\"Å\"), extra_frames=0)\n\nLike OutputDynamicsVariables, but only saves parts of the trajectory where desorption is occurring.\n\nUse surface_normal to define the direction \"away\" from the surface. Most commonly, this would be in positive z direction.\n\nUse extra_frames to save additional steps before the desorption event begins.\n\nA desorption is detected if the centre of mass of the molecule defined with indices is above surface_distance_threshold from the closest surface atom. This is calculated with respect to surface_normal and will take into account periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputDissociation","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputDissociation","text":"Output a 1 if the molecule has dissociated, 0 otherwise.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputFinalSubsetKineticEnergy","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputFinalSubsetKineticEnergy","text":"Evaluate the classical kinetic energy of a subset of the entire system at the end of the simulation.\n\nThe subset is defined by OutputSubsetKineticEnergy(indices).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputKineticTemperature","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputKineticTemperature","text":"Outputs the instantaneous temperature of the selected atoms in K in the system at every save point.\n\nInvoke with OutputKineticTemperature(:) for the entire system, or with OutputKineticTemperature([1,2,3...]) for a subset of atoms.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputQuantisedDiatomic","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputQuantisedDiatomic","text":"Output the vibrational and rotational quantum numbers of the final image.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputStateResolvedScattering1D","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputStateResolvedScattering1D","text":"Output a ComponentVector with fields reflection and transmission containing the probability of the outcome. Each index in the arrays refers to the adiabatic state.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputSubsetKineticEnergy","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputSubsetKineticEnergy","text":"OutputSubsetKineticEnergy(sol, i)\n\nEvaluate the classical kinetic energy of a subset of the entire system at each save step.\n\nThe subset is defined by OutputSubsetKineticEnergy(indices).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputSurfaceDesorption","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputSurfaceDesorption","text":"Outputs a 1 if the molecule has moved a certain distance from all atoms in the surface, 0 otherwise.\n\nDistance is defined by the projected distance from the highest non-adsorbate atom along the surface normal.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputAdiabaticPopulation-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputAdiabaticPopulation","text":"OutputAdiabaticPopulation(sol, i)\n\nOutput the adiabatic population at each timestep during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputCentroidPosition-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputCentroidPosition","text":"OutputCentroidPosition(sol, i)\n\nOutput the position of the ring polymer centroid at each timestep during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputCentroidVelocity-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputCentroidVelocity","text":"OutputCentroidVelocity(sol, i)\n\nOutput the velocity of the ring polymer centroid at each timestep during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputDiabaticPopulation-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputDiabaticPopulation","text":"OutputDiabaticPopulation(sol, i)\n\nOutput the diabatic population at each timestep during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputDiscreteState-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputDiscreteState","text":"OutputDiscreteState(sol, i)\n\nOutput the discrete state variable at each timestep during the trajectory. This is used for surface hopping simulations and returns the variable that determines the currently occupied adiabatic state.\n\nRequires that the dynamics variable has a field state.\n\nUse OutputDiabaticPopulation or OutputAdiabaticPopulation to get the population estimators.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputDynamicsVariables-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputDynamicsVariables","text":"OutputDynamicsVariables(sol, i)\n\nOutput all of the dynamics variables at each timestep during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputEverything-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputEverything","text":"OutputEverything(sol,i)\n\nOutputs the full DifferentialEquations solution object.\n\nStoring this to disk is inefficient, but allows for full post-processing with any of the functions defined in this module.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputFinal-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputFinal","text":"Output the end point of each trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputFinalTime-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputFinalTime","text":"Outputs the final time point of a trajectory. This is useful if simulations are terminated by a callback.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputInitial-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputInitial","text":"Output the first point of each trajectory in DynamicsVariables format. (Useful when using distributions for initial conditions.)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputKineticEnergy-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputKineticEnergy","text":"OutputKineticEnergy(sol, i)\n\nEvaluate the classical kinetic energy at each timestep during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputMappingMomentum-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputMappingMomentum","text":"OutputMappingMomentum(sol, i)\n\nOutput the momentum mapping variable at each timestep during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputMappingPosition-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputMappingPosition","text":"OutputMappingPosition(sol, i)\n\nOutput the position mapping variables at each timestep during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputNoise-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputNoise","text":"OutputNoise(sol, i)\n\nOutputs the noise generated by the integrator at each time step in the trajectory.\n\nNote: This requires using the run_dynamics command with save_noise=true, otherwise noise won't be accessible to this output function.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputPosition-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputPosition","text":"OutputPosition(sol, i)\n\nOutput the position at each timestep during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputPotentialEnergy-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputPotentialEnergy","text":"OutputPotentialEnergy(sol, i)\n\nOutput the adiabatic potential energy at each timestep during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputQuantumSubsystem-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputQuantumSubsystem","text":"OutputQuantumSubsystem(sol, i)\n\nOutput the quantum subsystem at each timestep during the trajectory. Usually this will refer to a wavefunction or density matrix but will depend on the particular dynamics method.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputSurfaceHops-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputSurfaceHops","text":"Output the total number of surface hops during the trajectory\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputTotalAdiabaticPopulation-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputTotalAdiabaticPopulation","text":"OutputTotalAdiabaticPopulation(sol, i)\n\nOutput the total adiabatic population at each timestep during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputTotalDiabaticPopulation-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputTotalDiabaticPopulation","text":"OutputTotalDiabaticPopulation(sol, i)\n\nOutput the total diabatic population at eah timestep during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputTotalEnergy-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputTotalEnergy","text":"OutputTotalEnergy(sol, i)\n\nEvaluate the classical Hamiltonian at each timestep during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputVelocity-Tuple{Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputVelocity","text":"OutputVelocity(sol, i)\n\nOutput the velocity at each timestep during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#Internals","page":"DynamicsOutputs","title":"Internals","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsoutputs/","page":"DynamicsOutputs","title":"DynamicsOutputs","text":"Modules=[NQCDynamics.DynamicsOutputs]\nPublic=false","category":"page"},{"location":"api/NQCDynamics/dynamicsoutputs/","page":"DynamicsOutputs","title":"DynamicsOutputs","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"@info \"Expanding src/dynamicssimulations/dynamicsmethods/mdef.md...\"\nstart_time = time()","category":"page"},{"location":"examples/mdef_multithermostat/#mdef-ttm-example","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"","category":"section"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"note: Note\nThis page focuses on using the model combination tools in NQCDynamics.jl and NQCModels.jl to perform MDEF simulations with separate thermostats for different parts of the system.  The page on Molecular Dynamics with Electronic Friction contains more information on MDEF as a method, and is a better starting point to setting up simulations. ","category":"page"},{"location":"examples/mdef_multithermostat/#Introtion","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"Intro🦆tion","text":"","category":"section"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"On this page, we will look at the example of simulating the response of hydrogen adsorbed to a Cu(111) surface to an ultrafast laser pulse using Molecular Dynamics with Electronic Friction and the Two-temperature model.","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"As detailed before, the nuclear coordinates in MDEF evolve as follows:","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"mathbfMddotmathbfR = - nabla_R V(mathbfR) + mathbfF(t) - Gamma(mathbfR) dotmathbfR","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"The first term on the right hand side of the equation corresponds to a conservative force associated with the potential energy surface (PES) as in the adiabatic case. The third term is the friction force and it comes from multiplication between the electronic friction object (Gamma(mathbfR)) and the velocity. Finally, the second term is a temperature and friction-dependent stochastic force which ensures detailed balance.","category":"page"},{"location":"examples/mdef_multithermostat/#The-two-temperature-model","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"The two-temperature model","text":"","category":"section"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"info: Info\nTemperature profiles for the Two-temperature model can be generated using the LightMatter.jl package. (Will be released soon)","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"The two-temperature model (TTM) is a system of two coupled differential equations that describe the time evolution of the electronic and lattice temperatures, T_el and T_ph. In this work, lateral heat transport across the metal surface is neglected, allowing for a simplified one-dimensional representation of the two-temperature model. The TTM is given by the following set of equations: ","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"Electronic heat capacity","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"C_elfracpartialpartial tT_el=nabla(kappanabla T_el)-g(T_el-T_ph)+S(zt) ","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"Phononic heat capacity","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"C_phfracpartialpartial tT_ph=g(T_el-T_ph) ","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"Laser source term","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"S(zt)=Fcdotfracexpfrac-zxicdotexpfrac-(t-t_0)^22r^2xicdotsqrt2pitau \n\t\ttau=fracmathrmFWHM2sqrt2ln2","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"The model is parametrised with material-specific parameters obtained from ab-initio calculations or experiments. As an example, the material-specific parameters for bulk crystalline Cu are shown here ([21]):","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"Parameter Explanation Value\ng Electron-phonon coupling constant 1times 10^-17mathrmWm^-3K^-1\nxi Laser penetration depth for lambda=400mathrmnm frac1xi=149mathrmnm\ngamma_el Scaling constant for the electronic heat capacity C_el. 980mathrmJm^-3K^-2\ntheta_D Debye temperature of Cu. 343mathrmK\nN Atom density of bulk Cu 85times 10^28\nkappa_RT Thermal conductivity at room temperature 4010mathrmW^-1K^-1\nmathrmFWHM Full width half maximum of the laser pulse 150mathrmfs","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"The electronic heat capacity C_el(T_el) was determined using a linear scaling relation:","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"C_el(T_el)=gamma_elT_el ","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"The temperature dependence of the thermal conductivity of Cu was modelled using the following relation:","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"kappa(T_el T_ph)=kappa_RTfracT_elT_ph","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"The phononic heat capacity was calculated using the Debye model with N and theta_D values given above:","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"C_ph(T_ph)=9nk_Bleft(fracT_phtheta_Dright)^3int_0^fractheta_DT_phfracx^4e^x(e^x-1)^2dx","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"An example of the TTM progression for a 80mathrmJm^-2 absorbed fluence is shown in the video below. ","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"(Image: Temperature progressions, energy distributions and laser power for a TTM progression.)","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"In our implementation of the TTM, the temperature progressions are saved to CSV files, which need to be interpolated to provide a continuous temperature function to use for our Simulations. ","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"using BSplineKit\nusing Unitful, UnitfulAtomic\nusing CSV, DataFrames\n\n\"\"\"\nThis function reads a CSV file for a TTM solution containing:\n1. The time in ps\n2. Electronic temperature\n3. Phononic temperature\n\nDepending on which index is specified, a continuous temperature function for the electronic or phononic temperature is returned. \n\"\"\"\nfunction T_function_from_file(file::String, index::Int=2)\n\tTTM_file = CSV.read(file, DataFrame)\n\tT_spline = interpolate(TTM_file.Time, TTM_file[:, index], BSplineOrder(4)) # is a cubic spline\n\tT_extrapolation = extrapolate(T_spline, Smooth()) #! Don't use to go earlier than the first point!\n\tT_function(time_ps) = T_extrapolation(ustrip(u\"ps\", time_ps)) * u\"K\"\n\treturn T_function\nend\n\nT_el_function = T_function_from_file(\"ttm-file.csv\", 2)\nT_ph_function = T_function_from_file(\"ttm-file.csv\", 3)","category":"page"},{"location":"examples/mdef_multithermostat/#Combining-MDEF-and-the-TTM","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"Combining MDEF and the TTM","text":"","category":"section"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"The electron and phonon temperatures are propagated as described above, yielding temperature profiles that are applied to MDEF simulations through the mathcalW term in the Langevin equation. T_el is applied directly to the adsorbate H atoms, while gamma as a function of H positions is determined using one of the MLIPs detailed above.  T_ph is coupled to the surface Cu atoms using a position-independent coupling constant.","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"(Image: Different thermostatting strategies for our system)","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"As shown above, T_ph can enter our system in different ways. We will use Subsystems to generate a CompositeModel and Simulation for these different strategies. ","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"using NQCDynamics\nusing Unitful, UnitfulAtomic\nusing MACEModels\n\n# Import starting structure\natoms, position, cell = read_extxyz(\"starting_structure.xyz\")\n\n# Load PES model\npes_model = MACEModel(\n\tatoms,\n\tcell,\n\t[\"mace-model.model\"];\n\tdevice=\"cpu\",\n\tdefault_dtype=Float32,\n\tmobile_atoms::Vector{Int}=18:56, # Keep the top 4 layers mobile, freeze the bottom 2. \n)\n\n# Load adsorbate and surface friction models\nadsorbate_friction_model = RandomFriction(3)\nsurface_friction_model = ConstantFriction(γ=0.2)","category":"page"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"Now that all models are defined, we can combine them in different ways for a simulation:","category":"page"},{"location":"examples/mdef_multithermostat/#Electron-thermostat-only","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"Electron thermostat only","text":"","category":"section"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"# PES applies to all atoms\npes_subsystem = Subsystem(pes_model)\n\n# Electronic friction applies to adsorbate atoms 55,56\nelectronic_friction = Subsystem(adsorbate_friction_model, indices=[55,56])\n\n# Combine models and generate Simulation\ncombined_model = CompositeModel(pes_subsystem, electronic_friction)\n\nsim_T_el_only = Simulation{MDEF}(\n\tatoms, \n\tcombined_model; \n\ttemperature = T_el_function, \n\tcell=cell\n)","category":"page"},{"location":"examples/mdef_multithermostat/#Phonon-thermostatting-top-four-layers","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"Phonon thermostatting top four layers","text":"","category":"section"},{"location":"examples/mdef_multithermostat/","page":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","title":"MDEF with the Two-temperature model and separate Electron and Phonon Thermostats","text":"# PES applies to all atoms\npes_subsystem = Subsystem(pes_model)\n\n# Electronic friction applies to adsorbate atoms 55,56\nelectronic_friction = Subsystem(adsorbate_friction_model, indices=[55,56])\n\n# Phononic friction applies to surface atoms 18:54\nphononic_friction = Subsystem(surface_friction_model, indices=18:54)\n\n# Combine models and generate Simulation\ncombined_model = CompositeModel(\n\tpes_subsystem, \n\telectronic_friction, \n\tphononic_friction\n)\n\n# Create TemperatureSetting objects to apply T_el to adsorbates, T_ph to surface\n# Manually specified indices\nelectron_thermostat = TemperatureSetting(T_el_function, indices = [55,56]) \n# Inherit indices from a Subsystem\nphonon_thermostat = TemperatureSetting(T_ph_function, phononic_friction) \n\nsim_T_el_only = Simulation{MDEF}(\n\tatoms, \n\tcombined_model; \n\ttemperature = [\n\t\telectron_thermostat,\n\t\tphonon_thermostat\n\t], \n\tcell=cell\n)","category":"page"},{"location":"output_and_analysis/intro/#output_and_analysis","page":"Simulations outputs and analysis functions","title":"Simulations outputs and analysis functions","text":"","category":"section"},{"location":"output_and_analysis/intro/","page":"Simulations outputs and analysis functions","title":"Simulations outputs and analysis functions","text":"NQCDynamics.jl is able to output a variety of common observables when running simulations with the run_dynamics function. Further output functions can be implemented easily as well. ","category":"page"},{"location":"output_and_analysis/intro/","page":"Simulations outputs and analysis functions","title":"Simulations outputs and analysis functions","text":"In this section you will find an overview of all available output types, as well as explanations of some common analysis functions in the realm of surface chemistry which we have implemented in the package. ","category":"page"},{"location":"output_and_analysis/intro/#DynamicsOutputs","page":"Simulations outputs and analysis functions","title":"DynamicsOutputs","text":"","category":"section"},{"location":"output_and_analysis/intro/","page":"Simulations outputs and analysis functions","title":"Simulations outputs and analysis functions","text":"In many examples within this documentation, you have seen calls to run_dynamics:","category":"page"},{"location":"output_and_analysis/intro/","page":"Simulations outputs and analysis functions","title":"Simulations outputs and analysis functions","text":"ensemble = run_dynamics(sim, tspan, distribution;selection=1:20,\n    dt=0.1u\"fs\", output=OutputPosition, trajectories=20, callback=terminate)","category":"page"},{"location":"output_and_analysis/intro/","page":"Simulations outputs and analysis functions","title":"Simulations outputs and analysis functions","text":"Within run_dynamics, the output argument specifies the desired output values for each trajectory. output can either be given as a single function, or as a tuple of multiple output functions, for example:","category":"page"},{"location":"output_and_analysis/intro/","page":"Simulations outputs and analysis functions","title":"Simulations outputs and analysis functions","text":"output=OutputPosition # or\noutput=(OutputPosition, OutputVelocity, OutputKineticEnergy)\n\nensemble[3][:OutputPosition] # will output the positions at all timesteps in trajectory 3","category":"page"},{"location":"output_and_analysis/intro/","page":"Simulations outputs and analysis functions","title":"Simulations outputs and analysis functions","text":"Every output type is a function which can use the DynamicsVariables and Simulation values of the respective trajectory, allowing you to create custom output types of any kind. See the [developer documentation] for more information on how to implement a custom output type. ","category":"page"},{"location":"output_and_analysis/intro/","page":"Simulations outputs and analysis functions","title":"Simulations outputs and analysis functions","text":"You can find an overview of all available output types in the DynamicsOutputs API. ","category":"page"},{"location":"output_and_analysis/intro/#Analysis-functions","page":"Simulations outputs and analysis functions","title":"Analysis functions","text":"","category":"section"},{"location":"output_and_analysis/intro/","page":"Simulations outputs and analysis functions","title":"Simulations outputs and analysis functions","text":"The Analysis submodule in NQCDynamics contains functions commonly used in the analysis of trajectories to make the analysis of existing trajectories easier.  Ideally, most observable quantities could be implemented with a combination of DynamicsOutputs and Reduction types, however we might want to data from existing ensemble simulations where re-running the entire set of trajectories is impractical. ","category":"page"},{"location":"output_and_analysis/intro/","page":"Simulations outputs and analysis functions","title":"Simulations outputs and analysis functions","text":"As a result, most functions in the Analysis submodule are also implemented as a DynamicsOutput. ","category":"page"},{"location":"output_and_analysis/intro/#Convenient-functions-for-periodic-structures","page":"Simulations outputs and analysis functions","title":"Convenient functions for periodic structures","text":"","category":"section"},{"location":"output_and_analysis/intro/","page":"Simulations outputs and analysis functions","title":"Simulations outputs and analysis functions","text":"NQCDynamics.Structure contains several useful functions for periodic structures, such as pbc_distance, pbc_center_of_mass. ","category":"page"},{"location":"output_and_analysis/intro/","page":"Simulations outputs and analysis functions","title":"Simulations outputs and analysis functions","text":"These functions take into account periodic copies of the atoms in question, returning the respective values for the closest set of periodic copies. ","category":"page"},{"location":"output_and_analysis/intro/#Analysis-of-diatomic-molecules","page":"Simulations outputs and analysis functions","title":"Analysis of diatomic molecules","text":"","category":"section"},{"location":"output_and_analysis/intro/","page":"Simulations outputs and analysis functions","title":"Simulations outputs and analysis functions","text":"NQCDynamics.Analysis.Diatomic","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"@info \"Expanding src/NQCModels/frictionmodels.md...\"\nstart_time = time()","category":"page"},{"location":"NQCModels/frictionmodels/#models-friction","page":"Electronic friction models","title":"Electronic friction models","text":"","category":"section"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"To perform molecular dynamics with electronic friction (MDEF) a specific type of model must be used that provides the friction tensor used to propagate the dynamics. For this we recommend using FrictionProviders.jl, however, various analytic models can also be employed.","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"As detailed in the MDEF page, there are two ways to obtain friction values, either from the local density friction approximation (LDFA), or from time-dependent perturbation theory (TDPT), also known as orbital-dependent friction (ODF). The models on this page describe our existing implementations.","category":"page"},{"location":"NQCModels/frictionmodels/#friction-providers","page":"Electronic friction models","title":"FrictionProviders.jl","text":"","category":"section"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"Machine learning-based models, and cube-based calculators can called through FrictionProviders.jl connector package.","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"Currently, FrictionProviders.jl supports LDFA (density) models based on:","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"Cube electronic densities\n(ACEpotentials.jl)[https://github.com/ACEsuit/ACEpotentials.jl]\n(Scikit-learn)[https://github.com/scikit-learn/scikit-learn]","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"TDPT (ODF) friction models based on:","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"(ACEds.jl)[https://github.com/ACEsuit/ACEds.jl]","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"The use of FrictionProviders.jl with LDFA (Cube calculator and ACE model), and TDPT (ACEds-based model) is explained on the reactive scattering example, to investigate the scattering of a diatomic molecule from a metal surface.","category":"page"},{"location":"NQCModels/frictionmodels/#models-ldfa","page":"Electronic friction models","title":"Density models for LDFA","text":"","category":"section"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"Our Cube-LDFA implementation takes a .cube file containing the electron density, whereas the ML-LDFA models predict the density directly. In both cases the obtained local density is then used to evaluate the friction.","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"The model works by fitting the LDA data provided by [2] that provides the LDFA friction coefficient as a function of the Wigner-Seitz radius. When the model is initialised, the LDA data from [2] is interpolated using DataInterpolations.jl with a cubic spline. Then, whenever required, the density at the current position is taken directly from the .cube file and converted to the Wigner-Seitz radius with the following relation:","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"r_s(rho) = (frac34pi rho (mathbfr_i))^13","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"Then, the interpolation function is evaluated with this value for the radius, which gives the LDA friction. Optimally, this would be done via an ab initio calculation to get the electron density, but this model instead uses a pre-computed .cube file to get the density with minimal cost. This makes the assumption that the density does not change throughout the dynamics, or that the surface is assumed to be frozen in place.","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"This graph shows how we interpolate the LDA data and evaluate the friction coefficient as a function of the Wigner-Seitz radius. (Image: ldfa graph)","category":"page"},{"location":"NQCModels/frictionmodels/#Analytic-models","page":"Electronic friction models","title":"Analytic models","text":"","category":"section"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"Since ab initio friction calculations are often expensive it is useful to have some models that we can use to test different friction methods. The DiabaticFrictionModel is the abstract type that groups together the diabatic models for which electronic friction can be evaluated. These have many electronic states, modelling the electronic structure characteristic of a metal.  The friction is calculated for these models directly from the nonadiabatic couplings with the equation:","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"γ = 2pihbar sum_j 1dHjjdH1 delta(omega_j)  omega_j","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"where the delta function is approximated by a normalised Gaussian function and the sum runs over the adiabatic states ([3]). The matrix elements in this equation are the position derivatives of the diabatic hamiltonian converted to the adiabatic representation.","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"warning: Warning\nThe analytic friction models and the equation above are experimental and subject to change.","category":"page"},{"location":"initialconditions/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"@info \"Expanding src/initialconditions/hamiltonian.md...\"\nstart_time = time()","category":"page"},{"location":"initialconditions/hamiltonian/#hmc-sampling","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"","category":"section"},{"location":"initialconditions/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"Our implementation of Hamiltonian Monte Carlo (HMC) is a light wrapper around the AdvancedHMC.jl package. If you want to learn about the HMC theory, refer to the references and documentation provided with AdvancedHMC.jl.","category":"page"},{"location":"initialconditions/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"Currently, our implementation works for systems with classical nuclei only (i.e. Simulation but not RingPolymerSimulation).","category":"page"},{"location":"initialconditions/hamiltonian/#Example","page":"Thermal Hamiltonian Monte Carlo","title":"Example","text":"","category":"section"},{"location":"initialconditions/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"In this example we use Hamiltonian Monte Carlo to sample the canonical distribution of a 3 dimensional harmonic oscillator potential containing 4 atoms.","category":"page"},{"location":"initialconditions/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"using NQCDynamics\nusing Unitful\nusing UnitfulAtomic\n\nsim = Simulation(Atoms([:H, :H, :C, :C]), Harmonic(dofs=3); temperature=300u\"K\")\nr0 = randn(size(sim))\nchain, stats = InitialConditions.ThermalMonteCarlo.run_advancedhmc_sampling(sim, r0, 1e4)\nnothing # hide","category":"page"},{"location":"initialconditions/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"The Monte Carlo chain contains the nuclear configurations that we have sampled:","category":"page"},{"location":"initialconditions/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"chain","category":"page"},{"location":"initialconditions/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"and stats contains extra information about the sampling procedure:","category":"page"},{"location":"initialconditions/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"stats","category":"page"},{"location":"initialconditions/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"Here we should see that the energy expectation for the generated ensemble matches with the equipartition theorem:","category":"page"},{"location":"initialconditions/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"Estimators.@estimate potential_energy(sim, chain)\naustrip(sim.temperature) * 3 * 4 / 2","category":"page"},{"location":"initialconditions/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCModels/diabaticmodels/","page":"DiabaticModels","title":"DiabaticModels","text":"@info \"Expanding src/api/NQCModels/diabaticmodels.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCModels/diabaticmodels/#DiabaticModels","page":"DiabaticModels","title":"DiabaticModels","text":"","category":"section"},{"location":"api/NQCModels/diabaticmodels/","page":"DiabaticModels","title":"DiabaticModels","text":"Modules=[NQCModels.DiabaticModels]","category":"page"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels","page":"DiabaticModels","title":"NQCModels.DiabaticModels","text":"DiabaticModels\n\nModels defined within this module subtype the DiabaticModel and provide potentials as Hermitian matrices and derivatives as arrays of Hermitian matrices.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.AltDebyeSpectralDensity","page":"DiabaticModels","title":"NQCModels.DiabaticModels.AltDebyeSpectralDensity","text":"AltDebyeSpectralDensity{T} <: SpectralDensity\n\nStandard Debye spectral density but uses an alternative discretization scheme that requires a cutoff parameter ωᵐ.\n\nReferences\n\nNajeh Rekik, Chang-Yu Hsieh, Holly Freedman, Gabriel Hanna, J. Chem. Phys. 138, 144106 (2013)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.AnanthModelOne","page":"DiabaticModels","title":"NQCModels.DiabaticModels.AnanthModelOne","text":"AnanthModelOne(a=0.01, b=1.6, c=0.005, d=1.0)\n\nAnanth's simple avoided crossing model (similar to Tully's first model) from J. Chem. Phys. 127, 084114 (2007).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.AnanthModelTwo","page":"DiabaticModels","title":"NQCModels.DiabaticModels.AnanthModelTwo","text":"AnanthModelTwo(a=0.04, b=0.01, c=0.005, d=1.0, e=0.7, f=1.6)\n\nAnanth's asymmetric model from J. Chem. Phys. 127, 084114 (2007).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.BosonBath","page":"DiabaticModels","title":"NQCModels.DiabaticModels.BosonBath","text":"BosonBath(density::SpectralDensity, N::Integer)\n\nBosonic bath with given spectral density.\n\nUseful for sampling the bath uncoupled from the spin for spin-boson dynamics.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.DebyeSpectralDensity","page":"DiabaticModels","title":"NQCModels.DiabaticModels.DebyeSpectralDensity","text":"DebyeSpectralDensity{T} <: SpectralDensity\n\nDebye density as detailed in: Xin He, Jian Liu, J. Chem. Phys. 151, 024105 (2019)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.DiabaticFrictionModel","page":"DiabaticModels","title":"NQCModels.DiabaticModels.DiabaticFrictionModel","text":"DiabaticFrictionModel <: LargeDiabaticModel\n\nThese models are defined identically to the LargeDiabaticModel but allocate extra temporary arrays when used with NQCDynamics.jl.\n\nThis allows for the calculation of electronic friction internally from the diabatic potential after diagonalisation and calculation of nonadiabatic couplings.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.DiabaticModel","page":"DiabaticModels","title":"NQCModels.DiabaticModels.DiabaticModel","text":"DiabaticModel <: Model\n\nDiabaticModels are used when a system has multiple electronic states that are presented in the diabatic representation. This is the case for the majority of model systems.\n\nImplementation\n\nDiabaticModels should implement:\n\npotential(model, R)\nderivative!(model, D, R)\nnstates(model)\nndofs(model)\n\nExample\n\nIn this example we create a simple 2 state, 1 dimensional diabatic model MyModel. As noted above, we implement the 4 relevant functions then evaluate the potential. Since this is a 1D model the argument R accepts a Real value.\n\nusing StaticArrays: SMatrix\nusing LinearAlgebra: Hermitian\n\nstruct MyModel <: NQCModels.DiabaticModels.DiabaticModel end\n\nNQCModels.nstates(::MyModel) = 2\nNQCModels.ndofs(::MyModel) = 1\n\nfunction NQCModels.potential(::MyModel, R::Real) \n    V11 = R\n    V22 = -R\n    V12 = 1\n    return Hermitian(SMatrix{2,2}(V11, V12, V12, V22))\nend\n\nfunction NQCModels.derivative!(::MyModel, D, R::Real)\n    return Hermitian(SMatrix{2,2}(1, 0, 0, 1))\nend\n\nmodel = MyModel()\nNQCModels.potential(model, 10)\n\n# output\n\n2×2 Hermitian{Int64, SMatrix{2, 2, Int64, 4}}:\n 10    1\n  1  -10\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.DoubleWell","page":"DiabaticModels","title":"NQCModels.DiabaticModels.DoubleWell","text":"DoubleWell(mass=1, ω=1, γ=1, Δ=1)\n\nTwo state double well, also called the one-dimensional spin-boson model. See: J. Chem. Phys. 150, 244102 (2019)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.ErpenbeckThoss","page":"DiabaticModels","title":"NQCModels.DiabaticModels.ErpenbeckThoss","text":"struct ErpenbeckThoss{T<:AbstractFloat} <: DiabaticModel\n\n1D two-state diabatic system capable of modelling a molecule adsorbed on a metal surface or a single-molecule junction.\n\nIn the two references, all of the parameters are identical except for the particle mass m and the vertical shift c applied to the ϵ₀ state. Both references modify the shift to ensure the quantum ground-state has an energy of 0 eV. Note that the mass m is specified in atomic mass units (amu) not atomic units. We calculate the offset automatically in the constructor from the Morse potential zero-point energy.\n\nReferences\n\nPHYSICAL REVIEW B 97, 235452 (2018)\nJ. Chem. Phys. 151, 191101 (2019)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.FullGaussLegendre","page":"DiabaticModels","title":"NQCModels.DiabaticModels.FullGaussLegendre","text":"FullGaussLegendre{T} <: WideBandBathDiscretisation\n\nUse Gauss-Legendre quadrature to discretise the continuum across the entire band width. This is similar to the ShenviGaussLegendre except that splits the continuum at the Fermi level into two halves.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.GatesHollowayElbow","page":"DiabaticModels","title":"NQCModels.DiabaticModels.GatesHollowayElbow","text":"GatesHollowayElbow()\n\nSimple two state elbow potential from Gates and Holloway: Journal of Electron Spectroscopy and Related Phenomena, 64/65 (1993) 633-639\n\nHas two diabatic states each comprised of the sum of a Morse and a repulsive potential. The coupling between them is an exponential function of z (distance from the surface).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.LargeDiabaticModel","page":"DiabaticModels","title":"NQCModels.DiabaticModels.LargeDiabaticModel","text":"LargeDiabaticModel <: DiabaticModel\n\nSame as the DiabaticModels but uses normal Julia arrays instead of StaticArrays and must implement the inplace potential! rather than potential. This is useful when nstates is very large and StaticArrays are no longer efficient.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.MiaoSubotnik","page":"DiabaticModels","title":"NQCModels.DiabaticModels.MiaoSubotnik","text":"MiaoSubotnik{T<:AbstractFloat} <: DiabaticModel\n\nDouble well model with parameters matching those of Miao and Subotnik in the reference. This model should be paired with the AndersonHolstein model to couple to the bath of metallic states.\n\nReferences\n\nJ. Chem. Phys. 150, 041711 (2019)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.OhmicSpectralDensity","page":"DiabaticModels","title":"NQCModels.DiabaticModels.OhmicSpectralDensity","text":"OhmicSpectralDensity{T} <: SpectralDensity\n\nOhmic density as detailed in: Xin He, Jian Liu, J. Chem. Phys. 151, 024105 (2019)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.OuyangModelOne","page":"DiabaticModels","title":"NQCModels.DiabaticModels.OuyangModelOne","text":"OuyangModelOne(A=0.01, B=1.6, Γ=1e-4, N=10, ΔE=1.6e-2, D=1.0)\n\nModel #1 from Ouyang and Subotnik. See also Ouyang's thesis.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.ReferenceGaussLegendre","page":"DiabaticModels","title":"NQCModels.DiabaticModels.ReferenceGaussLegendre","text":"ReferenceGaussLegendre{T}\n\nImplementation translated from Fortran code used for simulations of Shenvi et al. in J. Chem. Phys. 130, 174107 (2009). Two differences from ShenviGaussLegendre:\n\nPosition of minus sign in energy levels has been corrected.\nDivision by sqrt(ΔE) in the coupling. \n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.ShenviGaussLegendre","page":"DiabaticModels","title":"NQCModels.DiabaticModels.ShenviGaussLegendre","text":"ShenviGaussLegendre{T}\n\nDefined as described by Shenvi et al. in J. Chem. Phys. 130, 174107 (2009). The position of the negative sign for the state energy level has been moved to ensure the states are sorted from lowest to highest.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.SpinBoson","page":"DiabaticModels","title":"NQCModels.DiabaticModels.SpinBoson","text":"SpinBoson(density::SpectralDensity, N::Integer, ϵ, Δ)\n\nSpin boson model with N bosons with given spectral density.\n\nReferences\n\nXin He, Jian Liu, J. Chem. Phys. 151, 024105 (2019)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.ThreeStateMorse","page":"DiabaticModels","title":"NQCModels.DiabaticModels.ThreeStateMorse","text":"ThreeStateMorse()\n\nThree state morse potential referred to as Model IA here: J. Chem. Phys. 150, 244102 (2019) \n\nModels IB and IC retain the same functional form and need only a change of parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.TrapezoidalRule","page":"DiabaticModels","title":"NQCModels.DiabaticModels.TrapezoidalRule","text":"TrapezoidalRule{B,T} <: WideBandBathDiscretisation\n\nDiscretise wide band continuum using trapezoidal rule. Leads to evenly spaced states and constant coupling.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.TullyModelOne","page":"DiabaticModels","title":"NQCModels.DiabaticModels.TullyModelOne","text":"TullyModelOne(a=0.01, b=1.6, c=0.005, d=1.0)\n\nTully's simple avoided crossing model from J. Chem. Phys. 93, 1061 (1990).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.TullyModelThree","page":"DiabaticModels","title":"NQCModels.DiabaticModels.TullyModelThree","text":"TullyModelThree(a=0.0006, b=0.1, c=0.9)\n\nTully's extended coupling with reflection model from J. Chem. Phys. 93, 1061 (1990).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.TullyModelTwo","page":"DiabaticModels","title":"NQCModels.DiabaticModels.TullyModelTwo","text":"TullyModelTwo(a=0.1, b=0.28, c=0.015, d=0.06, e=0.05)\n\nTully's dual avoided crossing model from J. Chem. Phys. 93, 1061 (1990).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.discretize-Tuple{NQCModels.DiabaticModels.SpectralDensity, Integer}","page":"DiabaticModels","title":"NQCModels.DiabaticModels.discretize","text":"Discretize a given spectral density for N oscillators. Returns frequencies and couplings.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/diabaticmodels/","page":"DiabaticModels","title":"DiabaticModels","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"api/NQCDynamics/numericutils/","page":"Numerical utilities","title":"Numerical utilities","text":"@info \"Expanding src/api/NQCDynamics/numericutils.md...\"\nstart_time = time()","category":"page"},{"location":"api/NQCDynamics/numericutils/#Numerical-utilities","page":"Numerical utilities","title":"Numerical utilities","text":"","category":"section"},{"location":"api/NQCDynamics/numericutils/","page":"Numerical utilities","title":"Numerical utilities","text":"Modules=[NQCDynamics.FastDeterminant]","category":"page"},{"location":"api/NQCDynamics/numericutils/#NQCDynamics.FastDeterminant","page":"Numerical utilities","title":"NQCDynamics.FastDeterminant","text":"FastDeterminant\n\nWhen computing many determinants in a loop the allocation and GC of the temporary arrays for the pivots and workspace can contribute a large portion of the total runtime.\n\nUsing FastLapackInterface we can reduce the allocations and improve the runtime performance.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/numericutils/#NQCDynamics.FastDeterminant.det!-Tuple{AbstractMatrix, FastLapackInterface.LUWs}","page":"Numerical utilities","title":"NQCDynamics.FastDeterminant.det!","text":"det!(A::AbstractMatrix, ws::LUWs)\n\nSame as det but the user must provide the LU workspace from FastLapackInterface.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/numericutils/","page":"Numerical utilities","title":"Numerical utilities","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"@info \"Expanding src/getting_started.md...\"\nstart_time = time()","category":"page"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To get started with the package we can identify the necessary ingredients to perform a simple classical dynamics simulation and walk through how to set up the simulation.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using NQCDynamics","category":"page"},{"location":"getting_started/#Atoms","page":"Getting started","title":"Atoms","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"First, we must define the particles in the simulation. For this purpose we provide the Atoms  type which will contain the symbols, atomic numbers and masses for our atoms. Technically these need not be actual atoms and be a generic particle.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If using real atoms, then they can be constructed using the chemical symbols as a Vector of Julia's Symbol types, a Vector{Symbol}:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Atoms([:H, :C])","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"You can see that this contains two atoms labelled by their atomic numbers with their masses in atomic units.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"note: Atomic units\nInternally atomic units are used for all quantities. This makes things simple when performing nonadiabatic dynamics. Unitful.jl and UnitfulAtomic.jl can be used to help with unit transformations, and many functions will directly accept Unitful quantities and handle the conversions for you.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Alternatively, if not using real atoms, Atoms can be created using a Vector{<:Real} where the provided numbers are the masses of the particles.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Atoms([1, 2, 3, 4, 5, 6])","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"A more detailed look into the Atoms type along with a description of how to save and load structures can be found here.","category":"page"},{"location":"getting_started/#Representing-atomic-positions-and-velocities","page":"Getting started","title":"Representing atomic positions and velocities","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"This package chooses to separate the dynamical variables from the static atomic parameters included in the Atoms type. This allows us to easily interface with other numerical packages like DifferentialEquations.jl and AdvancedMH.jl. As such, both positions and velocities are represented using Julia's standard Array type, specifically as an Array{T,2} or the Matrix{T} type, which are equivalent. If you are new to Julia, you can find a description of the Array here. The first dimension contains each atomic degree of freedom, and the second dimension contains each atom. For example, a 3D system with two atoms would have positions:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using Symbolics\n@variables x1, y1, z1, x2, y2, z2\nr = [x1 x2;\n     y1 y2;\n     z1 z2]","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"info: Adding external packages\nSymbolics is a package available from the General registry. You will have to add it to your current environment using pkg> add Symbolics to be able to reproduce this example. Throughout the documentation we occasionally use external packages, if you run into an error you will likely have to add the package before being able to use it. Refer to the Julia manual for further information on installing packages.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"For a 1D system it would be necessary to create a 1x1 matrix:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"r = fill(x1, (1,1))","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Velocities are handled in the same way as positions and the data structures are the same. Usually manual initialisation like this will only be necessary for small model systems, whereas full dimensional model system will be read from a file instead. This is explored in the Atoms documentation.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"tip: Ring polymer simulations?\nWe can also perform simulations using ring polymers which have multiple replicas of each atom, these are implemented using Array{T,3} where the third dimension is used for each ring polymer bead. For more information, see the ring polymer methods in the dynamics methods section.","category":"page"},{"location":"getting_started/#Models","page":"Getting started","title":"Models","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The next ingredient required to set up the simulation is the Model, i.e., the potentials in which the system evolves. These Models are provided by NQCModels.jl, which  is a convenient infrastructure for defining different kinds of models for adiabatic and nonadiabatic dynamics. These models can range from simple analytic potentials all the way up to multi-dimensional ab initio potentials. Refer to the NQCModels.jl page for information on the available models and a description of how to implement further models.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"For now we can look at an AdiabaticModel which provides a simple harmonic potential energy function.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"model = Harmonic()","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Here, the four parameters (m, ω, r₀ and dofs) for this model are shown along with their types and default values. These values can be modified by specifying a new value in the constructor. For example for m:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"model = Harmonic(m=0.4)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"tip: Check out Parameters.jl\nMany of the models use Parameters.jl to provide convenient keyword constructors and formatted printing for the models. The Harmonic model above is defined using the @with_kw macro from Parameters.jl to give it a set of default parameters. Each of these can be modified by specifying a new value using keyword arguments in the constructor as demonstrated above.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Adiabatic models implement two functions to calculate the total energy and the forces, respectively: potential(model, R) and derivative(model, R).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Let's try these out and take a look at the results:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"potential(model, hcat(25.0))\nderivative(model, hcat(25.0))","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"note: Why hcat?\nAll models accept an R::AbstractMatrix for the argument representing the positions of the particles in the system. These are structured such that size(R) = (dofs, natoms) where dofs is the number of degrees of freedom for each atom, and natoms is the number of atoms in the  simulation.Since this is a 1D model, we use hcat to quickly create a 1x1 matrix.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To make sure the model is what we expect, we can plot the potential and derivative  using a custom plotting recipe. This looks pretty harmonic to me!","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using Plots\n\nplot(-5:0.1:5, model)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"warning: Warning\nPlotting recipes currently only exist for 1D models. For more complex models you will have to handle the plotting manually.","category":"page"},{"location":"getting_started/#Simulation","page":"Getting started","title":"Simulation","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To control all simulation parameters in one environment, we use the Simulation type which will contain both the Atoms and Models explained above, along with any extra information required for the simulation.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"sim = Simulation{Classical}(Atoms(:H), model)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Here, we have specified that each atom has a single degree of freedom and have not provided a simulation cell. Classical is a type parameter, and specifies the dynamics method that we want to use. Check out Dynamics methods to learn about the other kinds of dynamics available.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"note: Note\nTechnically Simulation(atoms, model) is equivalent to Simulation{Classical}(atoms, model) since Classical is the default.","category":"page"},{"location":"getting_started/#Dynamics-variables","page":"Getting started","title":"Dynamics variables","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The final ingredient before we can perform our simulation is the initial positions and velocities of our particles. For each dynamics type, the method DynamicsVariables is implemented and creates the dynamics variables for us. For classical dynamics we must provide a Matrix of velocities and of positions. These should have size = (dofs, natoms), matching the arguments of the potential and derivative functions. Usually the initial coordinates would have some physical significance, perhaps sampled from a relevant distribution, but here we use random numbers for simplicity.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"v = rand(3, 3);\nr = rand(3, 3);\nDynamicsVariables(sim, v, r)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"note: Note\nSince DifferentialEquations.jl requires AbstractArrays for the dynamics variables, we use ComponentArrays.jl which allow us to conveniently store all the required information for different types of dynamics.","category":"page"},{"location":"getting_started/#Bringing-it-all-together","page":"Getting started","title":"Bringing it all together","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"We have now covered all the parts necessary to perform our first classical dynamics simulation. Let's quickly set up our simulation parameters using what we've learned. Here we'll have two atoms in a harmonic potential, each with a single degree of freedom.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using NQCDynamics # hide\n\natoms = Atoms([:H, :C])\nsim = Simulation{Classical}(atoms, Harmonic(ω=50.0))\nz = DynamicsVariables(sim, randn(size(sim)), randn(size(sim)))\n\nnothing # hide","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Now, we can finally run the trajectory using the run_dynamics function. This takes three positional arguments: the simulation parameters sim,  the time span we want to solve fortspan, and the dynamics variablesz. For classical dynamics we also provide a timestepdtsince we're using theVelocityVerlet` algorithm by default.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"note: Integration algorithms\nEach method will default to an appropriate integration algorithm though it is possible to specify via a keyword argument to run_dynamics if an alternative algorithm is preferred. Refer to the dynamics documentation for more information.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The final keyword argument output is used to specify the quantities we want to save during the dynamics. A list of the available quantities can be found here.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"tip: Output format\nrun_dynamics returns a Dictionary from Dictionaries.jl that has entries containing the time and the output quantities saved at each time step.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"tspan = (0.0, 50.0)\nsolution = run_dynamics(sim, (0.0, 50.0), z;\n                                   dt=0.1, output=(OutputPosition, OutputVelocity))","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Here you can see the output containing the time steps and the output quantities we specified. These can be accessed directly as shown here:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"solution[:Time]\nsolution[:OutputPosition]","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"As with the models, we provide custom plotting recipes to quickly visualise the results before performing further analysis by manually accessing the fields of the solution table. To use these recipes, simply provide the solution to the plot function from Plots.jl and give the name of the output quantity as the second argument. This will only work if this quantity was specified in run_dynamics.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using Plots # hide\nplot(solution, :OutputPosition)\nplot!(solution, :OutputVelocity)","category":"page"},{"location":"getting_started/#Ensemble-simulations","page":"Getting started","title":"Ensemble simulations","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"We have shown how to perform a single trajectory, but usually we are interested in performing many and calculating observables using statistical methods. Running more trajectories is as simple as providing the trajectories keyword to run_dynamics, but we'll go through this in more detail in the Ensemble simulations section.","category":"page"},{"location":"getting_started/#What's-next?","page":"Getting started","title":"What's next?","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Now that we've covered the basics of classical dynamics, we're ready to explore the world of nonadiabatic dynamics. All the dynamics methods follow these patterns and anything you find elsewhere in the documentation should now seem relatively familiar.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"@info \"Expanding src/initialconditions/ebk.md...\"\nstart_time = time()","category":"page"},{"location":"initialconditions/ebk/#ebk-sampling","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"","category":"section"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"In surface science, it is often of interest to investigate how collisions with surfaces can perturb the quantum states of molecules. In particular, for diatomic molecules, the rotational and vibrational quantum numbers can undergo significant changes when the molecule impacts the surface.","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"Einstein-Brillouinn-Keller (EBK) quantisation allows for a semiclassical investigation into these phenomena by providing a link between the quantum numbers and classical positions and velocities. The quantisation procedure allows the user to generate a classical distribution with a given set of quantum numbers, then perform semiclassical dynamics and extract the quantum numbers at the end by reversing the procedure.","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"These three steps can be applied to give insight into the processes taking place during surface scattering and allow us to attempt to predict the experimentally observed change in the quantum numbers.","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"A detailed yet approachable description of the theory is given by [4] so we shall not delve into the theory here. Briefly, the procedure for a diatomic molecule involves an optimisation process to find the bounds of an integral, then computing the integral to obtain the vibrational quantum number. The rotational quantum number comes directly from the classical angular momentum of the molecule.","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"Configurations can be generated by randomly selecting bond lengths from the appropriate probability distribution and selecting a matching radial velocity.","category":"page"},{"location":"initialconditions/ebk/#Example","page":"Semiclassical EBK quantisation","title":"Example","text":"","category":"section"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"In this example we will create a quantised distribution suitable for use as initial conditions for hydrogen scattering simulations.","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"The simulation can be set up in the usual way, by specifying the atoms along with the model and the simulation cell.","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"using NQCDynamics\nusing Unitful, UnitfulAtomic\n\natoms = Atoms([:H, :H])\nmodel = DiatomicHarmonic()\ncell = PeriodicCell(austrip.([5.883 -2.942 0; 0 5.095 0; 0 0 20] .* u\"Å\"))\nsim = Simulation(atoms, model; cell=cell)","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"The distribution is generated using the QuantisedDiatomic.generate_configurations function. We have to provide the desired vibrational ν and rotational J quantum numbers, along with the number of samples and some other options as keyword arguments. In addition to the rotational and vibrational energy we have applied a translational impulse of 1 eV and positioned the molecule at a height of 10 bohr.","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"using NQCDynamics.InitialConditions: QuantisedDiatomic\n\nν, J = 2, 0\nnsamples = 150\n\nconfigurations = QuantisedDiatomic.generate_configurations(sim, ν, J;\n    samples=nsamples, translational_energy=1u\"eV\", height=10)","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"The output contains both the positions and velocities, these can be passed directly to the DynamicalDistribution for use with dynamics. Here however, let's focus on the positions and visualise the distribution.","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"This collects the x and y coordinate for each atom:","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"r = last.(configurations)\nx = hcat([i[1,:] for i in r]...)\ny = hcat([i[2,:] for i in r]...)","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"Now we can plot the distribution:","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"using Plots\n\nplt = plot(\n    xlabel=\"x coordinate / bohr\",\n    ylabel=\"y coordinate / bohr\",\n    legend=false,\n)\n\nfor i=1:nsamples\n    plot!([x[1,i], x[2,i]], [y[1,i], y[2,i]], linewidth=5, color=:black)\n    scatter!([x[1,i], x[2,i]], [y[1,i], y[2,i]])\nend\nplt","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"Here we can see that the molecule is randomly distributed within the unit cell. Since we have used a harmonic potential, this could have been produced without using the EBK procedure, but this technique can use any arbitrary potential. In the hydrogen scattering example we build on this example and use the sample procedure to perform scattering simulations starting from this distribution.","category":"page"},{"location":"initialconditions/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"@info \"Expanding src/dynamicssimulations/dynamicssimulations.md...\"\nstart_time = time()","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/#dynamicssimulations","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"Performing dynamics simulations is at the core of this package's functionality (as you might have guessed from the name). This section of the documentation will describe how to perform dynamics simulations, building on the introduction from Getting started.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"Since we use DifferentialEquations to perform the dynamics, it is most natural to split up the system parameters from the dynamics variables. This manifests itself as two separate data types: the Simulation, and the DynamicsVariables.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"info: Info\nIf you intend to implement a new dynamics method, we recommend reading DifferentialEquations.jl to understand more deeply how this package works.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"The Simulation holds all the static information about the system: the atoms, the model, the temperature, the cell and the dynamics method.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"using NQCDynamics # hide\natoms = Atoms(2000) # Single atom with mass = 2000 a.u.\nsim = Simulation{Ehrenfest}(atoms, TullyModelOne(); temperature=0, cell=InfiniteCell())","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"Here we have initialised the simulation parameters, including the default temperature and cell explicitly. sim takes the place of the p parameter seen throughout DifferentialEquations.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/#Simulation-Temperature","page":"Introduction","title":"Simulation Temperature","text":"","category":"section"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"The temperature of a simulation isn't used by some dynamics methods, but can always be included.  Methods such as Langevin dynamics or MDEF use temperature to determine the magnitude of random flucturations to preserve detailed balance. ","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"The temperature for a simulation can be provided in three ways:","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"Fixed temperature","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"This can be a number, either in atomic units or a Unitful quantity (e.g. 300u\"K\"). ","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"Temperature function","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"For time-dependent temperatures, the temperature can be set to a function. This function must take the time in Unitful u\"fs\" as an input and return a temperature in Unitful u\"K\". ","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"Different temperatures per atom","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"If different parts of the simulated system should be affected by different effective temperatures, a Vector of TemperatureSettings can be passed as the temperature argument.  However, only one temperature should be applied to each atom in the system. ","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/#DynamicsVariables","page":"Introduction","title":"DynamicsVariables","text":"","category":"section"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"For DifferentialEquations to allow for a wide variety of solvers,  the input arrays DynamicsVariables must be AbstractArrays. In nonadiabatic dynamics simulations, we usually have different groups of variables that behave in particular ways. For example: for mapping variable methods we have positions, velocities, and two sets of mapping variables representing the electronic degrees of freedom.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"For this purpose we use the ComponentVector, which allows us to arbitrarily partition the variables into their subgroups. This allows us to keep all the variables in a single array as required by DifferentialEquations, whilst still having them partitioned for convenient computation and readable code.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"v0 = hcat(10) / 2000\nr0 = hcat(-5)\nu0 = DynamicsVariables(sim, v0, r0, PureState(1))","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"Since each dynamics method has a different set of variables, each method implements DynamicsVariables(sim, args...), which will convert the input into the correct structure. This helps to ensure each method follows a similar workflow, making it easy to switch between different methods. The output of this function takes the place of the u argument seen throughout DifferentialEquations.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/#Running-dynamics","page":"Introduction","title":"Running dynamics","text":"","category":"section"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"With both the Simulation and DynamicsVariables in hand, the central function is run_dynamics which allows us to perform a single dynamics trajectory. run_dynamics takes the simulation parameters sim and the initial conditions u0, along with a time span tspan that the trajectory will cover.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"tspan = (0.0, 2000.0)\nrun_dynamics(sim, tspan, u0; output=OutputDynamicsVariables, dt=1.0)","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"The output is a dictionary containing entries for :Time and our requested output quantity.  Output is a required keyword and the code will error unless at least one quantity is specified. By passing a Tuple to the output keyword argument we can ask for multiple quantities.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"out = run_dynamics(sim, tspan, u0; output=(OutputPosition, OutputAdiabaticPopulation), dt=1.0)","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"The quantities that are available are listed here. More quantities can be added by defining new functions with the signature f(sol, i). The first argument is the DifferentialEquations.jl solution object and the second is the trajectory index.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"This time we can see that the output contains the two quantities that we asked for.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"using Plots\nplot(out, :OutputPosition)","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"plot(out, :OutputAdiabaticPopulation)","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"note: Note\nHere we have used a special plot recipe that will automatically plot any quantity against time. This is useful when investigating the results of a single trajectory.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"All of the dynamics methods work in a similar way. For details on a specific method along with examples, please see the method specific page in the sidebar under Dynamics methods.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"runtime = round(time() - start_time; digits=2)\n@info \"...done after $runtime s.\"","category":"page"}]
}
