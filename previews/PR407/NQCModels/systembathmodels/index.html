<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>System-bath models · NQCDynamics.jl</title><meta name="title" content="System-bath models · NQCDynamics.jl"/><meta property="og:title" content="System-bath models · NQCDynamics.jl"/><meta property="twitter:title" content="System-bath models · NQCDynamics.jl"/><meta name="description" content="Documentation for NQCDynamics.jl."/><meta property="og:description" content="Documentation for NQCDynamics.jl."/><meta property="twitter:description" content="Documentation for NQCDynamics.jl."/><meta property="og:url" content="https://nqcd.github.io/NQCDynamics.jl/stable/NQCModels/systembathmodels/"/><meta property="twitter:url" content="https://nqcd.github.io/NQCDynamics.jl/stable/NQCModels/systembathmodels/"/><link rel="canonical" href="https://nqcd.github.io/NQCDynamics.jl/stable/NQCModels/systembathmodels/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="NQCDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NQCDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../getting_started/">Getting started</a></li><li><a class="tocitem" href="../../atoms/">Atoms</a></li><li><a class="tocitem" href="../../ensemble_simulations/">Ensemble simulations</a></li><li><a class="tocitem" href="../../saving_loading/">Saving and loading</a></li><li><span class="tocitem">NQCModels.jl</span><ul><li><a class="tocitem" href="../overview/">NQCModels.jl</a></li><li><a class="tocitem" href="../combining_models/">Composing multiple models</a></li><li><a class="tocitem" href="../combining_models/">Composing multiple models</a></li><li><a class="tocitem" href="../analyticmodels/">Analytic model library</a></li><li><a class="tocitem" href="../machinelearningmodels/">Machine learning interatomic potentials</a></li><li><a class="tocitem" href="../fullsizemodels/">Full dimensional model library</a></li><li><a class="tocitem" href="../frictionmodels/">Electronic friction models</a></li></ul></li><li><span class="tocitem">NQCDistributions.jl</span><ul><li><a class="tocitem" href="../../NQCDistributions/overview/">NQCDistributions.jl</a></li></ul></li><li><span class="tocitem">Initial conditions</span><ul><li><a class="tocitem" href="../../initialconditions/ebk/">Semiclassical EBK quantisation</a></li><li><a class="tocitem" href="../../initialconditions/hamiltonian/">Thermal Hamiltonian Monte Carlo</a></li><li><a class="tocitem" href="../../initialconditions/langevin/">Thermal Langevin dynamics</a></li><li><a class="tocitem" href="../../initialconditions/metropolishastings/">Thermal Metropolis-Hastings Monte Carlo</a></li></ul></li><li><span class="tocitem">Dynamics simulations</span><ul><li><a class="tocitem" href="../../dynamicssimulations/dynamicssimulations/">Introduction</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/classical/">Classical molecular dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/ehrenfest/">Ehrenfest molecular dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/fssh/">Fewest-switches surface hopping (FSSH)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/langevin/">Classical Langevin dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/mdef/">Molecular dynamics with electronic friction (MDEF)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/nrpmd/">Nonadiabatic ring polymer molecular dynamics (NRPMD)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/rpmd/">Ring polymer molecular dynamics (RPMD)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/rpsh/">Ring polymer surface hopping (RPSH)</a></li></ul></li><li><span class="tocitem">Outputs and Analysis</span><ul><li><a class="tocitem" href="../../output_and_analysis/intro/">Simulations outputs and analysis functions</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/reactive_scattering/">Reactive scattering from a metal surface</a></li><li><a class="tocitem" href="../../examples/spinboson/">Ohmic spin-boson nonequilibrium population dynamics</a></li><li><a class="tocitem" href="../../examples/threestatemorse/">Time-dependent populations with the ThreeStateMorse model</a></li><li><a class="tocitem" href="../../examples/tully_scattering/">Scattering probabilities for TullyModelTwo</a></li></ul></li><li><a class="tocitem" href="../../integration_algorithms/">Integration algorithms</a></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../../devdocs/diffeq/">DifferentialEquations.jl integration</a></li><li><a class="tocitem" href="../../devdocs/models/">Implementing a new model</a></li><li><a class="tocitem" href="../../devdocs/new_methods/">Contributing a new method</a></li></ul></li><li><span class="tocitem">API</span><ul><li><input class="collapse-toggle" id="menuitem-14-1" type="checkbox"/><label class="tocitem" for="menuitem-14-1"><span class="docs-label">NQCBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCBase/nqcbase/">NQCBase</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14-2" type="checkbox"/><label class="tocitem" for="menuitem-14-2"><span class="docs-label">NQCModels</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCModels/FrictionProviders/">FrictionModels</a></li><li><a class="tocitem" href="../../api/NQCModels/adiabaticmodels/">ClassicalModels</a></li><li><a class="tocitem" href="../../api/NQCModels/bathdiscretisations/">BathDiscretisations</a></li><li><a class="tocitem" href="../../api/NQCModels/diabaticmodels/">QuantumModels</a></li><li><a class="tocitem" href="../../api/NQCModels/frictionmodels/">FrictionProviders.jl</a></li><li><a class="tocitem" href="../../api/NQCModels/mace/">MACEModels.jl</a></li><li><a class="tocitem" href="../../api/NQCModels/nonadiabaticmodels/">NQCModels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14-3" type="checkbox"/><label class="tocitem" for="menuitem-14-3"><span class="docs-label">NQCDistributions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCDistributions/nqcdistributions/">NQCDistributions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14-4" type="checkbox"/><label class="tocitem" for="menuitem-14-4"><span class="docs-label">NQCDynamics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCDynamics/analysis/">Analysis</a></li><li><a class="tocitem" href="../../api/NQCDynamics/calculators/">NQCCalculators</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsmethods/">DynamicsMethods</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsoutputs/">DynamicsOutputs</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsutils/">DynamicsUtils</a></li><li><a class="tocitem" href="../../api/NQCDynamics/ensembles/">Ensembles</a></li><li><a class="tocitem" href="../../api/NQCDynamics/estimators/">Estimators</a></li><li><a class="tocitem" href="../../api/NQCDynamics/initialconditions/">InitialConditions</a></li><li><a class="tocitem" href="../../api/NQCDynamics/nonadiabaticmoleculardynamics/">NQCDynamics</a></li><li><a class="tocitem" href="../../api/NQCDynamics/numericutils/">Numerical utilities</a></li><li><a class="tocitem" href="../../api/NQCDynamics/ringpolymers/">RingPolymers</a></li><li><a class="tocitem" href="../../api/NQCDynamics/structure/">Structure</a></li><li><a class="tocitem" href="../../api/NQCDynamics/timecorrelationfunctions/">TimeCorrelationFunctions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14-5" type="checkbox"/><label class="tocitem" for="menuitem-14-5"><span class="docs-label">NQCDInterfASE</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCDInterfASE/ase-interface/">NQCDInterfASE</a></li></ul></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>System-bath models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>System-bath models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NQCD/NQCDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NQCD/NQCDynamics.jl/blob/main/docs/src/NQCModels/systembathmodels.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="System-bath-models"><a class="docs-heading-anchor" href="#System-bath-models">System-bath models</a><a id="System-bath-models-1"></a><a class="docs-heading-anchor-permalink" href="#System-bath-models" title="Permalink"></a></h1><p>This documentation is a collaborative work jointly authored by <a href="https://louhokseson.github.io">Xuexun Lu (Hok-seon)</a>, <a href="https://uk.linkedin.com/in/matthew-larkin-773307219">Matt Larkin</a> and <a href="https://scholar.google.com/citations?user=I65S8ZQAAAAJ&amp;hl=en">Nils Hertl</a>.</p><h3 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h3><p>When dealing with molecule-surface systems, wherein the surface is a metal or semi-conductor; the surface can be considered as an environmental bath that allows energy dissipation through coupling between the molecular &quot;system&quot; and the bath.</p><p>The effect that the bath has on the system is described by the bath spectral density, <span>$J(\varepsilon)$</span>, which can take various forms dependent on the method of energy coupling.</p><p>&lt;!– &gt;This is specifically for Newns-Anderson (and WideBandBath), Spin Boson samples frequency and state coupling values from the discretised bath instead of electronic energies.</p><blockquote><p>$</p><p>J(\varepsilon) = \int_{a}^{b} d\varepsilon&#39; \left| V(\varepsilon&#39;) \right|^{2} \delta(\varepsilon - \varepsilon&#39;) = \left| V(\varepsilon) \right|^{2} $ Where <span>$V(\varepsilon)$</span> is the &quot;coupling function&quot; which describes how the bath and system should be related at a given energy. –&gt;</p></blockquote><h2 id="Spin-Boson-model"><a class="docs-heading-anchor" href="#Spin-Boson-model">Spin-Boson model</a><a id="Spin-Boson-model-1"></a><a class="docs-heading-anchor-permalink" href="#Spin-Boson-model" title="Permalink"></a></h2><p>The Spin-Boson model consists of a 2 state system coupled to a bath of harmonic oscillators that treat the energy dissipation. The potential of the system is given below. $ V(\mathbf{\hat{R}}) =  \begin{pmatrix} \varepsilon + \mathbf{c}^{T} \mathbf{\hat{R}} &amp; \Delta\
\Delta &amp; - \varepsilon - \mathbf{c}^{T} \mathbf{\hat{R}} \end{pmatrix} + \frac{1}{2} \mathbf{\hat{R}}^{T} \mathbf{\Omega}^{2} \mathbf{\hat{R}}  $ The set of coupling coefficients (<span>$\mathbf{c} = \{c\}$</span>) and frequencies (<span>$\mathbf{\Omega} = \{\omega\}$</span>) of the bath harmonic modes required for this model are sampled from a discretisation of the bath spectral density, <span>$J(\omega)$</span>.</p><p>When defining the Spin-Boson model, 4 arguments are provided to the function:</p><pre><code class="language-julia hljs">using NQCModels
SpinBoson(density::SpectralDensity, N::Integer, ϵ, Δ)</code></pre><p>The first 2 arguments given detail the bath discretiation, the first being the type of bath, the second (<code>N</code>) indicates the number of discretised bath modes. From these arguements, the bath discretisation functions can return the set of frequencies , <span>$\Omega$</span> and coupling coefficients for each harmonic mode <span>$j$</span>.</p><p>The final 2 arguments <code>ϵ</code> and <code>Δ</code> define information about the 2 state system coupling to the bath. <code>ϵ</code> provides the energy bias between the two states and <code>Δ</code> the coupling between them (also referred to as the tunneling matrix element) [3].</p><p>Discretisations of the spectral density function have be implemented for two of the bath types that are prevelant in literature.</p><ul><li><strong>Ohmic</strong> bath (<code>OhmicSpectralDensity()</code>)</li><li><strong>Debye</strong> bath (<code>DebyeSpectralDensity()</code>, <code>AltDebyeSpectralDensity</code>)</li></ul><p>These functions are containers that store the relevant information needed to build a discretised bath. The actual construction and subsequent sampling is only done when <code>SpinBoson()</code> is called.</p><p>The following section details each bath discretisation method with examples of their implementation.</p><h3 id="Ohmic-bath"><a class="docs-heading-anchor" href="#Ohmic-bath">Ohmic bath</a><a id="Ohmic-bath-1"></a><a class="docs-heading-anchor-permalink" href="#Ohmic-bath" title="Permalink"></a></h3><p>The Ohmic bath spectral density function (for <span>$\omega \geq 0$</span>) takes the form: $ J(\omega) = \frac{\pi}{2} \alpha \omega e^{-\omega / \omega<em>{c}}   $ Where \omega</em>{c}$ is the characteristic frequency of the bath and <span>$\alpha$</span> is the Kondo parameter. These are provided as inputs to the function <code>OhmicSpectralDensity(ωᶜ,α)</code>.</p><p>The set of frequencies, <span>$\mathbf{\Omega}$</span>, and coupling coefficients, <span>$\mathbf{c}$</span>, are generated for the number of discretised bath modes, <span>$N_{b}$</span> provided. $ \begin{align}    \omega<em>{j} &amp;= - \omega</em>{c} \ln\left[ 1 - \frac{j}{(1 + N<em>{b})} \right] \
   c</em>{j} &amp;= \sqrt{\frac{\alpha \omega<em>{c}}{N</em>{b} + 1}} \omega_{j} \end{align} $</p><p>Where <span>$j=1,...,N_{b}$</span>.</p><h3 id="Debye-bath"><a class="docs-heading-anchor" href="#Debye-bath">Debye bath</a><a id="Debye-bath-1"></a><a class="docs-heading-anchor-permalink" href="#Debye-bath" title="Permalink"></a></h3><p>The Debye bath spectral density function takes the form: $ J(\omega) = 2 \lambda \frac{\omega<em>{c} \omega}{\omega</em>{c}^{2} + \omega^{2}}  $ Where <span>$\omega_{c}$</span> is the characteristic frequency of the bath and <span>$\lambda$</span> is the reorganisation. These are provided as inputs to the function <code>DebyeSpectralDensity(ωᶜ,λ)</code>.</p><p>The set of frequencies, <span>$\mathbf{\Omega}$</span>, and coupling coefficients, <span>$\mathbf{c}$</span>, are generated for the number of discretised bath modes, <span>$N_{b}$</span> provided. $ \begin{align}    \omega<em>{j} &amp;= \omega</em>{c} \tan\left( \frac{\pi}{2} \left(1 - \frac{j}{(1 + N<em>{b})} \right) \right) \
   c</em>{j} &amp;= \sqrt{\frac{2 \lambda}{N<em>{b} + 1}} \omega</em>{j} \end{align} $</p><p>Where <span>$j=1,...,N_{b}$</span>.</p><p>&lt;!– This fucntion is in the code but hasn&#39;t been exported. –&gt; &lt;!– An alternative Debye bath discretisation has also been implemented that includes an additional cuttoff frequency, <code>ωᵐ</code>. The inputs to this function are <code>AltDebyeSpectralDensity(ωᶜ,λ,ωᵐ)</code>.</p><p>The set of frequencies and coupling coefficients are again generated for the number of discretised bath modes, <span>$N_{b}$</span> provided. $ \begin{align}    \omega<em>{j} &amp;= \omega</em>{c} \tan\left(j \frac{\arctan\left(\omega<em>{m}/\omega</em>{c}\right)}{N<em>{b}} \right) \
   c</em>{j} &amp;= \sqrt{\frac{4 \lambda \arctan\left(\omega<em>{m}/\omega</em>{c}\right)}{\pi N<em>{b}}} \omega</em>{j} \end{align} $</p><p>Where <span>$j=1,...,N_{b}$</span>. –&gt;</p><h2 id="Newns-Anderson-model"><a class="docs-heading-anchor" href="#Newns-Anderson-model">Newns-Anderson model</a><a id="Newns-Anderson-model-1"></a><a class="docs-heading-anchor-permalink" href="#Newns-Anderson-model" title="Permalink"></a></h2><p>The <strong>Anderson Impurity Model (AIM)</strong> describes a localized impurity state interacting with a continuous band of bath states. AIM is a foundamental model in condensed matter physics and quantum chemistry, introduced by P.W. Anderson in 1961. The <strong>Newns-Anderson model</strong> is a generalization of the AIM, which includes the possibility of <strong>multiple impurity states</strong> and a more complex interaction with the bath. A key advantage of using the AIM lies in its ability to yield <strong>analytical solutions</strong> for the energy level distribution and the hybridization (coupling) density, making it a powerful tool for theoretical analysis.</p><h4 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h4><p>The <strong>total Hamiltonian</strong> <span>$H$</span> of the AIM can be written as: $ H = H<em>{S} + H</em>{B} + H_{C} $</p><h5 id="Impurity"><a class="docs-heading-anchor" href="#Impurity">Impurity</a><a id="Impurity-1"></a><a class="docs-heading-anchor-permalink" href="#Impurity" title="Permalink"></a></h5><p>The <strong>Impurity Hamiltonian</strong> describes the localized orbitals:</p><p class="math-container">\[H_{S} = \sum_{i} \varepsilon_{i} d_{i}^{\dagger} d_{i}\]</p><p>Here:</p><ul><li><p class="math-container">\[\varepsilon_{i}\]</p>is the energy of the <span>$i$</span>-th impurity orbital.</li><li><p class="math-container">\[d_i^{\dagger}, d_i\]</p>: creation/annihilation operators for orbital i</li></ul><p>For the specific case of a <strong>two-state impurity system</strong>, the system Hamiltonian can be expressed as:</p><p class="math-container">\[H_{S} = h \cdot d^{\dagger} d + U_0\]</p><p>In this two-state representation:</p><ul><li><p class="math-container">\[U_0\]</p>: energy of state 0</li><li><p class="math-container">\[U_1\]</p>: energy of state 1</li><li><p class="math-container">\[h\]</p>: the energy gap <span>$U_1 -U_0$</span></li></ul><h5 id="Bath"><a class="docs-heading-anchor" href="#Bath">Bath</a><a id="Bath-1"></a><a class="docs-heading-anchor-permalink" href="#Bath" title="Permalink"></a></h5><p>Describes a reservoir of states which are non-interacting and intrisically existing. The bath states can be phonons or electrons in surfaces. Usually written as $ H<em>B = \sum</em>{k} \epsilon<em>k c</em>k^{\dagger} c_k $</p><ul><li><p class="math-container">\[\epsilon_k\]</p>: energy of bath state <span>$k$</span>  </li><li><p class="math-container">\[c_{k}^\dagger, c_{k}\]</p>: creation/annihilation operators for state <span>$k$</span></li></ul><h5 id="Interaction"><a class="docs-heading-anchor" href="#Interaction">Interaction</a><a id="Interaction-1"></a><a class="docs-heading-anchor-permalink" href="#Interaction" title="Permalink"></a></h5><p>Captures the coupling between the impurity and the bath states. The interaction Hamiltonian can be expressed as: $ H<em>{C} = \sum</em>{i,k} V<em>{ik} d</em>i^{\dagger} c<em>k + V</em>{ik}^{*} c<em>k^{\dagger} d</em>i $</p><p>where <span>$V$</span> stands for the coupling strength.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>To build a Newns-Anderson model in NQCModels.jl, you can use the <a href="../../api/NQCModels/diabaticmodels/#NQCModels.QuantumModels.AndersonHolstein"><code>AndersonHolstein</code></a>:</p><pre><code class="language-julia hljs">using NQCModels
...
NAmodel = AndersonHolstein(quantummodel, bath; couplings_rescale)</code></pre><p>The <code>quantummodel</code> belongs to <a href="../../api/NQCModels/diabaticmodels/#QuantumModels"><code>QuantumModels</code></a> is a system model describling the system Hamiltonian <span>$H_S$</span> and the <code>bath</code> is a set of energy states (and their couplings to the system) that represent the environmental bath, generated by some discretisation scheme. The <a href="../../api/NQCModels/diabaticmodels/#NQCModels.QuantumModels.AndersonHolstein"><code>couplings_rescale</code></a> is a scalar parameter that rescales the coupling strengths to the bath states. And the <code>bath</code> is a collection of bath states.</p><h2 id="Discretisation-of-bath"><a class="docs-heading-anchor" href="#Discretisation-of-bath">Discretisation of bath</a><a id="Discretisation-of-bath-1"></a><a class="docs-heading-anchor-permalink" href="#Discretisation-of-bath" title="Permalink"></a></h2><p>Some mixed quantum classical dynamics methods that deal with system-bath simulations require the discretisation of the bath spectral density, <span>$J(\varepsilon)$</span>, into a finite number of discrete energy levels such that the individual state couplings are excplicitly considered during propagation. i.e. <a href="../../api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AdiabaticIESH">Independent electron surface hopping</a> [1] [2].</p><p>The bath spectral density here is given by the following integral: $ J(\varepsilon) = \int<em>{a}^{b} d\varepsilon&#39; \left| V(\varepsilon&#39;) \right|^{2} \delta(\varepsilon - \varepsilon&#39;) = \left| V(\varepsilon) \right|^{2} $ Where <span>$V(\varepsilon)$</span> is the &quot;coupling function&quot; which describes how the bath and system should be related at a given energy [4]. Discretising this over a set of <span>$N$</span> bath states gives the following form: $ J^{discr}(\varepsilon) = \sum</em>{n=1}^{N} \left|V<em>{n}\right|^{2} \delta \left( \varepsilon - \varepsilon</em>{n} \right) $ Where <span>$V_{n}$</span> is the coupling contribution at state n. </p><h4 id="Discretisation-under-wide-band-limit"><a class="docs-heading-anchor" href="#Discretisation-under-wide-band-limit">Discretisation under wide band limit</a><a id="Discretisation-under-wide-band-limit-1"></a><a class="docs-heading-anchor-permalink" href="#Discretisation-under-wide-band-limit" title="Permalink"></a></h4><p>The <strong>Wide Band Limit (WBL)</strong> is a common approximation which considers the bath spectral density to be constant over a wide range of energies. This allows in the case of direct discretisation of the bath spectral density function, <span>$J(\varepsilon)$</span>, that the coupling associated with each state is simply related to the energy spacing between itself and its neighbouring state.</p><h4 id="Discretisation-with-constant-spacing"><a class="docs-heading-anchor" href="#Discretisation-with-constant-spacing">Discretisation with constant spacing</a><a id="Discretisation-with-constant-spacing-1"></a><a class="docs-heading-anchor-permalink" href="#Discretisation-with-constant-spacing" title="Permalink"></a></h4><p>The simpliest choice for discretising the bath spectral density is to represent the bath as a set of <code>N</code> evenly spaced energy states according to a trapezoidal integration rule. </p><p>This is implemented as <code>TrapezoidalRule()</code> which takes the following arguements:</p><pre><code class="language-julia hljs">using NQCModels
TrapezoidalRule(M, bandmin, bandmax)</code></pre><p>Where:</p><ul><li><code>M</code> = number of discretised bath states to be generated</li><li><code>bandmin</code> / <code>bandmax</code> = miniumum / maximum energies that define the bath energy range</li></ul><p>The discretised bath energy states, <span>$\varepsilon_{n}$</span>, and coupling elements, <span>$V_{n}$</span>, are calculated as follows: $ \begin{align<em>}    \varepsilon<em>{n} &amp;= a + \frac{(n - 1)(b - a)}{M - 1} \
   V</em>{n} &amp;= V(\varepsilon<em>{n})\sqrt{(b-a)/(M-1)} = \sqrt{\Delta \varepsilon</em>{n}} \end{align</em>} $  Where:</p><ul><li><p class="math-container">\[n\]</p>= index of the discretised state</li><li><p class="math-container">\[a\]</p>= minimum energy of bath discretisation (<code>bandmin</code>)</li><li><p class="math-container">\[b\]</p>= maximum energy of bath discretisation (<code>bandmax</code>)</li><li><p class="math-container">\[M\]</p>= number of bath states in the discretisation (<code>M</code>)</li><li><p class="math-container">\[\Delta \varepsilon_{n}\]</p>is the spacing between the <span>$n$</span> discretised energy states </li><li><p class="math-container">\[V(\varepsilon_{n})\]</p>is the coupling function evaluated at the <span>$n$</span> discretised energy states</li></ul><p>When making the Wide Band Limit approximation however, the coupling function, <span>$V(\varepsilon)$</span>, is independent of energy, <span>$\varepsilon$</span>. Taking <span>$V(\varepsilon_{n})$</span> as an arbitrary constant allows the simplification: $ \left| V<em>{n} \right|^{2} = \left| V(\varepsilon</em>{n}) \right|^{2} \Delta \varepsilon<em>{n} \approx \Delta \varepsilon</em>{n} $</p><p>This discretisation method is effective and given enough states will always accurately represent the spectral density, but methods such as IESH using this discretisation scheme will suffer from long computation times as the number of bath states <span>$M$</span> increases. </p><blockquote><p>[!note]</p></blockquote><p>Typically keeping <span>$M&lt;100$</span> for this discretisation scheme is sensible.</p><h4 id="Discretisation-by-Gauss-Legendre-quadrature"><a class="docs-heading-anchor" href="#Discretisation-by-Gauss-Legendre-quadrature">Discretisation by Gauss-Legendre quadrature</a><a id="Discretisation-by-Gauss-Legendre-quadrature-1"></a><a class="docs-heading-anchor-permalink" href="#Discretisation-by-Gauss-Legendre-quadrature" title="Permalink"></a></h4><p>To address the computational scaling issues with constant spacing methods, and allow for both low and high energy regions to be accurately described simultaneously, a discretisation of the spectral density function integral was generated using Gauss-Legendre quadrature to determine:</p><ul><li>energy states (<span>$\varepsilon_{n}$</span>) <span>$\leftarrow$</span> rescaled nodes (<span>$\epsilon_{n}$</span>)</li><li>coupling elements (<span>$V_{n}$</span>) <span>$\leftarrow$</span> rescaled weights (<span>$\tilde{w}_{n}$</span>) </li></ul><blockquote><p>[!note] The rescaled weights here <span>$\tilde{w}_{n}$</span>, fill the role of <span>$\Delta \varepsilon_{n}$</span> as described above for the Trapezoidal Rule discretisation.  <span>$\left| V_{n} \right|^{2} = \left| V(\epsilon_{n}) \right|^{2} \tilde{w}_{n} \approx \tilde{w}_{n}$</span></p></blockquote><p>Implemented here as <code>ShenviGaussLegendre()</code> is the method developed by Shenvi et al in 2009, where Gauss-Legendre quadrature was used to discretise the bath in two halves, separated at the Fermi level [1].  This function takes the following arguments:</p><pre><code class="language-julia hljs">using NQCModels
ShenviGaussLegendre(M, bandmin, bandmax)</code></pre><p>The rescaled knots, <span>$x_{n}$</span>, and weights, <span>$w_{n}$</span>, are given by the following scaling related to the value of the Fermi level, <span>$\epsilon_{n}$</span>. $ \begin{align<em>}    \epsilon<em>{n} &amp;=    \begin{cases}       \frac{1}{2}(\epsilon</em>{f} - a) x<em>{n} + \frac{1}{2}(a + \epsilon</em>{f}) \qquad n \leq M/2\
      \frac{1}{2}(b - \epsilon<em>{f}) x</em>{n} + \frac{1}{2}(\epsilon<em>{f} - b) \qquad n \geq M/2    \end{cases}\
   \tilde{w}</em>{n} &amp;=    \begin{cases}       \frac{1}{2}(\epsilon<em>{f} - a) w</em>{n} \qquad n \leq M/2\
      \frac{1}{2}(b - \epsilon<em>{f}) w</em>{n} \qquad n \geq M/2    \end{cases}\
\end{align</em>} $ Where:</p><ul><li><p class="math-container">\[\epsilon_{f}\]</p>= Fermi level</li><li><p class="math-container">\[x_{n}\]</p>= knots obtained from Guass-Legendre quadrature</li><li><p class="math-container">\[w_{n}\]</p>= weights obtained from Gauss-Legendre quadrature</li><li><p class="math-container">\[a\]</p>= minimum energy of bath discretisation (<code>bandmin</code>)</li><li><p class="math-container">\[b\]</p>= maximum energy of bath discretisation (<code>bandmax</code>)</li><li><p class="math-container">\[M\]</p>= number of bath states in the discretisation (<code>M</code>)</li></ul><p>By supplying a value for the fermi level, the dense discretisation region is shifted to be centred on a different region of the energy range that may benefit from being well described during a calculation.</p><h4 id="Discretisation-with-a-gap"><a class="docs-heading-anchor" href="#Discretisation-with-a-gap">Discretisation with a gap</a><a id="Discretisation-with-a-gap-1"></a><a class="docs-heading-anchor-permalink" href="#Discretisation-with-a-gap" title="Permalink"></a></h4><p>Two numerical discretisation methods which performs a band gap in the middle of the continuum are introduced and named as <a href="../../api/NQCModels/bathdiscretisations/#NQCModels.BathDiscretisations.GapTrapezoidalRule"><code>GapTrapezoidalRule</code></a> and <a href="../../api/NQCModels/bathdiscretisations/#NQCModels.BathDiscretisations.GapGaussLegendre"><code>GapGaussLegendre</code></a>.</p><pre><code class="language-julia hljs">using NQCModels
gapbath_T = GapTrapezoidalRule(nstates, bandmin_val, bandmax_val, bandgap)
gapbath_G = GapGaussLegendre(nstates, bandmin_val, bandmax_val, bandgap)</code></pre><h5 id="Gapped-Trapezoidal-Rule"><a class="docs-heading-anchor" href="#Gapped-Trapezoidal-Rule">Gapped Trapezoidal Rule</a><a id="Gapped-Trapezoidal-Rule-1"></a><a class="docs-heading-anchor-permalink" href="#Gapped-Trapezoidal-Rule" title="Permalink"></a></h5><p>The <em>Gapped Trapezoidal</em> Rule discretises a band into two evenly spaced continuums, which is particularly useful for systems with a band gap, such as semiconductors.</p><p>The energy <span>$\epsilon_k$</span> for each discretised state <span>$k$</span> is defined as:</p><p>$</p><p>\epsilon<em>k = \begin{cases}E</em>{\text{F}} - \Delta E + (k-1) \times \frac{\Delta E - E<em>{\text{gap}}}{M} &amp;\text { if } k \leq M/2 \ E</em>{\text{F}} + \frac{E<em>{\text{gap}}}{2} + (k-M/2 -1) \times \frac{\Delta E - E</em>{\text{gap}}}{M}&amp;\text { otherwise }\end{cases} $</p><p>These states are associated with constant coupling weights <span>$\omega_k$</span>:</p><p class="math-container">\[\omega_k = \frac{\Delta E - E_{\text{gap}}}{M}\]</p><p>where:</p><ul><li><p class="math-container">\[\Delta E\]</p>is the total energy range of the bath.</li><li><p class="math-container">\[E_{\text{gap}}\]</p>is the size of the gap located in the middle of the band.</li><li><p class="math-container">\[E_{\text{F}}\]</p>is the Fermi energy.</li><li><p class="math-container">\[M\]</p>is the total number of discretised states.</li></ul><h5 id="Gapped-Gauss-Legendre"><a class="docs-heading-anchor" href="#Gapped-Gauss-Legendre">Gapped Gauss Legendre</a><a id="Gapped-Gauss-Legendre-1"></a><a class="docs-heading-anchor-permalink" href="#Gapped-Gauss-Legendre" title="Permalink"></a></h5><p>The <em>Gapped Gauss-Legendre</em> discretization, unlike the Gapped Trapezoidal method, creates a band with a high density of states around the band gap, using a scheme adapted from the Legendre quadrature method.</p><p>The discretisation for the energy <span>$\epsilon_k$</span> of each state <span>$k$</span> is defined as follows:</p><p>$</p><p>\epsilon<em>k = \begin{cases}E</em>{\text{F}} - \left[\frac{\Delta E-E<em>{\text{gap}}}{2} (1+x</em>{\text L,M/2-k+1}) + E<em>{\text{gap}}\right]/2 &amp;\text { if } k \leq M/2 \
E</em>{\text{F}} + \left[\frac{\Delta E-E<em>{\text{gap}}}{2} (1+x</em>{\text L,k-M/2}) + E_{\text{gap}}\right]/2&amp;\text { otherwise }\end{cases} $</p><p>with conjugate weights:</p><p>$</p><p>\omega<em>k = \begin{cases} \Delta E w</em>{\text{L},M/2-k+1} /2 &amp;\text { if } k \leq M/2 \
\Delta E w_{\text{L},k-M/2} /2 &amp;\text { otherwise } \end{cases} $</p><p><strong>Parameters:</strong></p><ul><li><p class="math-container">\[x_{\text{L},i}\]</p>and <span>$\omega_{\text{L},i}$</span>: These represent the knot points and weights, respectively, obtained from Legendre quadrature over the interval <span>$[-1,1]$</span>. For this formulation, <span>$M/2$</span> knots are used.</li><li><p class="math-container">\[E_{\text{F}}\]</p>: The Fermi level, which is typically set to 0 eV or the centre of the continuum band.</li><li><p class="math-container">\[M\]</p>: The total number of discretisation points. It is crucial that <span>$M$</span> is an even number for this formulation to be valid.</li><li><p class="math-container">\[\Delta E\]</p>: The total width of the continuum band.</li><li><p class="math-container">\[E_{\text{gap}}\]</p>: The size of the band gap.</li></ul><h5 id="Gapped-discretisation-examples"><a class="docs-heading-anchor" href="#Gapped-discretisation-examples">Gapped discretisation examples</a><a id="Gapped-discretisation-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Gapped-discretisation-examples" title="Permalink"></a></h5><p>To build a discretised bath with a gap in the middle, you can use the <a href="../../api/NQCModels/bathdiscretisations/#NQCModels.BathDiscretisations.GapTrapezoidalRule"><code>GapTrapezoidalRule</code></a> or <a href="../../api/NQCModels/bathdiscretisations/#NQCModels.BathDiscretisations.GapGaussLegendre"><code>GapGaussLegendre</code></a> methods. &lt;p align=&quot;center&quot;&gt;   &lt;img src=&quot;../assets/system-bath-model/DOS<em>bath</em>discretisation<em>compare</em>test.svg&quot; alt=&quot;Discretisation with a gap&quot; style=&quot;display: block; margin: 0 auto;&quot;&gt; &lt;/p&gt;</p><p>The Julia script to reproduce the above figure is available in the <a href="../../assets/system-bath-model/plot_bath_DOS.jl">plot<em>bath</em>DOS.jl</a>.</p><h4 id="Discretisation-with-a-&quot;Window&quot;-region"><a class="docs-heading-anchor" href="#Discretisation-with-a-&quot;Window&quot;-region">Discretisation with a &quot;Window&quot; region</a><a id="Discretisation-with-a-&quot;Window&quot;-region-1"></a><a class="docs-heading-anchor-permalink" href="#Discretisation-with-a-&quot;Window&quot;-region" title="Permalink"></a></h4><p>The windowed discretisation method generates a dense region of states within a user specified energy &quot;window&quot;, and a sparse discretisation elsewhere. The density of this region is controlled through an optional keyword parameter <code>densityratio</code> which takes a default value of <code>0.5</code>. This is defined as the ratio <span>$N_{\textrm{States in Window}} / N_{\textrm{Total States}}$</span>. </p><p>This discretisation is selected for by the function <code>WindowedTrapezoidalRule()</code> which takes the following arguements:</p><pre><code class="language-julia hljs">using NQCModels
WindowedTrapezoidalRule(M, bandmin, bandmax, windmin, windmax, densityratio=0.50)</code></pre><p>Where:</p><ul><li><code>M</code> = number discretised bath states</li><li><code>bandmin</code> / <code>bandmax</code> = minimum / maximum values of bath discretisation energy range</li><li><code>windmin</code> / <code>windmax</code> = minimum / maximum energy values of window region in bath discretisation</li><li><code>densityratio</code> = ratio between the number of states in the window region to the total number of discretised bath states</li></ul><p>The discretised bath states and the associated couplings are calculated using the trapezoidal rule in each region, with the energy spacing between the window and sparse regions given by <span>$\Delta \varepsilon_{\textrm{join}} = \frac{1}{2}(\Delta \varepsilon_{\textrm{win}} + \Delta \varepsilon_{\textrm{sparse}})$</span>: $ \begin{align<em>} \varepsilon<em>{n} &amp;=     \begin{cases}       a^{win} + \frac{(n - 1)(b^{win} - a^{win})}{\eta M - 1} &amp;\qquad n^{win}</em>{-} &lt; n \leq n^{win}<em>{+} \        b^{win} + \Delta \varepsilon</em>{join} + \frac{(n - 1)(b - b^{win} - \Delta \varepsilon<em>{join})}{n^{win}</em>{-} - 1} &amp;\qquad  n &gt; n^{win}<em>{+} \
      a - \Delta \varepsilon</em>{join} + \frac{(n - 1)(b^{win} - a - \Delta \varepsilon<em>{join})}{n^{win}</em>{-} - 1} &amp;\qquad n &lt; n^{win}<em>{-}    \end{cases}\     V</em>{n} &amp;=     \begin{cases}       V(\varepsilon<em>{n})\sqrt{(b^{win} - a^{win})/(\eta M - 1)} = \sqrt{\Delta \varepsilon</em>{n}^{win}} &amp;\qquad n^{win}<em>{-} &lt; n \leq n^{win}</em>{+} \        V(\varepsilon<em>{n})\sqrt{(2b - 2b^{win} - \Delta \varepsilon^{win})/(2n^{win}</em>{-} - 1)} = \sqrt{\Delta \varepsilon<em>{n}^{sp}} &amp;\qquad n \leq n^{win}</em>{-} \; \textrm{and} \; n&gt;n^{win}_{+}    \end{cases} \end{align</em>} $ &lt;!– ^ this needs rephrased, need to work out a way to represent how the energy states and couplings are calculated for the windowed region, sparse region and joining of the two. –&gt;</p><p>Where:</p><ul><li><p class="math-container">\[n^{win}_{\mp} = M(1 \mp \eta)/2:\]</p>are the state indices that define the window region (<span>$n^{win}_{-}$</span> is also equivalent to the number of states in the sparse region)</li><li><p class="math-container">\[\eta\]</p>= density ratio (<code>densityratio</code>) which defines the proportion of states within the window relative to the total number of discretised states. <span>$M^{win} = \eta M$</span></li><li><p class="math-container">\[a\]</p>= minimum energy of bath discretisation (<code>bandmin</code>)</li><li><p class="math-container">\[b\]</p>= maximum energy of bath discretisation (<code>bandmax</code>)</li><li><p class="math-container">\[a^{win}\]</p>= minimum energy of the window region in the bath discretisation (<code>windmin</code>)</li><li><p class="math-container">\[b^{win}\]</p>= maximum energy of the window region in the bath discretisation (<code>windmax</code>)</li></ul><p>This method allows the user to finely discretise the electronic bath states over a larger energy range than can be achieved with the Gauss-Legendre quadrature method, without resorting to use a trapezoidal rule discretisation with many states. Hence, saving computation time. The motivation for such a discretisation was to provide a better energy grid for the bath such that a non-equlibrium electronic distribution with a complex shape could be more accurately sampled from. </p><p>&lt;!– #### How to implement and develop your own discretisation –&gt;</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1] N. Shenvi, S. Roy, and J. C. Tully, &quot;Nonadiabatic dynamics at metal surfaces: Independent-electron surface hopping&quot;, <em>J. Chem. Phys.</em> <strong>130</strong>, 174707 (2009). <a href="https://doi.org/10.1063/1.3125436">DOI: 10.1063/1.3125436</a></p><p>[2] J. Gardner, D. Corken, S. M. Janke, S. Habershon, and R. J. Maurer, &quot;Efficient implementation and performance analysis of the independent electron surface hopping method for dynamics at metal surfaces&quot;, <em>J. Chem. Phys.</em> <strong>158</strong>, 064101 (2023). <a href="https://doi.org/10.1063/5.0137137">DOI: 10.1063/5.0137137</a></p><p>[3] X. He and J. Liu, &quot;A new perspective for nonadiabatic dynamics with phase space mapping models&quot;, <em>J. Chem. Phys.</em> <strong>151</strong>, 024105 (2019). <a href="https://doi.org/10.1063/1.5108736">DOI: 10.1063/1.5108736</a></p><p>[4] I. de Vega, U. Schollwöck and F. A. Wolf, &quot;How to discretize a quantum bath for real-time evolution&quot;, <em>Phys. Rev. B</em> <strong>92</strong>, 155126 (2015). <a href="https://doi.org/10.1103/PhysRevB.92.155126">DOI: 10.1103/PhysRevB.92.155126</a> </p><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 15 July 2025 14:16">Tuesday 15 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
