<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integration algorithms · NQCDynamics.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://nqcd.github.io/NQCDynamics.jl/stable/integration_algorithms/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="NQCDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">NQCDynamics.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../atoms/">Atoms</a></li><li><a class="tocitem" href="../ensemble_simulations/">Ensemble simulations</a></li><li><a class="tocitem" href="../saving_loading/">Saving and loading</a></li><li><span class="tocitem">NQCModels.jl</span><ul><li><a class="tocitem" href="../NQCModels/overview/">NQCModels.jl</a></li><li><a class="tocitem" href="../NQCModels/analyticmodels/">Analytic model library</a></li><li><a class="tocitem" href="../NQCModels/ase/">ASE interface</a></li><li><a class="tocitem" href="../NQCModels/neuralnetworkmodels/">Neural network models</a></li><li><a class="tocitem" href="../NQCModels/frictionmodels/">Electronic friction models</a></li></ul></li><li><span class="tocitem">NQCDistributions.jl</span><ul><li><a class="tocitem" href="../NQCDistributions/overview/">NQCDistributions.jl</a></li></ul></li><li><span class="tocitem">Initial conditions</span><ul><li><a class="tocitem" href="../initialconditions/ebk/">Semiclassical EBK quantisation</a></li><li><a class="tocitem" href="../initialconditions/hamiltonian/">Thermal Hamiltonian Monte Carlo</a></li><li><a class="tocitem" href="../initialconditions/langevin/">Thermal Langevin dynamics</a></li><li><a class="tocitem" href="../initialconditions/metropolishastings/">Thermal Metropolis-Hastings Monte Carlo</a></li></ul></li><li><span class="tocitem">Dynamics simulations</span><ul><li><a class="tocitem" href="../dynamicssimulations/dynamicssimulations/">Introduction</a></li><li><a class="tocitem" href="../dynamicssimulations/dynamicsmethods/classical/">Classical molecular dynamics</a></li><li><a class="tocitem" href="../dynamicssimulations/dynamicsmethods/ehrenfest/">Ehrenfest molecular dynamics</a></li><li><a class="tocitem" href="../dynamicssimulations/dynamicsmethods/fssh/">Fewest-switches surface hopping (FSSH)</a></li><li><a class="tocitem" href="../dynamicssimulations/dynamicsmethods/langevin/">Classical Langevin dynamics</a></li><li><a class="tocitem" href="../dynamicssimulations/dynamicsmethods/mdef/">Molecular dynamics with electronic friction (MDEF)</a></li><li><a class="tocitem" href="../dynamicssimulations/dynamicsmethods/nrpmd/">Nonadiabatic ring polymer molecular dynamics (NRPMD)</a></li><li><a class="tocitem" href="../dynamicssimulations/dynamicsmethods/rpmd/">Ring polymer molecular dynamics (RPMD)</a></li><li><a class="tocitem" href="../dynamicssimulations/dynamicsmethods/rpsh/">Ring polymer surface hopping (RPSH)</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/reactive_scattering/">Reactive scattering from a metal surface</a></li><li><a class="tocitem" href="../examples/spinboson/">Ohmic spin-boson nonequilibrium population dynamics</a></li><li><a class="tocitem" href="../examples/threestatemorse/">Time-dependent populations with the ThreeStateMorse model</a></li><li><a class="tocitem" href="../examples/tully_scattering/">Scattering probabilities for TullyModelTwo</a></li></ul></li><li class="is-active"><a class="tocitem" href>Integration algorithms</a><ul class="internal"><li><a class="tocitem" href="#Ring-polymer-propagation"><span>Ring polymer propagation</span></a></li><li><a class="tocitem" href="#Mixed-quantum-classical-propagation"><span>Mixed quantum-classical propagation</span></a></li><li><a class="tocitem" href="#Semiclassical-mapping-variable-propagation"><span>Semiclassical mapping variable propagation</span></a></li><li><a class="tocitem" href="#Electronic-friction-propagation"><span>Electronic friction propagation</span></a></li></ul></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../devdocs/diffeq/">DifferentialEquations.jl integration</a></li><li><a class="tocitem" href="../devdocs/models/">Implementing a new model</a></li><li><a class="tocitem" href="../devdocs/new_methods/">Contributing a new method</a></li></ul></li><li><span class="tocitem">API</span><ul><li><input class="collapse-toggle" id="menuitem-13-1" type="checkbox"/><label class="tocitem" for="menuitem-13-1"><span class="docs-label">NQCBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/NQCBase/nqcbase/">NQCBase</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13-2" type="checkbox"/><label class="tocitem" for="menuitem-13-2"><span class="docs-label">NQCModels</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/NQCModels/adiabaticmodels/">AdiabaticModels</a></li><li><a class="tocitem" href="../api/NQCModels/cubeldfamodel/">CubeLDFAModel</a></li><li><a class="tocitem" href="../api/NQCModels/diabaticmodels/">DiabaticModels</a></li><li><a class="tocitem" href="../api/NQCModels/frictionmodels/">FrictionModels</a></li><li><a class="tocitem" href="../api/NQCModels/nninterfaces/">NNInterfaces</a></li><li><a class="tocitem" href="../api/NQCModels/nonadiabaticmodels/">NQCModels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13-3" type="checkbox"/><label class="tocitem" for="menuitem-13-3"><span class="docs-label">NQCDistributions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/NQCDistributions/nqcdistributions/">NQCDistributions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13-4" type="checkbox"/><label class="tocitem" for="menuitem-13-4"><span class="docs-label">NQCDynamics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/NQCDynamics/calculators/">Calculators</a></li><li><a class="tocitem" href="../api/NQCDynamics/dynamicsmethods/">DynamicsMethods</a></li><li><a class="tocitem" href="../api/NQCDynamics/dynamicsoutputs/">DynamicsOutputs</a></li><li><a class="tocitem" href="../api/NQCDynamics/dynamicsutils/">DynamicsUtils</a></li><li><a class="tocitem" href="../api/NQCDynamics/ensembles/">Ensembles</a></li><li><a class="tocitem" href="../api/NQCDynamics/estimators/">Estimators</a></li><li><a class="tocitem" href="../api/NQCDynamics/initialconditions/">InitialConditions</a></li><li><a class="tocitem" href="../api/NQCDynamics/nonadiabaticmoleculardynamics/">NQCDynamics</a></li><li><a class="tocitem" href="../api/NQCDynamics/ringpolymers/">RingPolymers</a></li><li><a class="tocitem" href="../api/NQCDynamics/timecorrelationfunctions/">TimeCorrelationFunctions</a></li></ul></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Integration algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Integration algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NQCD/NQCDynamics.jl/blob/main/docs/src/integration_algorithms.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Integration-algorithms"><a class="docs-heading-anchor" href="#Integration-algorithms">Integration algorithms</a><a id="Integration-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-algorithms" title="Permalink"></a></h1><p>At the core of NQCDynamics.jl is the DifferentialEquations.jl package that performs all of the dynamics simulations. Within the sub-packages OrdinaryDiffEq.jl and StochasticDiffEq.jl, a variety of integration algorithms have been implemented that are available to use without needing to implement custom algorithms for specific applications.  However, in some cases it can be desirable to implement algorithms that can take advantage of the special structure of the dynamical system at hand. A key example in the field of molecular dynamics is the famous velocity Verlet algorithm that is extremely popular due to its requirement for only a single force evaluation during each time step and symplectic energy conservation properties. In fact, velocity Verlet, along with a variety of other symplectic solvers are also implemented within OrdinaryDiffEq.jl.</p><p>For some problems encountered within semiclassical adiabatic and nonadiabatic dynamics, there are a few different algorithms that can be used to obtain improved performance. Ideally, these would be implemented using the DifferentialEquations.jl interface to allow for others to easily use these algorithms for their own problems. However, it can be challenging to implement algorithms with an appropriate level of generality. NQCDynamics.jl contains implementations for a few algorithms using the DifferentialEquations.jl interface but the implementations are not completely generic and are coupled to the rest of the package. In particular, the algorithms rely on specific formats for the dynamical arrays and use some functions that are not provided within the <code>DEProblem</code>. In future it would be great to try to decouple the algorithms and package them separately within the DifferentialEquations.jl ecosystem so that others can use them more easily.</p><p>This page describes a few applications where special algorithms are available to enhance performance. In each section it is noted which algorithms are available within NQCDynamics.jl.</p><h2 id="Ring-polymer-propagation"><a class="docs-heading-anchor" href="#Ring-polymer-propagation">Ring polymer propagation</a><a id="Ring-polymer-propagation-1"></a><a class="docs-heading-anchor-permalink" href="#Ring-polymer-propagation" title="Permalink"></a></h2><p>Path integral molecular dynamics and ring polymer molecular dynamics involve solving Hamilton&#39;s equations for a classical ring polymer Hamiltonian. The ring polymer Hamiltonian describes many replicas of the system joined together by harmonic springs. The number of replicas or beads required must be increased until convergence is achieved. After adding many beads the ring polymer dynamics becomes hard to integrate, as the ring polymer internal modes become the highest frequency modes in the system, limiting the largest acceptable time step.</p><p>To circumvent this difficulty, the ring polymer equations of motion can be partitioned to separate the free ring polymer dynamics from the influence of the external potential. Since the free ring polymer dynamics is entirely harmonic, it is possible to solve this part analytically, allowing for time steps that are not limited by the internal ring polymer frequencies. Recently, the symplectic Cayley modified algorithm has been demonstrated to exhibit strong stability and outperform the original algorithm.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The Cayley modified algorithm was originally introduced by <a href="../references/#Korol2019">Roman Korol, Nawaf Bou-Rabee, Thomas F. Miller (2019)</a>. This paper provides a detailed description of ring polymer dynamics, how the integration algorithm works,  and benchmarks the performance of the algorithms. </p></div></div><p>The Hamiltonian ring polymer integration algorithm has also been extended for thermostatted dynamics: such as for thermal sampling in path integral molecular dynamics, or in thermostatted ring polymer molecular dynamics. As an extension to the Cayley modified algorithm for the Hamiltonian dynamics, the work of <a href="../references/#Korol2020">Roman Korol, Jorge L. Rosa-Raíces, Nawaf Bou-Rabee, Thomas F. Miller (2020)</a> suggests the BCOCB algorithm as the most effective for ring polymer dynamics with Langevin thermostatting. The BCOCB nomenclature refers to the sub-steps within each time step. B is the external potential, C is the Cayley modified free ring polymer step, and O is the thermostat. In this nomenclature, the integration algorithm in the absence of the thermostat can be referred to as the BCB algorithm.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>NQCDynamics.jl implements both the BCOCB and BCB algorithms for Langevin and Hamiltonian dynamics, respectively. They are the default algorithms when performing adiabatic ring polymer dynamics.</p></div></div><h2 id="Mixed-quantum-classical-propagation"><a class="docs-heading-anchor" href="#Mixed-quantum-classical-propagation">Mixed quantum-classical propagation</a><a id="Mixed-quantum-classical-propagation-1"></a><a class="docs-heading-anchor-permalink" href="#Mixed-quantum-classical-propagation" title="Permalink"></a></h2><p>Mixed quantum-classical methods such as mean-field Ehrenfest dynamics or surface hopping dynamics involve simultaneous propagation of nuclear and electronic sub-systems. The two sub-systems evolve on different timescales and it can be advantageous to use different time steps or algorithms for each part. Commonly the nuclear part is solved using the velocity Verlet algorithm and the electronic part is handled using a Runge-Kutta method or an exponential integrator.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>SHARC and Newton-X, two popular surface hopping codes, use the split-algorithm approach. In SHARC, the nuclear degrees of freedom are propagated using the velocity Verlet algorithm, whilst the wavefunction is propagated using an exponential integrator with a smaller time step.  Since an exponential integrator is exact when the propagation operator is constant, reducing the time step would have no benefit if the nuclei remained fixed during the time step. SHARC instead linearly interpolates the propagation operator during the electronic steps so that the nuclei propagation operator changes smoothly during the nuclear time step. This procedure is explained in the SHARC manual. Newton-X allows a few choices for the wavefunction integration algorithm and the nuclear quantities are interpolated similarly to SHARC.</p></div></div><p>NQCDynamics.jl uses the standard library of OrdinaryDiffEq.jl solvers to run the dynamics for mixed quantum-classical methods. For model Hamiltonians where the evaluation of the electronic quantities is fast it is not necessary to use an augmented Verlet algorithm, instead it is sufficient to use any of the adaptive solvers from OrdinaryDiffEq.jl. However, in future it would be useful to implement some of these partioned algorithms that are able to achieve enhanced performance for large, expensive systems.</p><p>For ring polymer mixed quantum-classical methods, it is possible to combine the algorithms used for ring polymer propagation with the partitioning idea from the mixed quantum-classical solvers. Even for model systems, the performance is significantly improved when the ring polymer modes are solved separately such that larger time steps can be used. NQCDynamics.jl implements an augmented form of the BCB algorithm that uses the BCB algorithm for the ring polymer degrees of freedom and uses the Tsit5 algorithm from OrdinaryDiffEq.jl for the electronic part. Currently the time steps for both sub-systems are fixed to be the same, but in future this constraint should be removed. In fact, it would even be possible to use an adaptive solver for the electronic part that can automatically adjust the time step as necessary.</p><h2 id="Semiclassical-mapping-variable-propagation"><a class="docs-heading-anchor" href="#Semiclassical-mapping-variable-propagation">Semiclassical mapping variable propagation</a><a id="Semiclassical-mapping-variable-propagation-1"></a><a class="docs-heading-anchor-permalink" href="#Semiclassical-mapping-variable-propagation" title="Permalink"></a></h2><p>Mapping variable methods describe the coupled nuclear-electronic problem using a classical Hamiltonian, where additional variables have been introduced to represent the electronic populations. As is the case with the ring polymer methods, it is possible to construct symplectic algorithms where each timestep is partitioned into exactly soluble sub-steps. Of particular note is the MInt algorithm described by <a href="../references/#Church2018">Matthew S. Church, Timothy J. H. Hele, Gregory S. Ezra, Nandini Ananth (2018)</a>. The algorithm is symplectic, symmetric and time-reversible and can also be combined with the ring polymer algorithms for ring polymer dynamics with mapping variables. NQCDynamics.jl implements the MInt algorithm and a variant of the MInt algorithm for ring polymer systems that combines the BCB algorithm for the nuclei with the MInt algorithm for the mapping variables.</p><h2 id="Electronic-friction-propagation"><a class="docs-heading-anchor" href="#Electronic-friction-propagation">Electronic friction propagation</a><a id="Electronic-friction-propagation-1"></a><a class="docs-heading-anchor-permalink" href="#Electronic-friction-propagation" title="Permalink"></a></h2><p>Molecular dynamics with electronic friction is described by Langevin equations of motion, equivalent to classical Hamiltonian dynamics with an additional drag force and stochastic force. In the case of Langevin dynamics with a constant friction coefficient, there has been much interest in developing algorithms of low order that can be used for large molecular dynamics simulations. The work of <a href="../references/#Leimkuhler2012">Benedict Leimkuhler, Charles Matthews (2012)</a> has demonstrated that, although a few choices exist, the BAOAB algorithm performs most favourably.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The BAOAB algorithm uses the same nomenclature as the ring polymer algorithms introduced in <a href="#Ring-polymer-propagation">Ring polymer propagation</a>. Each letter represents one component of a single time step. B is the external force step that updates the velocities, A is the position update, and O is the thermostatting step. For ring polymer dynamics the A step encompasses the free ring polymer step.</p></div></div><p>For electronic friction dynamics, the friction is described by a tensor, not a single number as for traditional Langevin dynamics. However, the BAOAB algorithm is still applicable, but the O step requires the matrix exponential of the friction tensor. Since the tensor is positive semi-definite, it is possible to perform the exponentiation by first diagonalising the tensor. Using this approach, NQCDynamics.jl implements the BAOAB algorithm for tensorial friction and the BCOCB when using a ring polymer system. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>DynamicalSDEProblem</code> in StochasticDiffEq.jl represents systems that contain positions and velocities and have a stochastic component. The <code>DynamicalSDEProblem</code> was originally implemented for performing Langevin thermostatted dynamics simulations using the BAOAB algorithm. At the time of writing, BAOAB is the only algorithm implemented in StochasticDiffEq.jl for these problems. In future it would be useful to implement further algorithms and allow for more general noise profiles.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/tully_scattering/">« Scattering probabilities for TullyModelTwo</a><a class="docs-footer-nextpage" href="../devdocs/diffeq/">DifferentialEquations.jl integration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Tuesday 14 June 2022 10:49">Tuesday 14 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
