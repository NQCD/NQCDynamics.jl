<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Contributing a new method · NQCDynamics.jl</title><meta name="title" content="Contributing a new method · NQCDynamics.jl"/><meta property="og:title" content="Contributing a new method · NQCDynamics.jl"/><meta property="twitter:title" content="Contributing a new method · NQCDynamics.jl"/><meta name="description" content="Documentation for NQCDynamics.jl."/><meta property="og:description" content="Documentation for NQCDynamics.jl."/><meta property="twitter:description" content="Documentation for NQCDynamics.jl."/><meta property="og:url" content="https://nqcd.github.io/NQCDynamics.jl/stable/devdocs/new_methods/"/><meta property="twitter:url" content="https://nqcd.github.io/NQCDynamics.jl/stable/devdocs/new_methods/"/><link rel="canonical" href="https://nqcd.github.io/NQCDynamics.jl/stable/devdocs/new_methods/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="NQCDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NQCDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../getting_started/">Getting started</a></li><li><a class="tocitem" href="../../atoms/">Atoms</a></li><li><a class="tocitem" href="../../ensemble_simulations/">Ensemble simulations</a></li><li><a class="tocitem" href="../../saving_loading/">Saving and loading</a></li><li><span class="tocitem">NQCModels.jl</span><ul><li><a class="tocitem" href="../../NQCModels/overview/">NQCModels.jl</a></li><li><a class="tocitem" href="../../NQCModels/analyticmodels/">Analytic model library</a></li><li><a class="tocitem" href="../../NQCModels/ase/">ASE interface</a></li><li><a class="tocitem" href="../../NQCModels/neuralnetworkmodels/">Neural network models</a></li><li><a class="tocitem" href="../../NQCModels/frictionmodels/">Electronic friction models</a></li></ul></li><li><span class="tocitem">NQCDistributions.jl</span><ul><li><a class="tocitem" href="../../NQCDistributions/overview/">NQCDistributions.jl</a></li></ul></li><li><span class="tocitem">Initial conditions</span><ul><li><a class="tocitem" href="../../initialconditions/ebk/">Semiclassical EBK quantisation</a></li><li><a class="tocitem" href="../../initialconditions/hamiltonian/">Thermal Hamiltonian Monte Carlo</a></li><li><a class="tocitem" href="../../initialconditions/langevin/">Thermal Langevin dynamics</a></li><li><a class="tocitem" href="../../initialconditions/metropolishastings/">Thermal Metropolis-Hastings Monte Carlo</a></li></ul></li><li><span class="tocitem">Dynamics simulations</span><ul><li><a class="tocitem" href="../../dynamicssimulations/dynamicssimulations/">Introduction</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/classical/">Classical molecular dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/ehrenfest/">Ehrenfest molecular dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/fssh/">Fewest-switches surface hopping (FSSH)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/langevin/">Classical Langevin dynamics</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/mdef/">Molecular dynamics with electronic friction (MDEF)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/nrpmd/">Nonadiabatic ring polymer molecular dynamics (NRPMD)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/rpmd/">Ring polymer molecular dynamics (RPMD)</a></li><li><a class="tocitem" href="../../dynamicssimulations/dynamicsmethods/rpsh/">Ring polymer surface hopping (RPSH)</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/reactive_scattering/">Reactive scattering from a metal surface</a></li><li><a class="tocitem" href="../../examples/spinboson/">Ohmic spin-boson nonequilibrium population dynamics</a></li><li><a class="tocitem" href="../../examples/threestatemorse/">Time-dependent populations with the ThreeStateMorse model</a></li><li><a class="tocitem" href="../../examples/tully_scattering/">Scattering probabilities for TullyModelTwo</a></li></ul></li><li><a class="tocitem" href="../../integration_algorithms/">Integration algorithms</a></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../diffeq/">DifferentialEquations.jl integration</a></li><li><a class="tocitem" href="../models/">Implementing a new model</a></li><li class="is-active"><a class="tocitem" href>Contributing a new method</a><ul class="internal"><li><a class="tocitem" href="#Basic-implementation"><span>Basic implementation</span></a></li><li><a class="tocitem" href="#Advanced-tips"><span>Advanced tips</span></a></li></ul></li></ul></li><li><span class="tocitem">API</span><ul><li><input class="collapse-toggle" id="menuitem-13-1" type="checkbox"/><label class="tocitem" for="menuitem-13-1"><span class="docs-label">NQCBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCBase/nqcbase/">NQCBase</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13-2" type="checkbox"/><label class="tocitem" for="menuitem-13-2"><span class="docs-label">NQCModels</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCModels/adiabaticmodels/">AdiabaticModels</a></li><li><a class="tocitem" href="../../api/NQCModels/cubeldfamodel/">CubeLDFAModel</a></li><li><a class="tocitem" href="../../api/NQCModels/diabaticmodels/">DiabaticModels</a></li><li><a class="tocitem" href="../../api/NQCModels/frictionmodels/">FrictionModels</a></li><li><a class="tocitem" href="../../api/NQCModels/nninterfaces/">NNInterfaces</a></li><li><a class="tocitem" href="../../api/NQCModels/nonadiabaticmodels/">NQCModels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13-3" type="checkbox"/><label class="tocitem" for="menuitem-13-3"><span class="docs-label">NQCDistributions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCDistributions/nqcdistributions/">NQCDistributions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13-4" type="checkbox"/><label class="tocitem" for="menuitem-13-4"><span class="docs-label">NQCDynamics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/NQCDynamics/calculators/">Calculators</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsmethods/">DynamicsMethods</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsoutputs/">DynamicsOutputs</a></li><li><a class="tocitem" href="../../api/NQCDynamics/dynamicsutils/">DynamicsUtils</a></li><li><a class="tocitem" href="../../api/NQCDynamics/ensembles/">Ensembles</a></li><li><a class="tocitem" href="../../api/NQCDynamics/estimators/">Estimators</a></li><li><a class="tocitem" href="../../api/NQCDynamics/initialconditions/">InitialConditions</a></li><li><a class="tocitem" href="../../api/NQCDynamics/nonadiabaticmoleculardynamics/">NQCDynamics</a></li><li><a class="tocitem" href="../../api/NQCDynamics/numericutils/">Numerical utilities</a></li><li><a class="tocitem" href="../../api/NQCDynamics/ringpolymers/">RingPolymers</a></li><li><a class="tocitem" href="../../api/NQCDynamics/timecorrelationfunctions/">TimeCorrelationFunctions</a></li></ul></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer documentation</a></li><li class="is-active"><a href>Contributing a new method</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Contributing a new method</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NQCD/NQCDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NQCD/NQCDynamics.jl/blob/main/docs/src/devdocs/new_methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Contributing-a-new-method"><a class="docs-heading-anchor" href="#Contributing-a-new-method">Contributing a new method</a><a id="Contributing-a-new-method-1"></a><a class="docs-heading-anchor-permalink" href="#Contributing-a-new-method" title="Permalink"></a></h1><p>A key goal of NQCDynamics.jl is to provide an accessible toolkit for implementing new nonadiabatic dynamics methods. This page details the steps you must take in order to create a new dynamics method. The existing methods are stored inside the <a href="../../api/NQCDynamics/dynamicsmethods/#DynamicsMethods"><code>DynamicsMethods</code></a> submodule, and this is where new methods should be implemented. Technically, it is possible to implement new methods completely separately from the package by importing and extending the relevant functions but if you would like to include your method in the package, it should be added within this submodule.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Generally, each method has its own file, though similar methods are grouped into submodules and share functionality across files. For example, multiple surface hopping methods have been implemented in the submodule <a href="../../api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods"><code>DynamicsMethods.SurfaceHoppingMethods</code></a>, where some functions are shared across the files. </p></div></div><h2 id="Basic-implementation"><a class="docs-heading-anchor" href="#Basic-implementation">Basic implementation</a><a id="Basic-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-implementation" title="Permalink"></a></h2><p>To implement a new dynamics method, the necessary steps are:</p><h3 id="Create-a-new-subtype-of-DynamicsMethods.Method."><a class="docs-heading-anchor" href="#Create-a-new-subtype-of-DynamicsMethods.Method.">Create a new subtype of <code>DynamicsMethods.Method</code>.</a><a id="Create-a-new-subtype-of-DynamicsMethods.Method.-1"></a><a class="docs-heading-anchor-permalink" href="#Create-a-new-subtype-of-DynamicsMethods.Method." title="Permalink"></a></h3><p>This <code>Method</code> acts as an extra parameter inside the simulation that allows us to specify any extra information needed for our dynamics method. This can be a good place to include any temporary arrays and parameters for the simulation. Refer to the <a href="https://docs.julialang.org/en/v1/manual/types/#Composite-Types">Julia manual section on Composite Types</a> to learn how this types are created. Here, our type is called <code>MyMethod</code> and we have included an <code>a</code> parameter that will influence our dynamics:</p><pre><code class="language-julia hljs">using NQCDynamics

struct MyMethod &lt;: DynamicsMethods.Method
    a::Float64
end</code></pre><h3 id="Implement-DynamicsVariables"><a class="docs-heading-anchor" href="#Implement-DynamicsVariables">Implement <code>DynamicsVariables</code></a><a id="Implement-DynamicsVariables-1"></a><a class="docs-heading-anchor-permalink" href="#Implement-DynamicsVariables" title="Permalink"></a></h3><p>This function returns an <a href="https://docs.julialang.org/en/v1/manual/arrays/"><code>AbstractArray</code></a> of the variables to be used as the initial condition for the simulation. The array should contain all of the variables that will change during the dynamics.</p><div class="admonition is-success"><header class="admonition-header">Choosing an array format</header><div class="admonition-body"><p>The only constraint on the array type is that they are <a href="https://docs.julialang.org/en/v1/manual/arrays/"><code>AbstractArray</code></a>s. It could be a simple matrix or vector, but usually we use <a href="https://github.com/jonniedie/ComponentArrays.jl">ComponentArrays.jl</a> to structure the variables. The <code>ComponentVector</code> allows us to collect variables of different types into a convenient format to perform dynamics.</p></div></div><p>For classical dynamics, this would include only the positions and velocities, however, for <a href="../../dynamicssimulations/dynamicsmethods/fssh/#fssh-dynamics">FSSH</a> we must also include the continuous electronic variables and the discrete state.</p><div class="admonition is-info"><header class="admonition-header">Discrete variables</header><div class="admonition-body"><p>Some methods such as <a href="../../dynamicssimulations/dynamicsmethods/fssh/#fssh-dynamics">FSSH</a> have discontinuous variables, like the current occupied state. Discrete variables be handled separately using <a href="https://github.com/SciML/DEDataArrays.jl">DEDataArrays.jl</a>. For surface hopping methods, we have the <code>SurfaceHoppingVariables</code> type that uses this to combine a <code>ComponentVector</code> containing the continuous variables and the discrete state label.</p></div></div><p>For our new method, <code>MyMethod</code>, we implement the <code>DynamicsVariables</code> function and return a <code>ComponentVector</code> containing the velocities, positions and extra variables <code>x</code>. Inside this function we are free to take any inputs and manipulate them before returning the result. As an example, suppose that our <code>x</code> variables are randomly generated each time we run the dynamics, this could be done as follows:</p><pre><code class="language-julia hljs">using ComponentArrays

function DynamicsMethods.DynamicsVariables(sim::Simulation{&lt;:MyMethod}, v, r, k)
    return ComponentVector(v=v, r=r, x=rand()*k)
end</code></pre><p>Here, we take the velocities <code>v</code>, positions <code>r</code> and assign them to the output as we would for classical dynamics, but we also generate a random between 0 and <code>k</code>, where <code>k</code> was given as input.</p><h3 id="Implement-motion!(du,-u,-sim,-t)"><a class="docs-heading-anchor" href="#Implement-motion!(du,-u,-sim,-t)">Implement <code>motion!(du, u, sim, t)</code></a><a id="Implement-motion!(du,-u,-sim,-t)-1"></a><a class="docs-heading-anchor-permalink" href="#Implement-motion!(du,-u,-sim,-t)" title="Permalink"></a></h3><p>This function should fill <code>du</code> with the time-derivative of the dynamics variables <code>u</code> in the usual way expected by <a href="https://diffeq.sciml.ai/stable/tutorials/ode_example/#Example-2:-Solving-Systems-of-Equations"><code>DifferentialEquations.jl</code></a>. We use the in-place version, where each element of <code>du</code> is filled with the time derivative of the correponding element in <code>u</code>.</p><p>Inside the <a href="../../api/NQCDynamics/dynamicsutils/#DynamicsUtils"><code>DynamicsUtils</code></a> submodule there are some useful functions like <a href="../../api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.velocity!-NTuple{5, Any}"><code>velocity!</code></a> and <a href="../../api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.divide_by_mass!-Tuple{Any, Any}"><code>divide_by_mass!</code></a> which can handle some of the common parts of the <code>motion!</code> function. You are free to perform whatever manipulations you like inside this function, but note that <code>motion!</code> is a performance critical function, called numerous times during the simulation, so you should attempt to minimise allocations inside this function.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By convention in Julia, functions that end with the <code>!</code> modify at least one of their arguments.</p></div></div><pre><code class="language-julia hljs">function DynamicsMethods.motion!(du, u, sim::Simulation{MyMethod}, t)

    DynamicsUtils.velocity!(du.r, u.v, u.r, sim, t) # Set du.r equal to the velocity

    # Set the acceleration of the particles
    du.v .= -sim.method.a .* u.r # Use the `a` parameter we stored in the `method`.
    DynamicsUtils.divide_by_mass!(du.v, sim.atoms.masses) # Divide du.v by the mass

    du.x .= 1 ./ u.x # Set time derivative of `x`.

    return nothing # The return of this function is not used so the return is unimportant
end</code></pre><p>Here we have set the time derivative of the positions equal to the velocity, the time derivative of the velocities equal to the acceleration where the force involves the parameter <code>a</code>. Finally, the time derivative of the extra <code>x</code> variable is also set.</p><h3 id="Solve-a-trajectory"><a class="docs-heading-anchor" href="#Solve-a-trajectory">Solve a trajectory</a><a id="Solve-a-trajectory-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-a-trajectory" title="Permalink"></a></h3><p>To perform a simulation with our new method, we can write a script in the usual format and run the dynamics. In this script, we have a single atom with a mass of 1 with a single degree of freedom. We match this by initialising the positions and velocities equal to random 1x1 matrices.  The <code>a</code> parameter of the method has been set equal to 2.0, and the initial value of <code>x</code> has been set to 0.5.</p><pre><code class="language-julia hljs">sim = Simulation(Atoms(1), Free(), MyMethod(2.0))
u = DynamicsVariables(sim, rand(1,1), rand(1,1), [0.5])

sol = run_dynamics(sim, (0.0, 5.0), u, output=(OutputPosition, OutputVelocity, OutputDynamicsVariables))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Dictionaries.Dictionary{Symbol, Any}
                    :Time │ [0.0, 0.007808834438981661, 0.011547191116896234, 0…
          :OutputPosition │ [[0.5991529649338689;;], [0.5995673361071854;;], [0…
          :OutputVelocity │ [[0.056473270295321565;;], [0.04711338868005034;;],…
 :OutputDynamicsVariables │ ComponentArrays.ComponentVector{Float64, Vector{Flo…</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the definition of our <code>motion!</code> method, we have accessed only the <code>atoms</code> field of the simulation. This means that the <code>model</code> we pass to the <code>Simulation</code> constructor is not used. Generally the <code>model</code> is accessed through the calculator interface and examples of its usage can be found by referring the implementations of the existing methods.</p></div></div><p>To visualise the result we can plot each of the quantities from the output table:</p><pre><code class="language-julia hljs">using Plots

plot(sol, :OutputPosition, label=&quot;Position&quot;)
plot!(sol, :OutputVelocity, label=&quot;Velocity&quot;)
plot!(sol, :OutputDynamicsVariables, label=&quot;Dynamics variables&quot;, legend=true)
ylabel!(&quot;Value(t)&quot;)</code></pre><img src="8d56a0d4.svg" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The additional <code>x</code> parameter that we created cannot be accessed in the output tuple with a pre-existing function as with <code>position</code> and <code>velocity</code> since it is not a standard quantity. Instead, we request <code>OutputDynamicsVariables</code> which contains all of the dynamical variables. In the plot, two of the lines labelled <code>DynamicsVariables</code> overlap the position and velocity result. The unique line labelled <code>Dynamics variables</code> is the <code>x</code> variable. When implementing your method, if you want to add new output quantities you should do this inside the <a href="../../api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs"><code>DynamicsOutputs</code></a> submodule.</p></div></div><h2 id="Advanced-tips"><a class="docs-heading-anchor" href="#Advanced-tips">Advanced tips</a><a id="Advanced-tips-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-tips" title="Permalink"></a></h2><h3 id="Is-there-a-custom-algorithm-you-can-implement?"><a class="docs-heading-anchor" href="#Is-there-a-custom-algorithm-you-can-implement?">Is there a custom algorithm you can implement?</a><a id="Is-there-a-custom-algorithm-you-can-implement?-1"></a><a class="docs-heading-anchor-permalink" href="#Is-there-a-custom-algorithm-you-can-implement?" title="Permalink"></a></h3><p>Some dynamics methods have special algorithms that are tailored to the specific problem and achieve better performance than the general algorithms include in <code>DifferentialEquations.jl</code>. For example, ring polymer methods typically use a symplectic scheme to solve for the internal modes of the ring polymer, allowing much larger timesteps. The <code>DifferentialEquations.jl</code> framework provides a simple interface for adding new algorithms, check out the <a href="https://devdocs.sciml.ai/dev/">developer documentation</a> to learn how it works. You can also find some examples of custom algorithms in the <code>DynamicsMethods.IntegrationAlgorithms</code> module.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/">« Implementing a new model</a><a class="docs-footer-nextpage" href="../../api/NQCBase/nqcbase/">NQCBase »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 11 April 2024 16:15">Thursday 11 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
