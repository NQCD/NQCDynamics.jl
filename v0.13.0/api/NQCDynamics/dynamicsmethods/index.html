<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DynamicsMethods · NQCDynamics.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link rel="canonical" href="https://nqcd.github.io/NQCDynamics.jl/stable/api/NQCDynamics/dynamicsmethods/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.svg" alt="NQCDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">NQCDynamics.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Introduction</a></li><li><a class="tocitem" href="../../../getting_started/">Getting started</a></li><li><a class="tocitem" href="../../../atoms/">Atoms</a></li><li><a class="tocitem" href="../../../ensemble_simulations/">Ensemble simulations</a></li><li><a class="tocitem" href="../../../saving_loading/">Saving and loading</a></li><li><span class="tocitem">NQCModels.jl</span><ul><li><a class="tocitem" href="../../../NQCModels/overview/">NQCModels.jl</a></li><li><a class="tocitem" href="../../../NQCModels/analyticmodels/">Analytic model library</a></li><li><a class="tocitem" href="../../../NQCModels/ase/">ASE interface</a></li><li><a class="tocitem" href="../../../NQCModels/neuralnetworkmodels/">Neural network models</a></li><li><a class="tocitem" href="../../../NQCModels/frictionmodels/">Electronic friction models</a></li></ul></li><li><span class="tocitem">NQCDistributions.jl</span><ul><li><a class="tocitem" href="../../../NQCDistributions/overview/">NQCDistributions.jl</a></li></ul></li><li><span class="tocitem">Initial conditions</span><ul><li><a class="tocitem" href="../../../initialconditions/ebk/">Semiclassical EBK quantisation</a></li><li><a class="tocitem" href="../../../initialconditions/hamiltonian/">Thermal Hamiltonian Monte Carlo</a></li><li><a class="tocitem" href="../../../initialconditions/langevin/">Thermal Langevin dynamics</a></li><li><a class="tocitem" href="../../../initialconditions/metropolishastings/">Thermal Metropolis-Hastings Monte Carlo</a></li></ul></li><li><span class="tocitem">Dynamics simulations</span><ul><li><a class="tocitem" href="../../../dynamicssimulations/dynamicssimulations/">Introduction</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/classical/">Classical molecular dynamics</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/ehrenfest/">Ehrenfest molecular dynamics</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/fssh/">Fewest-switches surface hopping (FSSH)</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/langevin/">Classical Langevin dynamics</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/mdef/">Molecular dynamics with electronic friction (MDEF)</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/nrpmd/">Nonadiabatic ring polymer molecular dynamics (NRPMD)</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/rpmd/">Ring polymer molecular dynamics (RPMD)</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/rpsh/">Ring polymer surface hopping (RPSH)</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../../examples/reactive_scattering/">Reactive scattering from a metal surface</a></li><li><a class="tocitem" href="../../../examples/spinboson/">Ohmic spin-boson nonequilibrium population dynamics</a></li><li><a class="tocitem" href="../../../examples/threestatemorse/">Time-dependent populations with the ThreeStateMorse model</a></li><li><a class="tocitem" href="../../../examples/tully_scattering/">Scattering probabilities for TullyModelTwo</a></li></ul></li><li><a class="tocitem" href="../../../integration_algorithms/">Integration algorithms</a></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../../../devdocs/diffeq/">DifferentialEquations.jl integration</a></li><li><a class="tocitem" href="../../../devdocs/models/">Implementing a new model</a></li><li><a class="tocitem" href="../../../devdocs/new_methods/">Contributing a new method</a></li></ul></li><li><span class="tocitem">API</span><ul><li><input class="collapse-toggle" id="menuitem-13-1" type="checkbox"/><label class="tocitem" for="menuitem-13-1"><span class="docs-label">NQCBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NQCBase/nqcbase/">NQCBase</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13-2" type="checkbox"/><label class="tocitem" for="menuitem-13-2"><span class="docs-label">NQCModels</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NQCModels/adiabaticmodels/">AdiabaticModels</a></li><li><a class="tocitem" href="../../NQCModels/cubeldfamodel/">CubeLDFAModel</a></li><li><a class="tocitem" href="../../NQCModels/diabaticmodels/">DiabaticModels</a></li><li><a class="tocitem" href="../../NQCModels/frictionmodels/">FrictionModels</a></li><li><a class="tocitem" href="../../NQCModels/nninterfaces/">NNInterfaces</a></li><li><a class="tocitem" href="../../NQCModels/nonadiabaticmodels/">NQCModels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13-3" type="checkbox"/><label class="tocitem" for="menuitem-13-3"><span class="docs-label">NQCDistributions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NQCDistributions/nqcdistributions/">NQCDistributions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13-4" type="checkbox" checked/><label class="tocitem" for="menuitem-13-4"><span class="docs-label">NQCDynamics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../calculators/">Calculators</a></li><li class="is-active"><a class="tocitem" href>DynamicsMethods</a><ul class="internal"><li><a class="tocitem" href="#ClassicalMethods"><span>ClassicalMethods</span></a></li><li><a class="tocitem" href="#MappingVariableMethods"><span>MappingVariableMethods</span></a></li><li><a class="tocitem" href="#SurfaceHoppingMethods"><span>SurfaceHoppingMethods</span></a></li><li><a class="tocitem" href="#EhrenfestMethods"><span>EhrenfestMethods</span></a></li><li><a class="tocitem" href="#IntegrationAlgorithms"><span>IntegrationAlgorithms</span></a></li></ul></li><li><a class="tocitem" href="../dynamicsoutputs/">DynamicsOutputs</a></li><li><a class="tocitem" href="../dynamicsutils/">DynamicsUtils</a></li><li><a class="tocitem" href="../ensembles/">Ensembles</a></li><li><a class="tocitem" href="../estimators/">Estimators</a></li><li><a class="tocitem" href="../initialconditions/">InitialConditions</a></li><li><a class="tocitem" href="../nonadiabaticmoleculardynamics/">NQCDynamics</a></li><li><a class="tocitem" href="../numericutils/">Numerical utilities</a></li><li><a class="tocitem" href="../ringpolymers/">RingPolymers</a></li><li><a class="tocitem" href="../timecorrelationfunctions/">TimeCorrelationFunctions</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li><a class="is-disabled">NQCDynamics</a></li><li class="is-active"><a href>DynamicsMethods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DynamicsMethods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NQCD/NQCDynamics.jl/blob/main/docs/src/api/NQCDynamics/dynamicsmethods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DynamicsMethods"><a class="docs-heading-anchor" href="#DynamicsMethods">DynamicsMethods</a><a id="DynamicsMethods-1"></a><a class="docs-heading-anchor-permalink" href="#DynamicsMethods" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods" href="#NQCDynamics.DynamicsMethods"><code>NQCDynamics.DynamicsMethods</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This module contains functions and types necessary for performing nonadiabatic molecular dynamics.</p><p>Dynamics is performed using <a href="https://diffeq.sciml.ai/stable/"><code>DifferentialEquations.jl</code></a>. As such, this module is centered around the implementation of the functions necessary to integrate the dynamics.</p><p>For deterministic Hamiltonian methods, the central function is <a href="#NQCDynamics.DynamicsMethods.motion!"><code>DynamicsMethods.motion!</code></a>, which is the inplace form of the function to be integrated by <a href="https://diffeq.sciml.ai/stable/"><code>DifferentialEquations.jl</code></a>.</p><p>Further, methods that have discontinuities, such as surface hopping, use the <a href="https://diffeq.sciml.ai/stable/features/callback_functions/#callbacks">callback interface</a> provided by <code>DifferentialEquations.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/DynamicsMethods.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.Method" href="#NQCDynamics.DynamicsMethods.Method"><code>NQCDynamics.DynamicsMethods.Method</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Each type of dynamics subtypes <code>Method</code> which is passed to the <code>AbstractSimulation</code> as a parameter to determine the type of dynamics desired.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/DynamicsMethods.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.DynamicsVariables-Tuple{NQCDynamics.AbstractSimulation, Any, Any}" href="#NQCDynamics.DynamicsMethods.DynamicsVariables-Tuple{NQCDynamics.AbstractSimulation, Any, Any}"><code>NQCDynamics.DynamicsMethods.DynamicsVariables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DynamicsVariables(::AbstractSimulation, args...)</code></pre><p>For each dynamics method this function is implemented to provide the variables for the dynamics in the appropriate format.</p><p>By default, <code>DynamicsVariables</code> is set up for the classical case and takes <code>sim</code>, <code>v</code>, <code>r</code> as arguments and returns a <code>ComponentVector(v=v, r=r)</code> which is used as a container for the velocities and positions during classical dynamics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/DynamicsMethods.jl#L59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.create_problem-Tuple{Any, Any, Any}" href="#NQCDynamics.DynamicsMethods.create_problem-Tuple{Any, Any, Any}"><code>NQCDynamics.DynamicsMethods.create_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Provides the DEProblem for each type of simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/DynamicsMethods.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.get_callbacks-Tuple{NQCDynamics.AbstractSimulation}" href="#NQCDynamics.DynamicsMethods.get_callbacks-Tuple{NQCDynamics.AbstractSimulation}"><code>NQCDynamics.DynamicsMethods.get_callbacks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Select the default callbacks for this simulation type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/DynamicsMethods.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.motion!" href="#NQCDynamics.DynamicsMethods.motion!"><code>NQCDynamics.DynamicsMethods.motion!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">motion!(du, u, sim, t)</code></pre><p>As per <code>DifferentialEquations.jl</code>, this function is implemented for each method and defines the time derivatives of the <code>DynamicalVariables</code>.</p><p>We require that each implementation ensures <code>du</code> and <code>u</code> are subtypes of <code>DynamicalVariables</code> and <code>sim</code> subtypes <code>AbstractSimulation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/DynamicsMethods.jl#L38-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.select_algorithm-Tuple{NQCDynamics.AbstractSimulation}" href="#NQCDynamics.DynamicsMethods.select_algorithm-Tuple{NQCDynamics.AbstractSimulation}"><code>NQCDynamics.DynamicsMethods.select_algorithm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Choose a default algorithm for solving the differential equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/DynamicsMethods.jl#L53">source</a></section></article><h2 id="ClassicalMethods"><a class="docs-heading-anchor" href="#ClassicalMethods">ClassicalMethods</a><a id="ClassicalMethods-1"></a><a class="docs-heading-anchor-permalink" href="#ClassicalMethods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.ClassicalMethods.Classical" href="#NQCDynamics.DynamicsMethods.ClassicalMethods.Classical"><code>NQCDynamics.DynamicsMethods.ClassicalMethods.Classical</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Classical &lt;: DynamicsMethods.Method</code></pre><p>Type for performing classical molecular dynamics.</p><pre><code class="language-julia hljs">sim = Simulation{Classical}(Atoms(:H), Harmonic())

# output

Simulation{Classical}:
  Atoms{Float64}([:H], [1], [1837.4715941070515])
  Harmonic{Float64, Float64, Float64}
  m: Float64 1.0
  ω: Float64 1.0
  r₀: Float64 0.0
  dofs: Int64 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/ClassicalMethods/classical.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.ClassicalMethods.Langevin" href="#NQCDynamics.DynamicsMethods.ClassicalMethods.Langevin"><code>NQCDynamics.DynamicsMethods.ClassicalMethods.Langevin</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type for performing Langevin molecular dynamics.</p><pre><code class="language-julia hljs">using Unitful
sim = Simulation{Langevin}(Atoms(:H), Free(); γ=2.5, temperature=100u&quot;K&quot;)

# output

Simulation{Langevin{Float64}}:
  Atoms{Float64}([:H], [1], [1837.4715941070515])
  Free(1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/ClassicalMethods/langevin.jl#L7-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.ClassicalMethods.MDEF" href="#NQCDynamics.DynamicsMethods.ClassicalMethods.MDEF"><code>NQCDynamics.DynamicsMethods.ClassicalMethods.MDEF</code></a> — <span class="docstring-category">Type</span></header><section><div><p class="math-container">\[dr = v dt\\
dv = -\Delta U/M dt - \Gamma v dt + \sigma \sqrt{2\Gamma} dW\]</p><p><span>$\Gamma$</span> is the friction tensor with units of inverse time. For thermal dynamics we set <span>$\sigma = \sqrt{kT / M}$</span>, where <span>$T$</span> is the electronic temperature.</p><p>This is integrated using the BAOAB algorithm where the friction &quot;O&quot; step is performed in the tensor&#39;s eigenbasis. See <code>src/dynamics/mdef_baoab.jl</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/ClassicalMethods/mdef.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.ClassicalMethods.ThermalLangevin" href="#NQCDynamics.DynamicsMethods.ClassicalMethods.ThermalLangevin"><code>NQCDynamics.DynamicsMethods.ClassicalMethods.ThermalLangevin</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type for performing Langevin ring polymer molecular dynamics.</p><p>Currently there are separate types for classical and ring polymer versions of Langevin dynamics but they should be combined. The reason they are not at the moment is that they use different integration algorithms and require slightly different fields.</p><pre><code class="language-julia hljs">using Unitful
RingPolymerSimulation{ThermalLangevin}(Atoms(:H), Free(), 10; γ=0.1, temperature=25u&quot;K&quot;)

# output

RingPolymerSimulation{ThermalLangevin{Float64}}:
 
  Atoms{Float64}([:H], [1], [1837.4715941070515])
 
  Free(1)
  with 10 beads.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/ClassicalMethods/langevin.jl#L46-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!-Tuple{Any, Any, Any, NQCDynamics.AbstractSimulation, Any}" href="#NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!-Tuple{Any, Any, Any, NQCDynamics.AbstractSimulation, Any}"><code>NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>f1</code> in <code>DifferentialEquations.jl</code> docs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/ClassicalMethods/classical.jl#L56-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.ClassicalMethods.friction!-Tuple{Any, Any, NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.ClassicalMethods.AbstractMDEF}, Any}" href="#NQCDynamics.DynamicsMethods.ClassicalMethods.friction!-Tuple{Any, Any, NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.ClassicalMethods.AbstractMDEF}, Any}"><code>NQCDynamics.DynamicsMethods.ClassicalMethods.friction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">friction!(g, r, sim, t)</code></pre><p>Evaluates friction tensor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/ClassicalMethods/mdef.jl#L34-L38">source</a></section></article><h2 id="MappingVariableMethods"><a class="docs-heading-anchor" href="#MappingVariableMethods">MappingVariableMethods</a><a id="MappingVariableMethods-1"></a><a class="docs-heading-anchor-permalink" href="#MappingVariableMethods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.MappingVariableMethods.NRPMD" href="#NQCDynamics.DynamicsMethods.MappingVariableMethods.NRPMD"><code>NQCDynamics.DynamicsMethods.MappingVariableMethods.NRPMD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NRPMD{T} &lt;: DynamicsMethods.Method</code></pre><p>Nonadiabatic ring polymer molecular dynamics Uses Meyer-Miller-Stock-Thoss mapping variables for electronic degrees of freedom and ring polymer formalism for nuclear degrees of freedom.</p><pre><code class="language-julia hljs">RingPolymerSimulation{NRPMD}(Atoms(:H), DoubleWell(), 10)

# output

RingPolymerSimulation{NRPMD{Float64}}:
 
  Atoms{Float64}([:H], [1], [1837.4715941070515])
 
  DoubleWell{Int64, Int64, Int64, Int64}
  mass: Int64 1
  ω: Int64 1
  γ: Int64 1
  Δ: Int64 1
 
  with 10 beads.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/MappingVariableMethods/nrpmd.jl#L9-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.MappingVariableMethods.eCMM" href="#NQCDynamics.DynamicsMethods.MappingVariableMethods.eCMM"><code>NQCDynamics.DynamicsMethods.MappingVariableMethods.eCMM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">eCMM{T} &lt;: DynamicsMethods.Method</code></pre><p><strong>References</strong></p><ul><li><a href="../../../references/#HeGong2021">Xin He, Zhihao Gong, Baihua Wu, Jian Liu (2021)</a></li><li><a href="../../../references/#HeWu2021">Xin He, Baihua Wu, Zhihao Gong, Jian Liu (2021)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/MappingVariableMethods/cmm.jl#L5-L12">source</a></section></article><h2 id="SurfaceHoppingMethods"><a class="docs-heading-anchor" href="#SurfaceHoppingMethods">SurfaceHoppingMethods</a><a id="SurfaceHoppingMethods-1"></a><a class="docs-heading-anchor-permalink" href="#SurfaceHoppingMethods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">SurfaceHoppingMethods</code></pre><p>Implementation for surface hopping methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/SurfaceHoppingMethods.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AdiabaticIESH" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AdiabaticIESH"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AdiabaticIESH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IESH{T} &lt;: SurfaceHopping</code></pre><p>Independent electron surface hopping.</p><p><strong>References</strong></p><ul><li><a href="https://doi.org/10.1063/1.3125436">Shenvi, Roy, Tully, J. Chem. Phys. 130, 174107 (2009)</a></li><li><a href="https://doi.org/10.1063/1.3122989">Roy, Shenvi, Tully, J. Chem. Phys. 130, 174716 (2009)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/iesh.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.BCME" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.BCME"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.BCME</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BCME{T} &lt;: ClassicalMasterEquation</code></pre><p>Extension to CME that incorporates broadening in the potential energy surfaces.</p><p>Note that we do not rescale the velocity as this is not mentioned only in the 2016 paper, not any of the later ones, so I presume they later decided not to do it and instead keep it the same as the original CME.</p><ul><li>Dou, Subotnik, J. Chem. Phys. 144, 024116 (2016)</li><li>Dou, Subotnik, J. Phys. Chem. A, 24, 757-771 (2020)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/cme.jl#L100-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.CME" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.CME"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.CME</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CME{T} &lt;: ClassicalMasterEquation</code></pre><p>Simple surface hopping method for Newns-Anderson (Anderson-Holstein) models.</p><ul><li>Dou, Nitzan, Subotnik, J. Chem. Phys. 142, 084110 (2015)</li><li>Dou, Subotnik, J. Phys. Chem. A, 24, 757-771 (2020)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/cme.jl#L60-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.FSSH" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.FSSH"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.FSSH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FSSH{T} &lt;: SurfaceHopping</code></pre><p>Type for fewest-switches surface hopping</p><pre><code class="language-julia hljs">Simulation{FSSH}(Atoms(:H), Free())

# output

Simulation{FSSH{Float64}}:
  Atoms{Float64}([:H], [1], [1837.4715941070515])
  Free(1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/fssh.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for all surface hopping methods.</p><p>Surface hopping methods follow the structure set out in this file. The nuclear and electronic variables are propagated by the <code>motion!</code> function. The surface hopping procedure is handled by the <code>HoppingCallback</code> which uses the functions <code>check_hop!</code> and <code>execute_hop!</code> as its <code>condition</code> and <code>affect!</code>.</p><p>To add a new surface hopping scheme, you must create a new struct and define methods for <code>evaluate_hopping_probability!</code>, <code>select_new_state</code>, and <code>rescale_velocity!</code>.</p><p>See <code>fssh.jl</code> for an example implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/SurfaceHoppingMethods.jl#L36-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_Akj-Tuple{Simulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AbstractIESH}, AbstractMatrix, AbstractMatrix, Number, Vector}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_Akj-Tuple{Simulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AbstractIESH}, AbstractMatrix, AbstractMatrix, Number, Vector}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_Akj</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Equation 17 in Shenvi, Roy, Tully 2009. Uses equations 19 and 20.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/iesh.jl#L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_a-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, AbstractMatrix}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_a-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, AbstractMatrix}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_a(sim::AbstractSimulation{&lt;:SurfaceHopping}, coupling::AbstractMatrix)</code></pre><p>Equation 40 from <a href="../../../references/#HammesSchiffer1994">Sharon Hammes‐Schiffer, John C. Tully (1994)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/surface_hopping.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_b-Tuple{AbstractMatrix, AbstractMatrix}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_b-Tuple{AbstractMatrix, AbstractMatrix}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_b(coupling::AbstractMatrix, velocity::AbstractMatrix)</code></pre><p>Equation 41 from <a href="../../../references/#HammesSchiffer1994">Sharon Hammes‐Schiffer, John C. Tully (1994)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/surface_hopping.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.compute_overlap!-Tuple{Simulation{&lt;:AdiabaticIESH}, Matrix, Any, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.compute_overlap!-Tuple{Simulation{&lt;:AdiabaticIESH}, Matrix, Any, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.compute_overlap!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Equation 20 in Shenvi, Roy, Tully 2009.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/iesh.jl#L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_broadening-NTuple{4, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_broadening-NTuple{4, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_broadening</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate_broadening(h, μ, β, Γ)</code></pre><p>Evaluate the convolution of the Fermi function with a Lorentzian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/cme.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{NQCDynamics.AbstractSimulation{&lt;:FSSH}, Any, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{NQCDynamics.AbstractSimulation{&lt;:FSSH}, Any, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate_hopping_probability!(sim::Simulation{&lt;:FSSH}, u, dt)</code></pre><p>Evaluates the probability of hopping from the current state to all other states</p><p><strong>Implementation</strong></p><ul><li><code>σ</code> is Hermitan so the choice <code>σ[m,s]</code> or <code>σ[s,m]</code> is irrelevant; we take the real part.</li><li>&#39;d&#39; is skew-symmetric so here the indices are important.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/fssh.jl#L57-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function should set the field <code>sim.method.hopping_probability</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/surface_hopping.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{Simulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AbstractIESH}, Any, Any, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{Simulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AbstractIESH}, Any, Any, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Hopping probability according to equation 21 in Shenvi, Roy, Tully 2009.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/iesh.jl#L200-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.extract_nonadiabatic_coupling-Tuple{Any, Any, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.extract_nonadiabatic_coupling-Tuple{Any, Any, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.extract_nonadiabatic_coupling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extract_nonadiabatic_coupling(coupling, new_state, old_state)</code></pre><p>Extract the nonadiabatic coupling vector between states <code>new_state</code> and <code>old_state</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/surface_hopping.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.iesh_diabatic_population-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.iesh_diabatic_population-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.iesh_diabatic_population</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate the diabatic population in J. Chem. Theory Comput. 2022, 18, 4615−4626. Eqs. 12, 13 and 14 describe the steps to calculat it though the code is written to use matrix operations instead of summations to calculate the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/iesh.jl#L315-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.perform_rescaling!-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any, Any, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.perform_rescaling!-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any, Any, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.perform_rescaling!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perform_rescaling!(
    sim::AbstractSimulation{&lt;:SurfaceHopping}, velocity, velocity_rescale, d
)</code></pre><p>Equation 33 from <a href="../../../references/#HammesSchiffer1994">Sharon Hammes‐Schiffer, John C. Tully (1994)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/surface_hopping.jl#L109-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale_velocity!(sim::AbstractSimulation{&lt;:SurfaceHopping}, u)::Bool</code></pre><p>Rescale the velocity in the direction of the nonadiabatic coupling.</p><p><strong>References</strong></p><p><a href="../../../references/#HammesSchiffer1994">Sharon Hammes‐Schiffer, John C. Tully (1994)</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/surface_hopping.jl#L43-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.select_new_state-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.select_new_state-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.select_new_state</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function should return the desired state determined by the probability. Should return the original state if no hop is desired.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/surface_hopping.jl#L35-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.unpack_states-Tuple{NQCDynamics.AbstractSimulation{&lt;:FSSH}}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.unpack_states-Tuple{NQCDynamics.AbstractSimulation{&lt;:FSSH}}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.unpack_states</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unpack_states(sim)</code></pre><p>Get the two states that we are hopping between.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/fssh.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsUtils.acceleration!-Tuple{Any, Any, Any, Simulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AbstractIESH}, Any, Any}" href="#NQCDynamics.DynamicsUtils.acceleration!-Tuple{Any, Any, Any, Simulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.AbstractIESH}, Any, Any}"><code>NQCDynamics.DynamicsUtils.acceleration!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the acceleration due to the force from the currently occupied states. See Eq. 12 of Shenvi, Tully JCP 2009 paper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/iesh.jl#L163-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsUtils.set_quantum_derivative!-Tuple{Any, Any, Any, Simulation{&lt;:AdiabaticIESH}}" href="#NQCDynamics.DynamicsUtils.set_quantum_derivative!-Tuple{Any, Any, Any, Simulation{&lt;:AdiabaticIESH}}"><code>NQCDynamics.DynamicsUtils.set_quantum_derivative!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagation of electronic wave function happens according to Eq. (14)  in the Shenvi, Tully paper (JCP 2009)</p><p>In IESH each electron is independent so we can loop through electrons and set the derivative one at a time, in the standard way for FSSH.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/SurfaceHoppingMethods/iesh.jl#L185-L191">source</a></section></article><h2 id="EhrenfestMethods"><a class="docs-heading-anchor" href="#EhrenfestMethods">EhrenfestMethods</a><a id="EhrenfestMethods-1"></a><a class="docs-heading-anchor-permalink" href="#EhrenfestMethods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.EhrenfestMethods.AbstractEhrenfest" href="#NQCDynamics.DynamicsMethods.EhrenfestMethods.AbstractEhrenfest"><code>NQCDynamics.DynamicsMethods.EhrenfestMethods.AbstractEhrenfest</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for Ehrenfest method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/EhrenfestMethods/EhrenfestMethods.jl#L19-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.EhrenfestMethods.Ehrenfest" href="#NQCDynamics.DynamicsMethods.EhrenfestMethods.Ehrenfest"><code>NQCDynamics.DynamicsMethods.EhrenfestMethods.Ehrenfest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Ehrenfest{T} &lt;: AbstractEhrenfest</code></pre><p>Ehrenfest molecular dynamics. Classical molecular dynamics where the force is derived by averaging contributions from multiple electronic states.</p><pre><code class="language-julia hljs">Simulation{Ehrenfest}(Atoms(:H), DoubleWell())

# output

Simulation{Ehrenfest{Float64}}:
  Atoms{Float64}([:H], [1], [1837.4715941070515])
  DoubleWell{Int64, Int64, Int64, Int64}
  mass: Int64 1
  ω: Int64 1
  γ: Int64 1
  Δ: Int64 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/EhrenfestMethods/ehrenfest.jl#L7-L26">source</a></section></article><h2 id="IntegrationAlgorithms"><a class="docs-heading-anchor" href="#IntegrationAlgorithms">IntegrationAlgorithms</a><a id="IntegrationAlgorithms-1"></a><a class="docs-heading-anchor-permalink" href="#IntegrationAlgorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.MInt" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.MInt"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.MInt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MInt &lt;: OrdinaryDiffEq.OrdinaryDiffEqAlgorithm</code></pre><p>Second order symplectic momentum integral algorithm.</p><p><strong>Reference</strong></p><p><a href="https://doi.org/10.1063/1.5005557">J. Chem. Phys. 148, 102326 (2018)</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/IntegrationAlgorithms/IntegrationAlgorithms.jl#L32-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.RingPolymerMInt" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.RingPolymerMInt"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.RingPolymerMInt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RingPolymerMInt &lt;: OrdinaryDiffEq.OrdinaryDiffEqAlgorithm</code></pre><p>Second order symplectic momentum integral algorithm applied to NRPMD.</p><p><strong>Reference</strong></p><p><a href="https://doi.org/10.1063/1.5005557">J. Chem. Phys. 148, 102326 (2018)</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/IntegrationAlgorithms/IntegrationAlgorithms.jl#L21-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_C_propagator-Tuple{AbstractVector, AbstractMatrix, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_C_propagator-Tuple{AbstractVector, AbstractMatrix, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_C_propagator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>C</code> propagator for the mapping variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/IntegrationAlgorithms/ringpolymer_mint.jl#L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_D_propagator-Tuple{AbstractVector, AbstractMatrix, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_D_propagator-Tuple{AbstractVector, AbstractMatrix, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_D_propagator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>D</code> propagator for the mapping variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/IntegrationAlgorithms/ringpolymer_mint.jl#L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_gamma-Tuple{AbstractMatrix, AbstractVector, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_gamma-Tuple{AbstractMatrix, AbstractVector, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_gamma</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>Γ</code> variable used to calculate the nuclear propagators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/IntegrationAlgorithms/ringpolymer_mint.jl#L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, Any}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, Any}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the force due to the mapping variables.</p><p>Equivalent to this but doesn&#39;t allocate:      return 0.5 * (q&#39;<em>E</em>q + p&#39;<em>E</em>p) - q&#39;<em>F</em>p</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/IntegrationAlgorithms/mint.jl#L161-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the force due to the mapping variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/IntegrationAlgorithms/ringpolymer_mint.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_xi-Tuple{AbstractMatrix, AbstractVector, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_xi-Tuple{AbstractMatrix, AbstractVector, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_xi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>Ξ</code> variable used to calculate the nuclear propagators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/IntegrationAlgorithms/ringpolymer_mint.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_C_propagator!-Tuple{Any, Any, LinearAlgebra.Eigen, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_C_propagator!-Tuple{Any, Any, LinearAlgebra.Eigen, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_C_propagator!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>C</code> propagator for the mapping variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/IntegrationAlgorithms/mint.jl#L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_D_propagator!-Tuple{Any, Any, LinearAlgebra.Eigen, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_D_propagator!-Tuple{Any, Any, LinearAlgebra.Eigen, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_D_propagator!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>D</code> propagator for the mapping variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/IntegrationAlgorithms/mint.jl#L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_gamma!-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_gamma!-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_gamma!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>Γ</code> variable used to calculate the nuclear propagators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/IntegrationAlgorithms/mint.jl#L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_xi!-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_xi!-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_xi!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>Ξ</code> variable used to calculate the nuclear propagators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/9f9eb0964ab357d815b4d865073a050b6bc47963/src/DynamicsMethods/IntegrationAlgorithms/mint.jl#L149">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../calculators/">« Calculators</a><a class="docs-footer-nextpage" href="../dynamicsoutputs/">DynamicsOutputs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 12 January 2023 14:48">Thursday 12 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
