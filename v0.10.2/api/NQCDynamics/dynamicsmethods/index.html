<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DynamicsMethods · NQCDynamics.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link rel="canonical" href="https://nqcd.github.io/NQCDynamics.jl/stable/api/NQCDynamics/dynamicsmethods/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.svg" alt="NQCDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">NQCDynamics.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Introduction</a></li><li><a class="tocitem" href="../../../getting_started/">Getting started</a></li><li><a class="tocitem" href="../../../atoms/">Atoms</a></li><li><a class="tocitem" href="../../../ensemble_simulations/">Ensemble simulations</a></li><li><a class="tocitem" href="../../../saving_loading/">Saving and loading</a></li><li><span class="tocitem">NQCModels.jl</span><ul><li><a class="tocitem" href="../../../NQCModels/overview/">NQCModels.jl</a></li><li><a class="tocitem" href="../../../NQCModels/analyticmodels/">Analytic model library</a></li><li><a class="tocitem" href="../../../NQCModels/ase/">ASE interface</a></li><li><a class="tocitem" href="../../../NQCModels/neuralnetworkmodels/">Neural network models</a></li><li><a class="tocitem" href="../../../NQCModels/frictionmodels/">Electronic friction models</a></li></ul></li><li><span class="tocitem">Initial conditions</span><ul><li><a class="tocitem" href="../../../initialconditions/dynamicaldistribution/">Storing and sampling distributions</a></li><li><a class="tocitem" href="../../../initialconditions/samplingmethods/ebk/">Semiclassical EBK quantisation</a></li><li><a class="tocitem" href="../../../initialconditions/samplingmethods/hamiltonian/">Thermal Hamiltonian Monte Carlo</a></li><li><a class="tocitem" href="../../../initialconditions/samplingmethods/langevin/">Thermal Langevin dynamics</a></li><li><a class="tocitem" href="../../../initialconditions/samplingmethods/metropolishastings/">Thermal Metropolis-Hastings Monte Carlo</a></li></ul></li><li><span class="tocitem">Dynamics simulations</span><ul><li><a class="tocitem" href="../../../dynamicssimulations/dynamicssimulations/">Introduction</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/classical/">Classical molecular dynamics</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/ehrenfest/">Ehrenfest molecular dynamics</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/fssh/">Fewest-switches surface hopping (FSSH)</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/langevin/">Classical Langevin dynamics</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/mdef/">Molecular dynamics with electronic friction (MDEF)</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/nrpmd/">Nonadiabatic ring polymer molecular dynamics (NRPMD)</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/rpmd/">Ring polymer molecular dynamics (RPMD)</a></li><li><a class="tocitem" href="../../../dynamicssimulations/dynamicsmethods/rpsh/">Ring polymer surface hopping (RPSH)</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../../examples/reactive_scattering/">Reactive scattering from a metal surface</a></li><li><a class="tocitem" href="../../../examples/spinboson/">Ohmic spin-boson nonequilibrium population dynamics</a></li><li><a class="tocitem" href="../../../examples/threestatemorse/">Time-dependent populations with the ThreeStateMorse model</a></li><li><a class="tocitem" href="../../../examples/tully_scattering/">Scattering probabilities for TullyModelTwo</a></li></ul></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../../../devdocs/diffeq/">DifferentialEquations.jl integration</a></li><li><a class="tocitem" href="../../../devdocs/models/">Implementing a new model</a></li><li><a class="tocitem" href="../../../devdocs/new_methods/">Contributing a new method</a></li></ul></li><li><span class="tocitem">API</span><ul><li><input class="collapse-toggle" id="menuitem-11-1" type="checkbox"/><label class="tocitem" for="menuitem-11-1"><span class="docs-label">NQCBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NQCBase/nqcbase/">NQCBase</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">NQCModels</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NQCModels/adiabaticmodels/">AdiabaticModels</a></li><li><a class="tocitem" href="../../NQCModels/cubeldfamodel/">CubeLDFAModel</a></li><li><a class="tocitem" href="../../NQCModels/diabaticmodels/">DiabaticModels</a></li><li><a class="tocitem" href="../../NQCModels/frictionmodels/">FrictionModels</a></li><li><a class="tocitem" href="../../NQCModels/nninterfaces/">NNInterfaces</a></li><li><a class="tocitem" href="../../NQCModels/nonadiabaticmodels/">NQCModels</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox" checked/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">NQCDynamics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../calculators/">Calculators</a></li><li class="is-active"><a class="tocitem" href>DynamicsMethods</a><ul class="internal"><li><a class="tocitem" href="#ClassicalMethods"><span>ClassicalMethods</span></a></li><li><a class="tocitem" href="#MappingVariableMethods"><span>MappingVariableMethods</span></a></li><li><a class="tocitem" href="#SurfaceHoppingMethods"><span>SurfaceHoppingMethods</span></a></li><li><a class="tocitem" href="#EhrenfestMethods"><span>EhrenfestMethods</span></a></li><li><a class="tocitem" href="#IntegrationAlgorithms"><span>IntegrationAlgorithms</span></a></li></ul></li><li><a class="tocitem" href="../dynamicsoutputs/">DynamicsOutputs</a></li><li><a class="tocitem" href="../dynamicsutils/">DynamicsUtils</a></li><li><a class="tocitem" href="../ensembles/">Ensembles</a></li><li><a class="tocitem" href="../estimators/">Estimators</a></li><li><a class="tocitem" href="../initialconditions/">InitialConditions</a></li><li><a class="tocitem" href="../nonadiabaticdistributions/">NonadiabaticDistributions</a></li><li><a class="tocitem" href="../nonadiabaticmoleculardynamics/">NQCDynamics</a></li><li><a class="tocitem" href="../ringpolymers/">RingPolymers</a></li><li><a class="tocitem" href="../timecorrelationfunctions/">TimeCorrelationFunctions</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li><a class="is-disabled">NQCDynamics</a></li><li class="is-active"><a href>DynamicsMethods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DynamicsMethods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NQCD/NQCDynamics.jl/blob/master/docs/src/api/NQCDynamics/dynamicsmethods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DynamicsMethods"><a class="docs-heading-anchor" href="#DynamicsMethods">DynamicsMethods</a><a id="DynamicsMethods-1"></a><a class="docs-heading-anchor-permalink" href="#DynamicsMethods" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods" href="#NQCDynamics.DynamicsMethods"><code>NQCDynamics.DynamicsMethods</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This module contains functions and types necessary for performing nonadiabatic molecular dynamics.</p><p>Dynamics is performed using <a href="https://diffeq.sciml.ai/stable/"><code>DifferentialEquations.jl</code></a>. As such, this module is centered around the implementation of the functions necessary to integrate the dynamics.</p><p>For deterministic Hamiltonian methods, the central function is <a href="#NQCDynamics.DynamicsMethods.motion!"><code>DynamicsMethods.motion!</code></a>, which is the inplace form of the function to be integrated by <a href="https://diffeq.sciml.ai/stable/"><code>DifferentialEquations.jl</code></a>.</p><p>Further, methods that have discontinuities, such as surface hopping, use the <a href="https://diffeq.sciml.ai/stable/features/callback_functions/#callbacks">callback interface</a> provided by <code>DifferentialEquations.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/DynamicsMethods.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.Method" href="#NQCDynamics.DynamicsMethods.Method"><code>NQCDynamics.DynamicsMethods.Method</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Each type of dynamics subtypes <code>Method</code> which is passed to the <code>AbstractSimulation</code> as a parameter to determine the type of dynamics desired.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/DynamicsMethods.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.DynamicsVariables-Tuple{NQCDynamics.AbstractSimulation, Any, Any}" href="#NQCDynamics.DynamicsMethods.DynamicsVariables-Tuple{NQCDynamics.AbstractSimulation, Any, Any}"><code>NQCDynamics.DynamicsMethods.DynamicsVariables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DynamicsVariables(::AbstractSimulation, args...)</code></pre><p>For each dynamics method this function is implemented to provide the variables for the dynamics in the appropriate format.</p><p>By default, <code>DynamicsVariables</code> is set up for the classical case and takes <code>sim</code>, <code>v</code>, <code>r</code> as arguments and returns a <code>ComponentVector(v=v, r=r)</code> which is used as a container for the velocities and positions during classical dynamics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/DynamicsMethods.jl#L61-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.create_problem-Tuple{Any, Any, Any}" href="#NQCDynamics.DynamicsMethods.create_problem-Tuple{Any, Any, Any}"><code>NQCDynamics.DynamicsMethods.create_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Provides the DEProblem for each type of simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/DynamicsMethods.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.get_callbacks-Tuple{NQCDynamics.AbstractSimulation}" href="#NQCDynamics.DynamicsMethods.get_callbacks-Tuple{NQCDynamics.AbstractSimulation}"><code>NQCDynamics.DynamicsMethods.get_callbacks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Select the default callbacks for this simulation type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/DynamicsMethods.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.motion!" href="#NQCDynamics.DynamicsMethods.motion!"><code>NQCDynamics.DynamicsMethods.motion!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">motion!(du, u, sim, t)</code></pre><p>As per <code>DifferentialEquations.jl</code>, this function is implemented for each method and defines the time derivatives of the <code>DynamicalVariables</code>.</p><p>We require that each implementation ensures <code>du</code> and <code>u</code> are subtypes of <code>DynamicalVariables</code> and <code>sim</code> subtypes <code>AbstractSimulation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/DynamicsMethods.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.run_trajectory-Tuple{Any, Tuple, NQCDynamics.AbstractSimulation}" href="#NQCDynamics.DynamicsMethods.run_trajectory-Tuple{Any, Tuple, NQCDynamics.AbstractSimulation}"><code>NQCDynamics.DynamicsMethods.run_trajectory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run_trajectory(u0, tspan::Tuple, sim::AbstractSimulation;
               output=(:u,), saveat=[], algorithm=select_algorithm(sim), kwargs...)</code></pre><p>Solve a single trajectory starting from <code>u0</code> with a timespan <code>tspan</code> for the simulation <code>sim</code>.</p><p><strong>Keyword arguments</strong></p><p><code>output</code> specifies the quantities that should be saved during the dynamics simulation. The options for this keyword are any of the functions found in <code>src/DynamicsMethods/output.jl</code>.</p><p>The rest of the keywords are the usual arguments for the <code>solve</code> function from <code>DifferentialEquations.jl</code>. It is possible to use <code>Unitful</code> quantities for any of the arguments since these are automatically converted to atomic units internally.</p><p><strong>Output</strong></p><p>The function returns a <code>Table</code> from <code>TypedTables.jl</code> with columns for time <code>t</code> and every quantity specified in the <code>output</code> tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/DynamicsMethods.jl#L74-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.select_algorithm-Tuple{NQCDynamics.AbstractSimulation}" href="#NQCDynamics.DynamicsMethods.select_algorithm-Tuple{NQCDynamics.AbstractSimulation}"><code>NQCDynamics.DynamicsMethods.select_algorithm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Choose a default algorithm for solving the differential equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/DynamicsMethods.jl#L55">source</a></section></article><h2 id="ClassicalMethods"><a class="docs-heading-anchor" href="#ClassicalMethods">ClassicalMethods</a><a id="ClassicalMethods-1"></a><a class="docs-heading-anchor-permalink" href="#ClassicalMethods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.ClassicalMethods.Classical" href="#NQCDynamics.DynamicsMethods.ClassicalMethods.Classical"><code>NQCDynamics.DynamicsMethods.ClassicalMethods.Classical</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Classical &lt;: DynamicsMethods.Method</code></pre><p>Type for performing classical molecular dynamics.</p><pre><code class="language-julia hljs">sim = Simulation{Classical}(Atoms(:H), Harmonic())

# output

Simulation{Classical}:
  Atoms{Float64}([:H], [1], [1837.4715941070515])
  Harmonic{Float64, Float64, Float64}
  m: Float64 1.0
  ω: Float64 1.0
  r₀: Float64 0.0
  dofs: Int64 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/ClassicalMethods/classical.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.ClassicalMethods.Langevin" href="#NQCDynamics.DynamicsMethods.ClassicalMethods.Langevin"><code>NQCDynamics.DynamicsMethods.ClassicalMethods.Langevin</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type for performing Langevin molecular dynamics.</p><pre><code class="language-julia hljs">using Unitful
sim = Simulation{Langevin}(Atoms(:H), Free(); γ=2.5, temperature=100u&quot;K&quot;)

# output

Simulation{Langevin{Float64}}:
  Atoms{Float64}([:H], [1], [1837.4715941070515])
  Free(1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/ClassicalMethods/langevin.jl#L7-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.ClassicalMethods.MDEF" href="#NQCDynamics.DynamicsMethods.ClassicalMethods.MDEF"><code>NQCDynamics.DynamicsMethods.ClassicalMethods.MDEF</code></a> — <span class="docstring-category">Type</span></header><section><div><p class="math-container">\[dr = v dt\\
dv = -\Delta U/M dt - \Gamma v dt + \sigma \sqrt{2\Gamma} dW\]</p><p><span>$\Gamma$</span> is the friction tensor with units of inverse time. For thermal dynamics we set <span>$\sigma = \sqrt{kT / M}$</span>, where <span>$T$</span> is the electronic temperature.</p><p>This is integrated using the BAOAB algorithm where the friction &quot;O&quot; step is performed in the tensor&#39;s eigenbasis. See <code>src/dynamics/mdef_baoab.jl</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/ClassicalMethods/mdef.jl#L6-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.ClassicalMethods.ThermalLangevin" href="#NQCDynamics.DynamicsMethods.ClassicalMethods.ThermalLangevin"><code>NQCDynamics.DynamicsMethods.ClassicalMethods.ThermalLangevin</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type for performing Langevin ring polymer molecular dynamics.</p><p>Currently there are separate types for classical and ring polymer versions of Langevin dynamics but they should be combined. The reason they are not at the moment is that they use different integration algorithms and require slightly different fields.</p><pre><code class="language-julia hljs">using Unitful
RingPolymerSimulation{ThermalLangevin}(Atoms(:H), Free(), 10; γ=0.1, temperature=25u&quot;K&quot;)

# output

RingPolymerSimulation{ThermalLangevin{Float64}}:
 
  Atoms{Float64}([:H], [1], [1837.4715941070515])
 
  Free(1)
  with 10 beads.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/ClassicalMethods/langevin.jl#L46-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!-Tuple{Any, Any, Any, NQCDynamics.AbstractSimulation, Any}" href="#NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!-Tuple{Any, Any, Any, NQCDynamics.AbstractSimulation, Any}"><code>NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>f1</code> in <code>DifferentialEquations.jl</code> docs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/ClassicalMethods/classical.jl#L56-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!-Tuple{Any, Any, Any, Simulation{MDEF, &lt;:NQCDynamics.Calculators.DiabaticFrictionCalculator}, Any}" href="#NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!-Tuple{Any, Any, Any, Simulation{MDEF, &lt;:NQCDynamics.Calculators.DiabaticFrictionCalculator}, Any}"><code>NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">acceleration!(dv, v, r, sim::Simulation{MDEF,&lt;:DiabaticFrictionCalculator}, t)</code></pre><p>Sets acceleration due to ground state force when using a <code>DiabaticFrictionModel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/ClassicalMethods/mdef.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.ClassicalMethods.friction!-Tuple{Any, Any, NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.ClassicalMethods.AbstractMDEF}, Any}" href="#NQCDynamics.DynamicsMethods.ClassicalMethods.friction!-Tuple{Any, Any, NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.ClassicalMethods.AbstractMDEF}, Any}"><code>NQCDynamics.DynamicsMethods.ClassicalMethods.friction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">friction!(g, r, sim, t)</code></pre><p>Evaluates friction tensor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/ClassicalMethods/mdef.jl#L49-L53">source</a></section></article><h2 id="MappingVariableMethods"><a class="docs-heading-anchor" href="#MappingVariableMethods">MappingVariableMethods</a><a id="MappingVariableMethods-1"></a><a class="docs-heading-anchor-permalink" href="#MappingVariableMethods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.MappingVariableMethods.NRPMD" href="#NQCDynamics.DynamicsMethods.MappingVariableMethods.NRPMD"><code>NQCDynamics.DynamicsMethods.MappingVariableMethods.NRPMD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NRPMD{T} &lt;: DynamicsMethods.Method</code></pre><p>Nonadiabatic ring polymer molecular dynamics Uses Meyer-Miller-Stock-Thoss mapping variables for electronic degrees of freedom and ring polymer formalism for nuclear degrees of freedom.</p><pre><code class="language-julia hljs">RingPolymerSimulation{NRPMD}(Atoms(:H), DoubleWell(), 10)

# output

RingPolymerSimulation{NRPMD{Float64}}:
 
  Atoms{Float64}([:H], [1], [1837.4715941070515])
 
  DoubleWell{Int64, Int64, Int64, Int64}
  mass: Int64 1
  ω: Int64 1
  γ: Int64 1
  Δ: Int64 1
 
  with 10 beads.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/MappingVariableMethods/nrpmd.jl#L9-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.MappingVariableMethods.eCMM" href="#NQCDynamics.DynamicsMethods.MappingVariableMethods.eCMM"><code>NQCDynamics.DynamicsMethods.MappingVariableMethods.eCMM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">eCMM{T} &lt;: DynamicsMethods.Method</code></pre><p><strong>References</strong></p><ul><li><a href="../../../references/#HeGong2021">Xin He, Zhihao Gong, Baihua Wu, Jian Liu (2021)</a></li><li><a href="../../../references/#HeWu2021">Xin He, Baihua Wu, Zhihao Gong, Jian Liu (2021)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/MappingVariableMethods/cmm.jl#L5-L12">source</a></section></article><h2 id="SurfaceHoppingMethods"><a class="docs-heading-anchor" href="#SurfaceHoppingMethods">SurfaceHoppingMethods</a><a id="SurfaceHoppingMethods-1"></a><a class="docs-heading-anchor-permalink" href="#SurfaceHoppingMethods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">SurfaceHoppingMethods</code></pre><p>Implementation for surface hopping methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/SurfaceHoppingMethods/SurfaceHoppingMethods.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.FSSH" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.FSSH"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.FSSH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FSSH{T} &lt;: SurfaceHopping</code></pre><p>Type for fewest-switches surface hopping</p><pre><code class="language-julia hljs">Simulation{FSSH}(Atoms(:H), Free())

# output

Simulation{FSSH{Float64}}:
  Atoms{Float64}([:H], [1], [1837.4715941070515])
  Free(1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/SurfaceHoppingMethods/fssh.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for all surface hopping methods.</p><p>Surface hopping methods follow the structure set out in this file. The nuclear and electronic variables are propagated by the <code>motion!</code> function. The surface hopping procedure is handled by the <code>HoppingCallback</code> which uses the functions <code>check_hop!</code> and <code>execute_hop!</code> as its <code>condition</code> and <code>affect!</code>.</p><p>To add a new surface hopping scheme, you must create a new struct and define methods for <code>evaluate_hopping_probability!</code>, <code>select_new_state</code>, and <code>rescale_velocity!</code>.</p><p>See <code>fssh.jl</code> for an example implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/SurfaceHoppingMethods/SurfaceHoppingMethods.jl#L37-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_a-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, AbstractMatrix}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_a-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, AbstractMatrix}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_a(sim::AbstractSimulation{&lt;:SurfaceHopping}, coupling::AbstractMatrix)</code></pre><p>Equation 40 from <a href="../../../references/#HammesSchiffer1994">Sharon Hammes‐Schiffer, John C. Tully (1994)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/SurfaceHoppingMethods/fssh.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_b-Tuple{AbstractMatrix, AbstractMatrix}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_b-Tuple{AbstractMatrix, AbstractMatrix}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_b(coupling::AbstractMatrix, velocity::AbstractMatrix)</code></pre><p>Equation 41 from <a href="../../../references/#HammesSchiffer1994">Sharon Hammes‐Schiffer, John C. Tully (1994)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/SurfaceHoppingMethods/fssh.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{NQCDynamics.AbstractSimulation{&lt;:FSSH}, Any, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{NQCDynamics.AbstractSimulation{&lt;:FSSH}, Any, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate_hopping_probability!(sim::Simulation{&lt;:FSSH}, u, dt)</code></pre><p>Evaluates the probability of hopping from the current state to all other states</p><p><strong>Implementation</strong></p><ul><li><code>σ</code> is Hermitan so the choice <code>σ[m,s]</code> or <code>σ[s,m]</code> is irrelevant; we take the real part.</li><li>&#39;d&#39; is skew-symmetric so here the indices are important.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/SurfaceHoppingMethods/fssh.jl#L57-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function should set the field <code>sim.method.hopping_probability</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/SurfaceHoppingMethods/SurfaceHoppingMethods.jl#L102-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.extract_nonadiabatic_coupling-Tuple{Any, Any, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.extract_nonadiabatic_coupling-Tuple{Any, Any, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.extract_nonadiabatic_coupling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extract_nonadiabatic_coupling(coupling, new_state, old_state)</code></pre><p>Extract the nonadiabatic coupling vector between states <code>new_state</code> and <code>old_state</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/SurfaceHoppingMethods/fssh.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.perform_rescaling!-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any, Any, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.perform_rescaling!-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any, Any, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.perform_rescaling!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perform_rescaling!(
    sim::AbstractSimulation{&lt;:SurfaceHopping}, velocity, velocity_rescale, d
)</code></pre><p>Equation 33 from <a href="../../../references/#HammesSchiffer1994">Sharon Hammes‐Schiffer, John C. Tully (1994)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/SurfaceHoppingMethods/fssh.jl#L190-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!-Tuple{NQCDynamics.AbstractSimulation{&lt;:FSSH}, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!-Tuple{NQCDynamics.AbstractSimulation{&lt;:FSSH}, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale_velocity!(sim::AbstractSimulation{&lt;:FSSH}, u)::Bool</code></pre><p>Rescale the velocity in the direction of the nonadiabatic coupling.</p><p><strong>References</strong></p><p><a href="../../../references/#HammesSchiffer1994">Sharon Hammes‐Schiffer, John C. Tully (1994)</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/SurfaceHoppingMethods/fssh.jl#L115-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function should modify the velocity and return a <code>Bool</code> that determines whether the state change should take place.</p><p>This only needs to be implemented if the velocity should be modified during a hop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/SurfaceHoppingMethods/SurfaceHoppingMethods.jl#L117-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.select_new_state-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.select_new_state-Tuple{NQCDynamics.AbstractSimulation{&lt;:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.select_new_state</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function should return the desired state determined by the probability. Should return the original state if no hop is desired.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/SurfaceHoppingMethods/SurfaceHoppingMethods.jl#L109-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.unpack_states-Tuple{NQCDynamics.AbstractSimulation{&lt;:FSSH}}" href="#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.unpack_states-Tuple{NQCDynamics.AbstractSimulation{&lt;:FSSH}}"><code>NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.unpack_states</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unpack_states(sim)</code></pre><p>Get the two states that we are hopping between.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/SurfaceHoppingMethods/fssh.jl#L150-L154">source</a></section></article><h2 id="EhrenfestMethods"><a class="docs-heading-anchor" href="#EhrenfestMethods">EhrenfestMethods</a><a id="EhrenfestMethods-1"></a><a class="docs-heading-anchor-permalink" href="#EhrenfestMethods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.EhrenfestMethods.AbstractEhrenfest" href="#NQCDynamics.DynamicsMethods.EhrenfestMethods.AbstractEhrenfest"><code>NQCDynamics.DynamicsMethods.EhrenfestMethods.AbstractEhrenfest</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for Ehrenfest method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/EhrenfestMethods/EhrenfestMethods.jl#L20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.EhrenfestMethods.Ehrenfest" href="#NQCDynamics.DynamicsMethods.EhrenfestMethods.Ehrenfest"><code>NQCDynamics.DynamicsMethods.EhrenfestMethods.Ehrenfest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Ehrenfest{T} &lt;: AbstractEhrenfest</code></pre><p>Ehrenfest molecular dynamics. Classical molecular dynamics where the force is derived by averaging contributions from multiple electronic states.</p><pre><code class="language-julia hljs">Simulation{Ehrenfest}(Atoms(:H), DoubleWell())

# output

Simulation{Ehrenfest{Float64}}:
  Atoms{Float64}([:H], [1], [1837.4715941070515])
  DoubleWell{Int64, Int64, Int64, Int64}
  mass: Int64 1
  ω: Int64 1
  γ: Int64 1
  Δ: Int64 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/EhrenfestMethods/ehrenfest.jl#L7-L26">source</a></section></article><h2 id="IntegrationAlgorithms"><a class="docs-heading-anchor" href="#IntegrationAlgorithms">IntegrationAlgorithms</a><a id="IntegrationAlgorithms-1"></a><a class="docs-heading-anchor-permalink" href="#IntegrationAlgorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.MInt" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.MInt"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.MInt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MInt &lt;: OrdinaryDiffEq.OrdinaryDiffEqAlgorithm</code></pre><p>Second order symplectic momentum integral algorithm.</p><p><strong>Reference</strong></p><p><a href="https://doi.org/10.1063/1.5005557">J. Chem. Phys. 148, 102326 (2018)</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/IntegrationAlgorithms/mint.jl#L11-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.RingPolymerMInt" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.RingPolymerMInt"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.RingPolymerMInt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RingPolymerMInt &lt;: OrdinaryDiffEq.OrdinaryDiffEqAlgorithm</code></pre><p>Second order symplectic momentum integral algorithm applied to NRPMD.</p><p><strong>Reference</strong></p><p><a href="https://doi.org/10.1063/1.5005557">J. Chem. Phys. 148, 102326 (2018)</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/IntegrationAlgorithms/ringpolymer_mint.jl#L11-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_C_propagator-Tuple{AbstractVector, AbstractMatrix, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_C_propagator-Tuple{AbstractVector, AbstractMatrix, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_C_propagator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>C</code> propagator for the mapping variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/IntegrationAlgorithms/ringpolymer_mint.jl#L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_D_propagator-Tuple{AbstractVector, AbstractMatrix, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_D_propagator-Tuple{AbstractVector, AbstractMatrix, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_D_propagator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>D</code> propagator for the mapping variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/IntegrationAlgorithms/ringpolymer_mint.jl#L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_gamma-Tuple{AbstractMatrix, AbstractVector, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_gamma-Tuple{AbstractMatrix, AbstractVector, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_gamma</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>Γ</code> variable used to calculate the nuclear propagators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/IntegrationAlgorithms/ringpolymer_mint.jl#L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, Any}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, Any}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the force due to the mapping variables.</p><p>Equivalent to this but doesn&#39;t allocate:      return 0.5 * (q&#39;<em>E</em>q + p&#39;<em>E</em>p) - q&#39;<em>F</em>p</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/IntegrationAlgorithms/mint.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the force due to the mapping variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/IntegrationAlgorithms/ringpolymer_mint.jl#L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_xi-Tuple{AbstractMatrix, AbstractVector, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_xi-Tuple{AbstractMatrix, AbstractVector, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_xi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>Ξ</code> variable used to calculate the nuclear propagators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/IntegrationAlgorithms/ringpolymer_mint.jl#L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_C_propagator!-Tuple{Any, Any, LinearAlgebra.Eigen, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_C_propagator!-Tuple{Any, Any, LinearAlgebra.Eigen, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_C_propagator!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>C</code> propagator for the mapping variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/IntegrationAlgorithms/mint.jl#L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_D_propagator!-Tuple{Any, Any, LinearAlgebra.Eigen, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_D_propagator!-Tuple{Any, Any, LinearAlgebra.Eigen, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_D_propagator!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>D</code> propagator for the mapping variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/IntegrationAlgorithms/mint.jl#L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_gamma!-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_gamma!-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_gamma!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>Γ</code> variable used to calculate the nuclear propagators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/IntegrationAlgorithms/mint.jl#L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_xi!-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector, Real}" href="#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_xi!-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector, Real}"><code>NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_xi!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>Ξ</code> variable used to calculate the nuclear propagators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NQCD/NQCDynamics.jl/blob/b3e344689a1b2dc6a2b84ef98671cff625c162b1/src/DynamicsMethods/IntegrationAlgorithms/mint.jl#L161">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../calculators/">« Calculators</a><a class="docs-footer-nextpage" href="../dynamicsoutputs/">DynamicsOutputs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.14 on <span class="colophon-date" title="Thursday 10 March 2022 15:39">Thursday 10 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
