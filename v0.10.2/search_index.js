var documenterSearchIndex = {"docs":
[{"location":"examples/spinboson/#Ohmic-spin-boson-nonequilibrium-population-dynamics","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"","category":"section"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"The spin-boson model is widely used as a model for condensed phase quantum dynamics. It is defined by a system-bath Hamiltonian where the system is a 2-state spin coupled to a bath of harmonic oscillators. This example shows how to perform nonequilibrium population dynamics with the spin-boson model using a bath characterised by the Ohmic spectral density. We will be using model B from the work of Xing Gao, Maximilian A. C. Saller, Yudan Liu, Aaron Kelly, Jeremy O. Richardson, Eitan Geva (2020).","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"Our boson bath will have 100 oscillators, each with a mass of 1. Here, we also set up the model with the ohmic density and the parameters that match up with our reference (Xing Gao, Maximilian A. C. Saller, Yudan Liu, Aaron Kelly, Jeremy O. Richardson, Eitan Geva (2020)). The ohmic density is given a cutoff frequency of 2.5 and a Kondo parameter of 0.09. The model is symmetric, with the energy bias between states equal to 0.0, and the coupling between states set to 1.","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"using NQCDynamics\nN = 100\natoms = Atoms(fill(1, N))\nβ = 5\nT = 1 / β\ndensity = OhmicSpectralDensity(2.5, 0.09)\nmodel = SpinBoson(density, N, 0.0, 1.0)\nnothing # hide","category":"page"},{"location":"examples/spinboson/#Initial-conditions","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Initial conditions","text":"","category":"section"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"For the initial conditions, we will sample directly from a Wigner distribution for the nuclear degrees of freedom. Since our nuclear degrees of freedom are harmonic, the Wigner distribution has an analytic form and we can use the distributions included in the package. The position and velocity variables we create here are Vectors of Normal distributions. Inside the DynamicalDistribution they will provide samples that match the size of the system. The initial electronic state is confined to 1 with SingleState(1).","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"position = PositionHarmonicWigner.(model.ωⱼ, β, 1)\nvelocity = VelocityHarmonicWigner.(model.ωⱼ, β, 1)\ndistribution = DynamicalDistribution(velocity, position, (1, 100)) * SingleState(1)\nnothing # hide","category":"page"},{"location":"examples/spinboson/#Dynamics","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Dynamics","text":"","category":"section"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"Now that we have a distribution from which we can sample our initial conditions, we can run ensembles of trajectories and calculate the population correlation functions. Let's compare the results obtained using FSSH and Ehrenfest.","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"fssh = Simulation{FSSH}(atoms, model)\nehrenfest = Simulation{Ehrenfest}(atoms, model)\n\nsaveat = 0:0.1:20\noutput = TimeCorrelationFunctions.PopulationCorrelationFunction(fssh, Diabatic())\nu_init = [zeros(2,2) for i=1:length(saveat)]\nensemble_fssh = run_ensemble(fssh, (0.0, 20.0), distribution;\n    saveat=saveat, trajectories=100, output, reduction=:mean, u_init=copy(u_init))\noutput = TimeCorrelationFunctions.PopulationCorrelationFunction(ehrenfest, Diabatic())\nensemble_ehrenfest = run_ensemble(ehrenfest, (0.0, 20.0), distribution;\n    saveat=saveat, trajectories=100, output, reduction=:mean, u_init=copy(u_init))\nnothing # hide","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"Here, we can see the population difference between the two states.","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"using Plots\nplot(saveat, [p[1,1] - p[1,2] for p in ensemble_fssh], label=\"FSSH\")\nplot!(saveat, [p[1,1] - p[1,2] for p in ensemble_ehrenfest], label=\"Ehrenfest\")\nxlabel!(\"Time /a.u.\")\nylabel!(\"Population difference\")","category":"page"},{"location":"examples/spinboson/","page":"Ohmic spin-boson nonequilibrium population dynamics","title":"Ohmic spin-boson nonequilibrium population dynamics","text":"The exact result for this model, along with various mapping methods can be found  in the work of Xing Gao, Maximilian A. C. Saller, Yudan Liu, Aaron Kelly, Jeremy O. Richardson, Eitan Geva (2020). We can see that even with just 100 trajectories, our Ehrenfest result closely matches theirs. The FSSH is quite clearly underconverged with only 100 trajectories due to the discontinuous nature of the individual trajectories. Feel free to try this for yourself and see what the converged FSSH result looks like!","category":"page"},{"location":"examples/tully_scattering/#examples-tully-model-two","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"","category":"section"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"In this section we aim to reproduce the results of Fig. 5 from John C. Tully (1990). This figure presents the scattering outcomes when a particle interacts with Tully's model 2 with an increasing magnitude of incident kinetic energy.","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"To reproduce this figure, first, let's set up our system parameters:","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"using NQCDynamics\n\nsim = Simulation{FSSH}(Atoms(2000), TullyModelTwo())","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"!!! note Atomic units","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"Recall that all of are units are atomic by default, this mass of 2000 is similar to\nthat of a hydrogen atom.","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"Each data point in the figure is obtained from an ensemble average of trajectories. We can use our Ensembles setup to run a set of trajectories for every single momentum value. Firstly, we can prepare the parts that will be the same for every ensemble:","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"using ComponentArrays: ComponentVector\n\noutput = Ensembles.OutputStateResolvedScattering1D(sim, :adiabatic)","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"Here, we are using the OutputStateResolvedScattering1D along with the MeanReduction which will give us the average scattering outcome from the entire ensemble. Each trajectory outputs the scattering outcome along with its final adiabatic state, and the reduction computes the average over all trajectories.","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"Next, we can choose how many trajectories we want to perform for each ensemble, and choose the range of momentum values:","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"ntraj = 500\nmomenta = 9:2:50","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"note: Range notation\nHere we uses Julia's range operator to generate a set of values from 9 to 50 with a spacing of 2: 9, 11, 13, ..., 49. The final value of 50 is not included since a step size of 2 starting from 9 allows us to include only odd numbers.","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"Since each ensemble requires different initial conditions, we will specify the trajectory timespan and the distribution inside the loop. Before the loop begins, we will create an empty list to store the results, and append to this list after every iteration. The distribution we create produces initial conditions where each trajectory has momentum k and starts at a position of -5. ","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"result = []\nfor k in momenta # Iterate through each momentum value\n    v = k / sim.atoms.masses[1] # Starting velocity\n    r = -5 # Starting position\n    tspan = (0, 2abs(r)/v)\n    distribution = DynamicalDistribution(v, -5, size(sim)) * SingleState(1, Adiabatic())\n\n    out = run_ensemble(sim, tspan, distribution;\n        trajectories=ntraj, output=output, reduction=:mean,\n        u_init=ComponentVector(reflection=zeros(2), transmission=zeros(2))\n    )\n\n    push!(result, out)\nend\n\nresult","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"tip: Adaptive timespan\nSince the trajectories with larger momentum will exit the scattering region sooner, we scale the timespan to save computational time. Using tspan = (0, 2abs(r)/v) allows enough time such that a particle will be able to travel a total distance of 2r at a constant velocity of v. This is sufficient to ensure the particle has left the interaction region. Alternatively, we could define a callback to terminate the simulation early.","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"Now we can plot our simulation results. We format this plot to match Fig. 3 from Farnaz A. Shakib, Pengfei Huo (2017) which also reproduces Fig. 5 from John C. Tully (1990). We manage to reproduce the FSSH results quite accurately by visual comparison, though a larger number of trajectories would lead to better convergence. Since all of the examples run during the documentation build, we use a minimal number of trajectories to optimise the build time.","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"using CairoMakie\n\nf = Figure()\nax = Axis(f[1,1], xlabel=\"Incident momentum / a.u.\", ylabel=\"Scattering probability\")\n\nr1 = [r.reflection[1] for r in result]\nt1 = [r.transmission[1] for r in result]\nt2 = [r.transmission[2] for r in result]\n\nscatter!(ax, momenta, r1; label=\"R1\", color=:red)\nscatter!(ax, momenta, t1; label=\"T1\", color=:green)\nscatter!(ax, momenta, t2; label=\"T2\", color=:blue)\naxislegend(ax)\n\nf","category":"page"},{"location":"examples/tully_scattering/","page":"Scattering probabilities for TullyModelTwo","title":"Scattering probabilities for TullyModelTwo","text":"As in Farnaz A. Shakib, Pengfei Huo (2017), R1, T1, T2 refer to reflection on state 1, transmission on state 1 and transmission on state 2 respectively. For this model, surface hopping is successful in closely approximating the exact quantum result, especially at higher momentum values. Refer to John C. Tully (1990) and Farnaz A. Shakib, Pengfei Huo (2017) for a detailed discussion of the results.","category":"page"},{"location":"api/NQCModels/nninterfaces/#NNInterfaces","page":"NNInterfaces","title":"NNInterfaces","text":"","category":"section"},{"location":"api/NQCModels/nninterfaces/","page":"NNInterfaces","title":"NNInterfaces","text":"Modules=[NNInterfaces]","category":"page"},{"location":"api/NQCModels/nninterfaces/#NNInterfaces.H2AgModel","page":"NNInterfaces","title":"NNInterfaces.H2AgModel","text":"J. Phys. Chem. Lett. 2019, 10, 4962−4967 J. Phys. Chem. C 2020, 124, 186−195\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/frictionmodels/#FrictionModels","page":"FrictionModels","title":"FrictionModels","text":"","category":"section"},{"location":"api/NQCModels/frictionmodels/","page":"FrictionModels","title":"FrictionModels","text":"Modules=[NQCModels.FrictionModels]","category":"page"},{"location":"api/NQCModels/frictionmodels/#NQCModels.FrictionModels.ASEFrictionProvider","page":"FrictionModels","title":"NQCModels.FrictionModels.ASEFrictionProvider","text":"ASEFrictionProvider{A} <: ElectronicFrictionProvider\n\nObtain the electronic friction from an ASE calculator that implements get_friction_tensor. Assumes that the units of friction are \"eV/Å/Å\". Construct by passing the ase atoms object with the calculator already attached.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/frictionmodels/#NQCModels.FrictionModels.AdiabaticFrictionModel","page":"FrictionModels","title":"NQCModels.FrictionModels.AdiabaticFrictionModel","text":"AdiabaticFrictionModel <: AdiabaticModel\n\nAdiabaticFrictionModels must implement potential!, derivative!, and friction!\n\npotential! and friction! should be the same as for the AdiabaticModel.\n\nfriction! must fill an AbstractMatrix with size = (ndofs*natoms, ndofs*natoms).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/frictionmodels/#NQCModels.FrictionModels.CompositeFrictionModel","page":"FrictionModels","title":"NQCModels.FrictionModels.CompositeFrictionModel","text":"CompositeFrictionModel{M,F} <: AdiabaticFrictionModel\n\nCombine an AdiabaticModel with an ElectronicFrictionProvider.\n\nThis allows for arbitrary composition of potentials and friction providers, such that any adiabatic model can be augmented with any form of electronic friction.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/frictionmodels/#NQCModels.FrictionModels.ElectronicFrictionProvider","page":"FrictionModels","title":"NQCModels.FrictionModels.ElectronicFrictionProvider","text":"ElectronicFrictionProvider\n\nAbstract type for defining models that provide electronic friction only. Subtypes of this should implement friction! and ndofs.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/frictionmodels/#NQCModels.FrictionModels.RandomFriction","page":"FrictionModels","title":"NQCModels.FrictionModels.RandomFriction","text":"RandomFriction <: ElectronicFrictionProvider\n\nProvide a random positive semi-definite matrix of friction values. Used mostly for testing and examples.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/frictionmodels/#NQCModels.FrictionModels.friction!","page":"FrictionModels","title":"NQCModels.FrictionModels.friction!","text":"friction!(model::AdiabaticFrictionModel, F, R:AbstractMatrix)\n\nFill F with the electronic friction as a function of the positions R.\n\nThis need only be implemented for AdiabaticFrictionModels.\n\n\n\n\n\n","category":"function"},{"location":"api/NQCModels/frictionmodels/#NQCModels.FrictionModels.friction-Tuple{NQCModels.FrictionModels.AdiabaticFrictionModel, Any}","page":"FrictionModels","title":"NQCModels.FrictionModels.friction","text":"friction(model::Model, R)\n\nObtain the friction for the current position R.\n\nThis is an allocating version of friction!.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/calculators/#Calculators","page":"Calculators","title":"Calculators","text":"","category":"section"},{"location":"api/NQCDynamics/calculators/","page":"Calculators","title":"Calculators","text":"Modules=[NQCDynamics.Calculators]","category":"page"},{"location":"api/NQCDynamics/calculators/#NQCDynamics.Calculators","page":"Calculators","title":"NQCDynamics.Calculators","text":"Calculators\n\nThis module exists to bridge the gap between the Models and the Dynamics.\n\nHere, we provide functions and types for evaluating and storing quantities obtained from the Models. In addition any further manipulation of those quantities, such as computing eigenvalues, is included here.\n\nThis module is largely needed to facilitate integration of both ring polymer and classical dynamics to allow using the same models and functions for both. Specific ring polymer types are provided that have the extra fields and methods needed to evaluate the quantities for each bead. \n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/calculators/#NQCDynamics.Calculators.quantities","page":"Calculators","title":"NQCDynamics.Calculators.quantities","text":"Each of the quantities specified here has functions: get_quantity(calculator, r) evaluate_quantity!(calculator, r)!\n\nThe user should access only the former. This will ensure quantities are correctly evaluated and cached accordingly.\n\nThe latter is called by the former and is where the details required to calculate the quantity are found.\n\n\n\n\n\n","category":"constant"},{"location":"api/NQCDynamics/calculators/#NQCDynamics.Calculators.AbstractCalculator","page":"Calculators","title":"NQCDynamics.Calculators.AbstractCalculator","text":"AbstractCalculator{M<:Model}\n\nTop-level type for all calculators.\n\nEach concrete calculator contains the Model and the fields to store the quantities obtained from the model.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/calculators/#NQCDynamics.Calculators.evaluate_friction!-Tuple{NQCDynamics.Calculators.DiabaticFrictionCalculator, AbstractMatrix}","page":"Calculators","title":"NQCDynamics.Calculators.evaluate_friction!","text":"evaluate_friction!(calc::DiabaticFrictionCalculator, R::AbstractMatrix)\n\nEvaluate the electronic friction for a model given in the diabatic representation.\n\nγ = 2πħ ⱼ 1dHjjdH1 δ(ωⱼ)  ωⱼ\n\nNote that the delta function is approximated by a normalised gaussian.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/calculators/#NQCDynamics.Calculators.evaluate_nonadiabatic_coupling-Tuple{StaticArrays.SMatrix, StaticArrays.SVector}","page":"Calculators","title":"NQCDynamics.Calculators.evaluate_nonadiabatic_coupling","text":"References\n\nHammesSchifferTullyJChemPhys10146571994 Eq. (32)\nSubotnikBellonziAnnuRevPhyschem673872016, section 2.3\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/calculators/#NQCDynamics.Calculators.update_electronics!-Tuple{NQCDynamics.Calculators.AbstractDiabaticCalculator, AbstractArray}","page":"Calculators","title":"NQCDynamics.Calculators.update_electronics!","text":"Evaluates all electronic properties for the current position r.\n\nProperties evaluated:\n\nDiabatic potential\nDiabatic derivative\nEigenvalues and eigenvectors\nAdiabatic derivative\nNonadiabatic coupling\n\nThis should no longer be used, instead access the quantities directly with get_quantity(calc, r).\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#DynamicsMethods","page":"DynamicsMethods","title":"DynamicsMethods","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsmethods/","page":"DynamicsMethods","title":"DynamicsMethods","text":"Modules=[NQCDynamics.DynamicsMethods]","category":"page"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods","text":"This module contains functions and types necessary for performing nonadiabatic molecular dynamics.\n\nDynamics is performed using DifferentialEquations.jl. As such, this module is centered around the implementation of the functions necessary to integrate the dynamics.\n\nFor deterministic Hamiltonian methods, the central function is DynamicsMethods.motion!, which is the inplace form of the function to be integrated by DifferentialEquations.jl.\n\nFurther, methods that have discontinuities, such as surface hopping, use the callback interface provided by DifferentialEquations.jl.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.Method","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.Method","text":"Each type of dynamics subtypes Method which is passed to the AbstractSimulation as a parameter to determine the type of dynamics desired.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.DynamicsVariables-Tuple{NQCDynamics.AbstractSimulation, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.DynamicsVariables","text":"DynamicsVariables(::AbstractSimulation, args...)\n\nFor each dynamics method this function is implemented to provide the variables for the dynamics in the appropriate format.\n\nBy default, DynamicsVariables is set up for the classical case and takes sim, v, r as arguments and returns a ComponentVector(v=v, r=r) which is used as a container for the velocities and positions during classical dynamics.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.create_problem-Tuple{Any, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.create_problem","text":"Provides the DEProblem for each type of simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.get_callbacks-Tuple{NQCDynamics.AbstractSimulation}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.get_callbacks","text":"Select the default callbacks for this simulation type.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.motion!","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.motion!","text":"motion!(du, u, sim, t)\n\nAs per DifferentialEquations.jl, this function is implemented for each method and defines the time derivatives of the DynamicalVariables.\n\nWe require that each implementation ensures du and u are subtypes of DynamicalVariables and sim subtypes AbstractSimulation.\n\n\n\n\n\n","category":"function"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.run_trajectory-Tuple{Any, Tuple, NQCDynamics.AbstractSimulation}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.run_trajectory","text":"run_trajectory(u0, tspan::Tuple, sim::AbstractSimulation;\n               output=(:u,), saveat=[], algorithm=select_algorithm(sim), kwargs...)\n\nSolve a single trajectory starting from u0 with a timespan tspan for the simulation sim.\n\nKeyword arguments\n\noutput specifies the quantities that should be saved during the dynamics simulation. The options for this keyword are any of the functions found in src/DynamicsMethods/output.jl.\n\nThe rest of the keywords are the usual arguments for the solve function from DifferentialEquations.jl. It is possible to use Unitful quantities for any of the arguments since these are automatically converted to atomic units internally.\n\nOutput\n\nThe function returns a Table from TypedTables.jl with columns for time t and every quantity specified in the output tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.select_algorithm-Tuple{NQCDynamics.AbstractSimulation}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.select_algorithm","text":"Choose a default algorithm for solving the differential equation.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#ClassicalMethods","page":"DynamicsMethods","title":"ClassicalMethods","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsmethods/","page":"DynamicsMethods","title":"DynamicsMethods","text":"Modules=[NQCDynamics.DynamicsMethods.ClassicalMethods]","category":"page"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.ClassicalMethods.Classical","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.ClassicalMethods.Classical","text":"Classical <: DynamicsMethods.Method\n\nType for performing classical molecular dynamics.\n\nsim = Simulation{Classical}(Atoms(:H), Harmonic())\n\n# output\n\nSimulation{Classical}:\n  Atoms{Float64}([:H], [1], [1837.4715941070515])\n  Harmonic{Float64, Float64, Float64}\n  m: Float64 1.0\n  ω: Float64 1.0\n  r₀: Float64 0.0\n  dofs: Int64 1\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.ClassicalMethods.Langevin","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.ClassicalMethods.Langevin","text":"Type for performing Langevin molecular dynamics.\n\nusing Unitful\nsim = Simulation{Langevin}(Atoms(:H), Free(); γ=2.5, temperature=100u\"K\")\n\n# output\n\nSimulation{Langevin{Float64}}:\n  Atoms{Float64}([:H], [1], [1837.4715941070515])\n  Free(1)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.ClassicalMethods.MDEF","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.ClassicalMethods.MDEF","text":"dr = v dt\ndv = -Delta UM dt - Gamma v dt + sigma sqrt2Gamma dW\n\nGamma is the friction tensor with units of inverse time. For thermal dynamics we set sigma = sqrtkT  M, where T is the electronic temperature.\n\nThis is integrated using the BAOAB algorithm where the friction \"O\" step is performed in the tensor's eigenbasis. See src/dynamics/mdef_baoab.jl for details.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.ClassicalMethods.ThermalLangevin","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.ClassicalMethods.ThermalLangevin","text":"Type for performing Langevin ring polymer molecular dynamics.\n\nCurrently there are separate types for classical and ring polymer versions of Langevin dynamics but they should be combined. The reason they are not at the moment is that they use different integration algorithms and require slightly different fields.\n\nusing Unitful\nRingPolymerSimulation{ThermalLangevin}(Atoms(:H), Free(), 10; γ=0.1, temperature=25u\"K\")\n\n# output\n\nRingPolymerSimulation{ThermalLangevin{Float64}}:\n \n  Atoms{Float64}([:H], [1], [1837.4715941070515])\n \n  Free(1)\n  with 10 beads.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!-Tuple{Any, Any, Any, NQCDynamics.AbstractSimulation, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!","text":"f1 in DifferentialEquations.jl docs.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!-Tuple{Any, Any, Any, Simulation{MDEF, <:NQCDynamics.Calculators.DiabaticFrictionCalculator}, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.ClassicalMethods.acceleration!","text":"acceleration!(dv, v, r, sim::Simulation{MDEF,<:DiabaticFrictionCalculator}, t)\n\nSets acceleration due to ground state force when using a DiabaticFrictionModel.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.ClassicalMethods.friction!-Tuple{Any, Any, NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.ClassicalMethods.AbstractMDEF}, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.ClassicalMethods.friction!","text":"friction!(g, r, sim, t)\n\nEvaluates friction tensor\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#MappingVariableMethods","page":"DynamicsMethods","title":"MappingVariableMethods","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsmethods/","page":"DynamicsMethods","title":"DynamicsMethods","text":"Modules=[NQCDynamics.DynamicsMethods.MappingVariableMethods]","category":"page"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.MappingVariableMethods.NRPMD","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.MappingVariableMethods.NRPMD","text":"NRPMD{T} <: DynamicsMethods.Method\n\nNonadiabatic ring polymer molecular dynamics Uses Meyer-Miller-Stock-Thoss mapping variables for electronic degrees of freedom and ring polymer formalism for nuclear degrees of freedom.\n\nRingPolymerSimulation{NRPMD}(Atoms(:H), DoubleWell(), 10)\n\n# output\n\nRingPolymerSimulation{NRPMD{Float64}}:\n \n  Atoms{Float64}([:H], [1], [1837.4715941070515])\n \n  DoubleWell{Int64, Int64, Int64, Int64}\n  mass: Int64 1\n  ω: Int64 1\n  γ: Int64 1\n  Δ: Int64 1\n \n  with 10 beads.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.MappingVariableMethods.eCMM","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.MappingVariableMethods.eCMM","text":"eCMM{T} <: DynamicsMethods.Method\n\nReferences\n\nXin He, Zhihao Gong, Baihua Wu, Jian Liu (2021)\nXin He, Baihua Wu, Zhihao Gong, Jian Liu (2021)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#SurfaceHoppingMethods","page":"DynamicsMethods","title":"SurfaceHoppingMethods","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsmethods/","page":"DynamicsMethods","title":"DynamicsMethods","text":"Modules=[NQCDynamics.DynamicsMethods.SurfaceHoppingMethods]","category":"page"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods","text":"SurfaceHoppingMethods\n\nImplementation for surface hopping methods.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.FSSH","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.FSSH","text":"FSSH{T} <: SurfaceHopping\n\nType for fewest-switches surface hopping\n\nSimulation{FSSH}(Atoms(:H), Free())\n\n# output\n\nSimulation{FSSH{Float64}}:\n  Atoms{Float64}([:H], [1], [1837.4715941070515])\n  Free(1)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping","text":"Abstract type for all surface hopping methods.\n\nSurface hopping methods follow the structure set out in this file. The nuclear and electronic variables are propagated by the motion! function. The surface hopping procedure is handled by the HoppingCallback which uses the functions check_hop! and execute_hop! as its condition and affect!.\n\nTo add a new surface hopping scheme, you must create a new struct and define methods for evaluate_hopping_probability!, select_new_state, and rescale_velocity!.\n\nSee fssh.jl for an example implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_a-Tuple{NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, AbstractMatrix}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_a","text":"calculate_a(sim::AbstractSimulation{<:SurfaceHopping}, coupling::AbstractMatrix)\n\nEquation 40 from Sharon Hammes‐Schiffer, John C. Tully (1994).\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_b-Tuple{AbstractMatrix, AbstractMatrix}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.calculate_b","text":"calculate_b(coupling::AbstractMatrix, velocity::AbstractMatrix)\n\nEquation 41 from Sharon Hammes‐Schiffer, John C. Tully (1994).\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{NQCDynamics.AbstractSimulation{<:FSSH}, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!","text":"evaluate_hopping_probability!(sim::Simulation{<:FSSH}, u, dt)\n\nEvaluates the probability of hopping from the current state to all other states\n\nImplementation\n\nσ is Hermitan so the choice σ[m,s] or σ[s,m] is irrelevant; we take the real part.\n'd' is skew-symmetric so here the indices are important.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!-Tuple{NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.evaluate_hopping_probability!","text":"This function should set the field sim.method.hopping_probability.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.extract_nonadiabatic_coupling-Tuple{Any, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.extract_nonadiabatic_coupling","text":"extract_nonadiabatic_coupling(coupling, new_state, old_state)\n\nExtract the nonadiabatic coupling vector between states new_state and old_state\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.perform_rescaling!-Tuple{NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any, Any, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.perform_rescaling!","text":"perform_rescaling!(\n    sim::AbstractSimulation{<:SurfaceHopping}, velocity, velocity_rescale, d\n)\n\nEquation 33 from Sharon Hammes‐Schiffer, John C. Tully (1994).\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!-Tuple{NQCDynamics.AbstractSimulation{<:FSSH}, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!","text":"rescale_velocity!(sim::AbstractSimulation{<:FSSH}, u)::Bool\n\nRescale the velocity in the direction of the nonadiabatic coupling.\n\nReferences\n\nSharon Hammes‐Schiffer, John C. Tully (1994)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!-Tuple{NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.rescale_velocity!","text":"This function should modify the velocity and return a Bool that determines whether the state change should take place.\n\nThis only needs to be implemented if the velocity should be modified during a hop.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.select_new_state-Tuple{NQCDynamics.AbstractSimulation{<:NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.SurfaceHopping}, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.select_new_state","text":"This function should return the desired state determined by the probability. Should return the original state if no hop is desired.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.unpack_states-Tuple{NQCDynamics.AbstractSimulation{<:FSSH}}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.SurfaceHoppingMethods.unpack_states","text":"unpack_states(sim)\n\nGet the two states that we are hopping between.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#EhrenfestMethods","page":"DynamicsMethods","title":"EhrenfestMethods","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsmethods/","page":"DynamicsMethods","title":"DynamicsMethods","text":"Modules=[NQCDynamics.DynamicsMethods.EhrenfestMethods]","category":"page"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.EhrenfestMethods.AbstractEhrenfest","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.EhrenfestMethods.AbstractEhrenfest","text":"Abstract type for Ehrenfest method.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.EhrenfestMethods.Ehrenfest","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.EhrenfestMethods.Ehrenfest","text":"Ehrenfest{T} <: AbstractEhrenfest\n\nEhrenfest molecular dynamics. Classical molecular dynamics where the force is derived by averaging contributions from multiple electronic states.\n\nSimulation{Ehrenfest}(Atoms(:H), DoubleWell())\n\n# output\n\nSimulation{Ehrenfest{Float64}}:\n  Atoms{Float64}([:H], [1], [1837.4715941070515])\n  DoubleWell{Int64, Int64, Int64, Int64}\n  mass: Int64 1\n  ω: Int64 1\n  γ: Int64 1\n  Δ: Int64 1\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#IntegrationAlgorithms","page":"DynamicsMethods","title":"IntegrationAlgorithms","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsmethods/","page":"DynamicsMethods","title":"DynamicsMethods","text":"Modules=[NQCDynamics.DynamicsMethods.IntegrationAlgorithms]","category":"page"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.MInt","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.MInt","text":"MInt <: OrdinaryDiffEq.OrdinaryDiffEqAlgorithm\n\nSecond order symplectic momentum integral algorithm.\n\nReference\n\nJ. Chem. Phys. 148, 102326 (2018)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.RingPolymerMInt","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.RingPolymerMInt","text":"RingPolymerMInt <: OrdinaryDiffEq.OrdinaryDiffEqAlgorithm\n\nSecond order symplectic momentum integral algorithm applied to NRPMD.\n\nReference\n\nJ. Chem. Phys. 148, 102326 (2018)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_C_propagator-Tuple{AbstractVector, AbstractMatrix, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_C_propagator","text":"Get the C propagator for the mapping variables.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_D_propagator-Tuple{AbstractVector, AbstractMatrix, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_D_propagator","text":"Get the D propagator for the mapping variables.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_gamma-Tuple{AbstractMatrix, AbstractVector, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_gamma","text":"Get the Γ variable used to calculate the nuclear propagators.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, Any}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force","text":"Get the force due to the mapping variables.\n\nEquivalent to this but doesn't allocate:      return 0.5 * (q'Eq + p'Ep) - q'Fp\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_mapping_nuclear_force","text":"Get the force due to the mapping variables.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_xi-Tuple{AbstractMatrix, AbstractVector, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.get_xi","text":"Get the Ξ variable used to calculate the nuclear propagators.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_C_propagator!-Tuple{Any, Any, LinearAlgebra.Eigen, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_C_propagator!","text":"Get the C propagator for the mapping variables.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_D_propagator!-Tuple{Any, Any, LinearAlgebra.Eigen, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_D_propagator!","text":"Get the D propagator for the mapping variables.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_gamma!-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_gamma!","text":"Get the Γ variable used to calculate the nuclear propagators.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsmethods/#NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_xi!-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector, Real}","page":"DynamicsMethods","title":"NQCDynamics.DynamicsMethods.IntegrationAlgorithms.set_xi!","text":"Get the Ξ variable used to calculate the nuclear propagators.\n\n\n\n\n\n","category":"method"},{"location":"dynamicssimulations/dynamicsmethods/langevin/#langevin-dynamics","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Langevin dynamics can be used to sample the canonical ensemble for a classical system. Langevin dynamics are based on classical equations of motion that are modified by an additional drag force and a random force. The Langevin equation of motion can be written as","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"mathbfMddotmathbfR = - nabla_R V(mathbfR) + mathbfF(t) - gamma dotmathbfR","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"where mathbfM are the masses, ddotmathbfR the time-derivative of the positions,  i.e., the velocities, nabla_R V(mathbfR) the gradient of the potential and mathbfF(t) the random force that is related to the friction coefficient gamma by the second fluctuation-dissipation theorem.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Equally the above equation can be written in the form of Ito stochastic differential equations Benedict Leimkuhler, Charles Matthews (2012)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"beginaligned\ndmathbfR = mathbfM^-1 mathbfP dt\ndmathbfP = -nabla V(mathbfR) - gamma mathbfP dt\n+ sigma mathbfM^12 dmathbfW\nendaligned","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"where sigma = sqrt2gammabeta and mathbfW is a vector of N independent Wiener processes. As usual, mathbfP is the vector of particle momenta and mathbfM their diagonal mass matrix.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"note: Stochastic differential equations\nThere are two mathematical frameworks for handling stochastic differential equations, developed by Ruslan Stratonovich and Kiyosi Ito. To learn about the difference between the two in a physical context refer to H. Risken, H. Haken (1989).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"As a stochastic differential equation, these two can be integrated immediately using StochasticDiffEq provided by DifferentialEquations, which offers a variety of stochastic solvers. It is possible to exploit the dynamical structure of the differential equations by splitting the integration steps into parts that can be solved exactly. In this context,  it has been shown that the BAOAB method from Benedict Leimkuhler, Charles Matthews (2012) achieves good accuracy compared to other similar algorithms and this algorithm is used here as the default.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/#Example","page":"Classical Langevin dynamics","title":"Example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Using Langevin dynamics we can sample the canonical ensemble for a simple harmonic oscillator and investigate the energy expectation values.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Firstly we set up our system parameters. Here, we have two atoms in a harmonic potential at a temperature of 1e-3. We have arbitrarily chosen the dissipation constant gamma = 1, this can be tuned for optimal sampling in more complex systems. ","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"using NQCDynamics\nusing Unitful\n\natoms = Atoms([:H, :C])\ntemperature = 1e-3\nsim = Simulation{Langevin}(atoms, Harmonic(m=atoms.masses[1]); γ=1, temperature)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"note: Atomic units\nAs usual, all quantities are in atomic units by default.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Here we can generate a simple starting configuration with zeros for every degree of freedom.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"u = DynamicsVariables(sim, zeros(size(sim)), zeros(size(sim)))","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Running the dynamics proceeds by providing all the parameters along with any extra keywords. This time we have requested both the positions and velocities to be outputted and have selected a timestep dt. Since the default algorithm is a fixed timestep algorithm an error will be thrown if a timestep is not provided.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"traj = run_trajectory(u, (0.0, 2000.0), sim; output=(:position, :velocity), dt=0.1)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Here, we plot the positions of our two atoms throughout the simulation.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"using Plots\nplot(traj, :position, label=[\"Hydrogen\" \"Carbon\"], legend=true)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"We next plot the velocities. Notice how the carbon atom with its heavier mass has a smaller magnitude throughout.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"plot(traj, :velocity, label=[\"Hydrogen\" \"Carbon\"], legend=true)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Using the configurations from the Langevin simulation we can obtain expectation values along the trajectories. This can be done manually, but we provide the Estimators module to make this as simple as possible.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"!!! note Estimators","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"[Here](@ref `Estimators`) you can find the available quantities that [`Estimators`](@ref) provides.\nTo add new quantities, you must implement a new function inside `src/Estimators.jl`.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Let's find the expectation for the potential energy during our simulation. This is the potential energy of the final configuration in the simulation:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Estimators.potential_energy(sim, traj.position[end])","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"We could evaluate this for every configuration and average it manually. Fortunately however, we have the @estimate macro that will do this for us:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Estimators.@estimate potential_energy(sim, traj.position)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"tip: Tip\nWe can verify this result by comparing to the equipartition theorem which states that each quadratic degree of freedom should contribute frac12kT to the total energy. As this is a harmonic system, this gives us the exact classical potential energy expectation as equal to the temperature, since we have two degrees of freedom and we are in atomic units.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Similarly, we can evaluate the kinetic energy expectation with:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Estimators.@estimate kinetic_energy(sim, traj.velocity)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/langevin/","page":"Classical Langevin dynamics","title":"Classical Langevin dynamics","text":"Again, this takes a similar value since the total energy is evenly split between the kinetic and potential for a classical harmonic system.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/#mdef-dynamics","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/mdef/#Introduction","page":"Molecular dynamics with electronic friction (MDEF)","title":"Introduction","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"A set of fundamental and technologically relevant chemical processes (surface scattering, dissociative chemisorption, surface diffusion, recombinative desorption, etc.) are often catalyzed at the metal surface of several late transition metals (Au, Ag, Cu, Pt, Pd, Rh, etc). These metallic surfaces, unlike other surfaces, are characterized by a dense manifold of electronic states at the Fermi level, which produce continuous conduction and valence bands without a band gap. A theoretical description of the chemical processes at these metal surfaces is often challenging due to the Born-Oppenheimer (BO) approximation no longer being valid. With the breakdown of the Born-Oppenheimer approximation,  nonadiabatic effects have to be considered to describe, e.g., the energy exchange that can take place between adsorbate and substrate degrees of freedom (DOF).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"A fully quantum dynamical approach of this complex scenario is currently unfeasible and the gas-surface reaction dynamics are often described using quasi-classical methods where nuclear motion is described classically. Molecular dynamics with electronic friction (MDEF) is one of main methods used to deal with the nonadiabaticity in gas-surface chemical reactions. MDEF has been widely employed to decribe and simulate the nuclear dynamics in several molecular systems. It is a theoretical model based on a ground-state Langevin equation of motion which introduces nonadiabatic effects by using frictional and stochastic forces. This approach was originally introduced by Head-Gordon and Tully and the nonadiabatic effects can be included through different electronic friction models (see section below, LDFA and TDPT). The nuclear coordinates of the adsorbate atoms evolve as follows:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"mathbfMddotmathbfR = - nabla_R V(mathbfR) + mathbfF(t) - Gamma(mathbfR) dotmathbfR","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"The first term on the right hand side of the equation corresponds to a conservative force associated with the potential energy surface (PES) as in the adiabatic case. The third term is the friction force and it comes from multiplication between the electronic friction object (Gamma(mathbfR)) and the velocity. Finally, the second term is a temperature and friction-dependent stochastic force which ensures detailed balance.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"This figure shows an atom moving near a metal surface M_A. When the atom moves into the region of electron density rho_0^M_A it experiences the forces described above. (Image: ldfa motion)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/#Simple-example","page":"Molecular dynamics with electronic friction (MDEF)","title":"Simple example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"We can explore the MDEF concept first by introducing a model system with non-physical parameters. This will demonstrate the general format and expected results from an MDEF simulation which can explore further in later sections using realistic systems.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"Here, we model a single hydrogen atom in a harmonic potential, where the electronic temperature is 300 K. The CompositeFrictionModel allows us to combine any AdiabaticModel with an ElectronicFrictionProvider  that will add electronic friction to an otherwise adiabatic system. RandomFriction is used for demonstration purposes only and provides a matrix of random numbers to use in place of the friction.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"using NQCDynamics\nusing Unitful\n\natoms = Atoms([:H])\nmodel = CompositeFrictionModel(Harmonic(dofs=3), RandomFriction(3))\nsim = Simulation{MDEF}(atoms, model; temperature=300u\"K\")","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"For simplicity, we initialise the system with zero velocity and position for each degree of freedom:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"z = DynamicsVariables(sim, zeros(size(sim)), zeros(size(sim)))","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"With these parameters, we can run a single trajectory and visualise the total energy as a function of time.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"using Plots\n\nsolution = run_trajectory(z, (0.0, 100u\"fs\"), sim, dt=0.1u\"fs\", output=(:hamiltonian))\nplot(solution, :hamiltonian)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"note: Note\n:hamiltonian in the output tuple refers to the classical Hamiltonian that generates the classical equations of motion. Since we are performing MDEF we see that the total energy fluctuates.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"Now let's see what happens if we make the electronic temperature a function of time. For any simulation, temperature can be provided as a time-dependent function which allows variable temperature simulations. In the context of MDEF, this temperature can be used to represent the use of lasers to provide extra energy to the electrons in the metal.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"temperature_function(t) = exp(-(t - 50u\"fs\")^2 / 20u\"fs^2\") * 300u\"K\"\nnothing # hide","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"warning: Warning\nThe time argument enters this function as a Unitful.jl quantity, and it is important to make sure the unit of the return value is temperature.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"Now we can re-simulate, replacing the fixed temperature with the function we have defined.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"sim = Simulation{MDEF}(atoms, model; temperature=temperature_function)\nsolution = run_trajectory(z, (0.0, 100u\"fs\"), sim, dt=0.1u\"fs\",\n    output=(:hamiltonian, :position, :velocity))\nplot(solution, :hamiltonian)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"This time we see a peak in the energy in the middle of the simulation which coincides with the peak in temperature at 50 fs. Having viewed this simple example, we can now explore the different ways the friction coefficient can be obtained from ab initio simulations. ","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/#Local-density-friction-approximation-(LDFA)","page":"Molecular dynamics with electronic friction (MDEF)","title":"Local density friction approximation (LDFA)","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"Local density friction approximation (LDFA) is a theoretical model which describes the electronic friction Gamma(mathbfR) term in the above equation based on the local electron density of the metal substrate. This approximation assumes a scalar friction coefficient (Gamma(R_i)) for each adsorbate atom. The underlying assumption to this approximation is that any atom only sees an anisotropic (scalar) density that only depends on the local surroundings. In the LDFA theoretical framework the above equation of motion is used, except the friction matrix is diagonal, each element coming from the local density of each atom.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"In our current LDFA implementation, a set of pre-calculated electronic friction coefficients (eta_ei) computed at different Wigner-Seitz radius (r_s) are used to fit and get an analytical expression to connect any r_s values with an single electronic friction coefficient by means of    cubic Spline functions. The Wigner-Sietz radius is connected to the metal substrate electron density by the following equation, ","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"   r_s(rho) = (frac34pi rho (mathbfr_i))^13","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"In this way, the electron density associated with the current substrate atom position is used to compute the respective friction coefficient through fitting function for each point of the trajectory. Visit the CubeLDFAModel.jl to learn more about how this is evaluated.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/#Time-dependent-Perturbation-theory-(TDPT)","page":"Molecular dynamics with electronic friction (MDEF)","title":"Time-dependent Perturbation theory (TDPT)","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"A more general formulation of the electronic friction object was also developed under the umbrella of electronic friction tensor(EFT) or orbital-dependent electronic friction (ODF) approaches. Both formulations are essentially equivalent and they incorporate the isotropy nature of the electronic friction object by a multidimentional tensor (Lambda_ij) instead of a single coefficient as usually computed at LDFA level.  The electronic friction elements can be computed by first-principle calculations in the context of first-order time-dependent perturbation theory (TDPT) at the density functional theory (DFT) level. Each electronic friction tensor (EFT) elements corresponds to relaxation rate due to electron-nuclear coupling along the Cartesian coordinate i due to motion in the j direction. The electronic friction tensor elements can be computed by using the Fermi's golden rule. Lambda_ij is an object with (3Ntimes3N)-dimension where N is often the total number of adsorbate atoms considered explicitly on the study system. View the friction models page to learn about how this can be used.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/mdef/","page":"Molecular dynamics with electronic friction (MDEF)","title":"Molecular dynamics with electronic friction (MDEF)","text":"tip: TDPT friction and LDFA in action?\nIf you would like to see an example using both LDFA and TDPT during full dimensional dynamics, refer to the reactive scattering example.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/#ehrenfest-dynamics","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"The Ehrenfest method is a mixed quantum-classical dynamics method in which the total wavefunction is factorized into slow (nuclear) variables, which are treated classically, and fast ones (electrons) which remain quantum-mechanical. In the Ehrenfest method, nuclei move according to classical mechanics on a potential energy surface given by the expectation value of the electronic Hamiltonian. ","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"The time depedence of the electronic wavefunction is expanded into an adiabatic basis and follows the time-dependent Schr\\\"odinger equation.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"ihbar dotc_i(t) = V_i(mathbfR) c_i (t)\n- ihbar sum_j dotmathbfR cdot mathbfd_ij(mathbfR)c_j(t)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/#Example","page":"Ehrenfest molecular dynamics","title":"Example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"Below the example of the Ehrenfest implementation is presented, using model from Nandini Ananth, Charulatha Venkataraman, William H. Miller (2007).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"At the start, we assign atoms and initialise the simulation using the mass and model from NQCModels.jl.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"using NQCDynamics\n\natoms = Atoms(1980)\nsim = Simulation{Ehrenfest}(atoms, AnanthModelOne())","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"Next, the initial distribution is created:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"using Distributions\ne = 0.03\nk = sqrt(e*2*atoms.masses[1])\nr = Normal(-5, 1/sqrt(0.25))\nv = k / atoms.masses[1]\ndistribution = DynamicalDistribution(v, r, size(sim))* SingleState(1, Adiabatic())","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"To run an ensemble simulation we additionally choose number of trajectories n_traj and timespan tspan and we pass all the established settings to the run_ensemble function. In this example we output velocities by specifying output=:velocity and store the final values in the final_velocities array. Following that, we calculate final momenta.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"n_traj = 5000\ntspan = (0.0, 3000.0)\nsolution = run_ensemble(sim, tspan, distribution; \n    trajectories=n_traj, output=:velocity)\nfinal_velocities = [r.velocity[end] for r in solution]\nmomenta = reduce(vcat, final_velocities*atoms.masses[1])","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"Resulting momenta can be plotted by using StatsPlots package.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/ehrenfest/","page":"Ehrenfest molecular dynamics","title":"Ehrenfest molecular dynamics","text":"using StatsPlots\nplot(density(momenta))\nxlims!(-20,20)","category":"page"},{"location":"ensemble_simulations/#ensembles","page":"Ensemble simulations","title":"Ensemble simulations","text":"","category":"section"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"Typically we'll be interested in computing observables based upon the statistics obtained from many trajectories. Technically it is possible to manually run many trajectories using the single trajectory procedure introduced in the Getting started section. However, by using the methods introduced on this page it is possible to run many trajectories at once, using parallelism and computing ensemble observables automatically.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"The key function for performing ensemble simulations is run_ensemble.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"run_ensemble","category":"page"},{"location":"ensemble_simulations/#NQCDynamics.Ensembles.run_ensemble","page":"Ensemble simulations","title":"NQCDynamics.Ensembles.run_ensemble","text":"run_ensemble(sim::AbstractSimulation, tspan, distribution;\n    selection::Union{Nothing,AbstractVector}=nothing,\n    output=(sol,i)->(sol,false),\n    reduction=:append\n    reduction::Symbol=:append,\n    ensemble_algorithm=SciMLBase.EnsembleThreads(),\n    algorithm=DynamicsMethods.select_algorithm(sim),\n    saveat=[],\n    trajectories=1,\n    kwargs...\n    )\n\nRun multiple trajectories for timespan tspan sampling from distribution. The DifferentialEquations ensemble interface is used which allows us to specify functions to modify the output and how it is reduced across trajectories.\n\nKeywords\n\nselection should be an AbstractVector containing the indices to sample from the distribution. By default, nothing leads to random sampling.\noutput can be a function that transforms the DiffEq solution to an output, or a tuple of output quantities as for run_trajectory.\nreduction defines how the data is reduced across trajectories. Options are :append, :mean or :sum.\nensemble_algorithm is the algorithm from DifferentialEquations which determines which form of parallelism is used.\nalgorithm is the algorithm used to integrate the equations of motion.\nsaveat mirrors the DiffEq keyword and labels the time points to save the output.\ntrajectories is the number of trajectories to perform.\n\nThis function wraps the EnsembleProblem from DifferentialEquations and passes the kwargs to the solve function.\n\n\n\n\n\n","category":"function"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"From the function signature displayed above it should be possible to identify the similarities to the run_trajectory function. The sim and tspan positional arguments are the same, but the initial DynamicsVariables have been replaced by a distribution. These distributions are defined such that they can be sampled to provide initial conditions for each trajectory. The Storing and sampling distributions page details the format this distribution must take.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"The output may take two distinct forms: the tuple structure familiar from run_trajectory output=(:position, :velocity, :hamiltonian) or a function as described in the DifferentialEquations.jl documentation. These options allow access to the common output quantities defined in the DynamicsOutputs module along with specific customised output. Already implemented in the code are a small library of existing functions of this type, but it is possible to use any Julia function in its place. The existing ensemble outputs can be found here.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"Internally, the DifferentialEquations.jl ensemble infrastructure is used to handle per trajectory parallelism. The ensemble_algorithm keyword takes one of the EnsembleAlgorithms. To use these, you must first add using DiffEqBase to your script.","category":"page"},{"location":"ensemble_simulations/#Example","page":"Ensemble simulations","title":"Example","text":"","category":"section"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"To demonstrate usage of run_ensemble, let's investigate different ways to calculate the time-dependent population with FSSH.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"First, we set up our system using one of Tully's simple models (John C. Tully (1990)).","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"using NQCDynamics\n\natoms = Atoms(2000)\nmodel = TullyModelOne()\nsim = Simulation{FSSH}(atoms, model)\nnothing # hide","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"As mentioned above, before running the ensemble, we must prepare a distribution to generate initial conditions for each trajectory. This procedure is detailed in the Storing and sampling distributions section.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"using Distributions: Normal # Import the Normal distribution\n\nk = 10 # Initial momentum = 10\nv = k / atoms.masses[1] # Convert momentum to velocity\nr = Normal(-8) # Create Normal distribution centred at -8 for sampling initial position\nnuclear_distribution = DynamicalDistribution(v, r, (1,1)) # Combine position and velocity\nelectronic_distribution = SingleState(2) # Create nonequilibrium electronic distribution\nproduct_distribution = nuclear_distribution * electronic_distribution\nnothing # hide","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"In this case, we have used a deterministic momentum of 10 a.u. and a gaussian position distribution with width 1 centered at -8 a.u.. The electronic variables will be sampled such that the initial population is confined to the second state by SingleState(2).","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"The final step before running the dynamics is to decide how to output the results. The simplest option is to use the built-in tuple format familiar from run_trajectory.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"ensemble = run_ensemble(sim, (0.0, 3000.0), product_distribution;\n    trajectories=20, output=:population)\nnothing # hide","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"This is equivalent to performing single trajectories in a loop and manually re-sampling the initial conditions each time. However, here we have been able to do this more concisely, using internal mechanisms for sampling from the product_distribution.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"The output of this function is a vector containing the output from each trajectory. Each entry is equivalent to the output from a call to run_trajectory and  can be plotted by iterating through ensemble.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"using Plots\n\np = plot(legend=false)\nfor traj in ensemble\n    plot!(traj.t, [population[2] - population[1] for population in traj.population])\nend\np","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"This plot shows the population difference between the two states for each trajectory. To approximate the exact quantum dynamics for this model, the average over all trajectories should be computed. Instead of manually averaging the result, we can use reduction=:mean or reduction=:sum which will reduce the data accordingly before outputting the result:","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"ensemble = run_ensemble(sim, (0.0, 3000.0), product_distribution;\n    trajectories=20, output=:population, reduction=:mean, saveat=0.0:10.0:3000.0)\nplot(ensemble, :population)","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"note: Note\nHere we have also specified the saveat keyword to ensure the output is saved at the same points for every trajectory, otherwise the averaging will not work. This is necessary because we are using an integrator with adaptive timestepping that will save at different points for each trajectory.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"This workflow can be applied for any of the quantities defined in the DynamicsOutputs submodule. If we want a more complex output, such as a scattering probability or a time-correlation function, we can provide a function to the output argument as described in the DifferentialEquations.jl documentation. The advantage of this approach is that memory can be saved by reducing the data as the trajectories accumulate, it also allows greater flexibility when modifying the output.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"Inside the Ensembles submodule we define a few premade functions of this sort, but here we can demonstrate how to reformulate the previous simulation using the alternative format.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"function output_function(sol, i)\n    output = zeros(2,div(3000, 50) + 1)\n    for (i,u) in enumerate(sol.u)\n        output[:,i] = Estimators.diabatic_population(sim, u)\n    end\n    return (output, false)\nend\n\nensemble = run_ensemble(sim, (0.0, 3000.0), product_distribution;\n    trajectories=20, output=output_function, reduction=:mean, u_init=zeros(2,div(3000, 50)+1), saveat=50.0)","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"This function provides us the same output as above, but here we have defined it in a way compatible with the DifferentialEquations.jl format. To use this format, we have additionally specified u_init and saveat. These keywords come from DifferentialEquations.jl, and specify the shape of the output and at which timesteps we want to evaluate output_function and save the values. In this example we have saved the output at intervals of 50 from 0 to 3000, our tspan. The advantage of this format is that greater flexibility is available since output_function can be modified to output any quantity.","category":"page"},{"location":"ensemble_simulations/","page":"Ensemble simulations","title":"Ensemble simulations","text":"Throughout the documentation, ensemble simulations like this one are used to demonstrate many of the dynamics methods. Now that you have understood the contents of this page, all of the ensemble simulations will appear familiar.","category":"page"},{"location":"api/NQCDynamics/timecorrelationfunctions/#TimeCorrelationFunctions","page":"TimeCorrelationFunctions","title":"TimeCorrelationFunctions","text":"","category":"section"},{"location":"api/NQCDynamics/timecorrelationfunctions/","page":"TimeCorrelationFunctions","title":"TimeCorrelationFunctions","text":"Modules=[NQCDynamics.TimeCorrelationFunctions]","category":"page"},{"location":"api/NQCDynamics/timecorrelationfunctions/#NQCDynamics.TimeCorrelationFunctions","page":"TimeCorrelationFunctions","title":"NQCDynamics.TimeCorrelationFunctions","text":"TimeCorrelationFunctions\n\nThis module defines extra types that can be used as Ensemble outputs when computing time-correlation functions. It hopes to provide a minimal interface that reduces code repetition when implementing different correlation functions.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/timecorrelationfunctions/#NQCDynamics.TimeCorrelationFunctions.PopulationCorrelationFunction","page":"TimeCorrelationFunctions","title":"NQCDynamics.TimeCorrelationFunctions.PopulationCorrelationFunction","text":"PopulationCorrelationFunction{T,S<:AbstractSimulation} <: TimeCorrelationFunction\n\nOutput type for computing the population correlation function. The statetype determines the population type (diabatic or adiabatic). sim must also be provided to access the parameters to compute the population.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/timecorrelationfunctions/#NQCDynamics.TimeCorrelationFunctions.TimeCorrelationFunction","page":"TimeCorrelationFunctions","title":"NQCDynamics.TimeCorrelationFunctions.TimeCorrelationFunction","text":"TimeCorrelationFunction\n\nAbstract type for defining time correlation functions\n\n\n\n\n\n","category":"type"},{"location":"saving_loading/#saving-and-loading","page":"Saving and loading","title":"Saving and loading","text":"","category":"section"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"If you would like to split your workflow into multiple scripts (e.g. separately generating initial conditions and running dynamics) it is necessary to be able to store intermediate data in files.","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"When this data is atomic configurations or trajectories, it can be useful to use standard file formats such as those mentioned in the Atoms section previously. However, often it is more convenient to directly save and load Julia objects between sessions. For this purpose, we recommend using FileIO.jl with JLD2.jl.","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"note: Note\nJLD2 can be used independently of FileIO. However, FileIO provides a unified interface for many file types and allows you to save data to lots of formats with consistent syntax.","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"As a simple example, suppose that we want the same system parameters across multiple scripts:","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"using NQCDynamics\n\natoms = Atoms([:H, :H, :C, :C])\ncell = PeriodicCell([10.0 0 0; 0 10.0 0; 0 0 10.0])\nmodel = Harmonic()\nnothing # hide","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"Instead of redefining these in every script, we can save them to a file, then load them back in whenever we need them using FileIO.","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"This creates a file \"parameters.jld2\" containing all of our system parameters:","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"using FileIO\nsave(\"parameters.jld2\", Dict(\"atoms\"=>atoms, \"cell\"=>cell, \"model\"=>model))","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"In a separate Julia session we can re-load these parameters. As detailed in the JLD2 documentation we can select the data to load by specifying extra arguments to load.","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"using NQCDynamics, FileIO\n\nparameters = load(\"parameters.jld2\")\natoms = load(\"parameters.jld2\", \"atoms\")\ncell = load(\"parameters.jld2\", \"cell\")\nmodel = load(\"parameters.jld2\", \"model\")","category":"page"},{"location":"saving_loading/","page":"Saving and loading","title":"Saving and loading","text":"JLD2 is compatible with any Julia type so it widely usable for most of the types you encounter is NQCDynamics.jl and across all Julia packages.","category":"page"},{"location":"NQCModels/neuralnetworkmodels/#Neural-network-models","page":"Neural network models","title":"Neural network models","text":"","category":"section"},{"location":"NQCModels/neuralnetworkmodels/","page":"Neural network models","title":"Neural network models","text":"Using the ASE interface we can directly use models trained using SchNetPack.","category":"page"},{"location":"NQCModels/neuralnetworkmodels/","page":"Neural network models","title":"Neural network models","text":"danger: Danger\nThe examples on this page do not run during the documentation build due to schnetpack causing segfaults when installed in the build environment. The causes of this is not currently clear but we have temporarily disabled these examples in the build.However, the examples should still be correct and you are welcome to try them with your own schnetpack trained models.","category":"page"},{"location":"NQCModels/neuralnetworkmodels/","page":"Neural network models","title":"Neural network models","text":"To use a SchNet model, please load any pre-trained model into a given path you can access. Here, our SchNet model is named \"best_model\" as is common in SchNet and provide the relative path.","category":"page"},{"location":"NQCModels/neuralnetworkmodels/","page":"Neural network models","title":"Neural network models","text":"First we load the model into an ase calculator and attach it to our diatomic hydrogen molecule.","category":"page"},{"location":"NQCModels/neuralnetworkmodels/","page":"Neural network models","title":"Neural network models","text":"using PyCall\n\nase = pyimport(\"ase\")\nspkutils = pyimport(\"schnetpack.utils\")\nspkinterfaces = pyimport(\"schnetpack.interfaces\")\n\nspk_model = spkutils.load_model(\"../assets/schnetpack/best_model\"; map_location=\"cpu\")\n\nh2 = ase.Atoms(\"H2\", [(0, 0, 0), (0, 0, 0.74)])\n\ncalc = spkinterfaces.SpkCalculator(spk_model, energy=\"energy\", forces=\"forces\")\nh2.set_calculator(calc)","category":"page"},{"location":"NQCModels/neuralnetworkmodels/","page":"Neural network models","title":"Neural network models","text":"We can obtain the energies and forces from ase directly in the usual way, converting them to atomic units using UnifulAtomic.","category":"page"},{"location":"NQCModels/neuralnetworkmodels/","page":"Neural network models","title":"Neural network models","text":"using Unitful, UnitfulAtomic;\naustrip(h2.get_total_energy() * u\"eV\")\naustrip.(h2.get_forces() .* u\"eV/Å\")","category":"page"},{"location":"NQCModels/neuralnetworkmodels/","page":"Neural network models","title":"Neural network models","text":"warning: Warning\nNote that this is an arbitrary model not trained on H2, hence the calculation of the potential energy and forces most likely do not make sense.","category":"page"},{"location":"NQCModels/neuralnetworkmodels/","page":"Neural network models","title":"Neural network models","text":"Then, we can convert the ASE output into the format used in NQCModels, which makes it possible to use the SchNet model e.g. for molecular dynamics calculations within NQCDynamics.jl:","category":"page"},{"location":"NQCModels/neuralnetworkmodels/","page":"Neural network models","title":"Neural network models","text":"using NQCModels;\nmodel = AdiabaticASEModel(h2);\n\nr = [0 0; 0 0; 0 ustrip(auconvert(0.74u\"Å\"))]\n\npotential(model, r)\nderivative(model, r)","category":"page"},{"location":"api/NQCModels/adiabaticmodels/#AdiabaticModels","page":"AdiabaticModels","title":"AdiabaticModels","text":"","category":"section"},{"location":"api/NQCModels/adiabaticmodels/","page":"AdiabaticModels","title":"AdiabaticModels","text":"Modules=[NQCModels.AdiabaticModels]","category":"page"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels","text":"AdiabaticModels\n\nAll models defined within this module have only a single electronic state and return potentials as scalars and derivatives as simple arrays.\n\nThe central abstract type is the AdiabaticModel, which all models should subtype.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.AdiabaticASEModel","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.AdiabaticASEModel","text":"AdiabaticASEModel{A} <: AdiabaticModel\n\nWrapper for an ase.Atoms object that has a calculator attached. This will synchronise the positions with the ase object and handle the unit conversions.\n\nImplements both potential and derivative!.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.AdiabaticModel","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.AdiabaticModel","text":"AdiabaticModel <: Model\n\nAdiabaticModels represent the potentials from classical molecular dynamics where the potential is a function of the position.\n\nImplementation\n\nAdiabaticModels should implement:\n\npotential(model, R)\nderivative!(model, D, R) (this is the derivative of the potential energy with respect to the positions)\nndofs(model) (these are the degrees of freedom)\n\nExample\n\nThis example creates a 2 dimensional adiabatic model MyModel. We implement the 3 compulsory functions then evaluate the potential. Here, the argument R is an AbstractMatrix since this is a 2D model that can accept multiple atoms.\n\nstruct MyModel{P} <: NQCModels.AdiabaticModels.AdiabaticModel\n    param::P\nend\n\nNQCModels.ndofs(::MyModel) = 2\n\nNQCModels.potential(model::MyModel, R::AbstractMatrix) = model.param*sum(R.^2)\nNQCModels.derivative!(model::MyModel, D, R::AbstractMatrix) = D .= model.param*2R\n\nmodel = MyModel(10)\n\nNQCModels.potential(model, [1 2; 3 4])\n\n# output\n\n300\n\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.DarlingHollowayElbow","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.DarlingHollowayElbow","text":"DarlingHollowayElbow()\n\nAdiabatic elbow potential from Darling and Holloway: Faraday Discuss., 1993, 96, 43-54\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.DiatomicHarmonic","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.DiatomicHarmonic","text":"DiatomicHarmonic(r₀=1.0)\n\nHarmonic interaction between two particles.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.Free","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.Free","text":"Free()\n\nZero external potential everywhere. Useful for modelling free particles.\n\njulia> model, R = Free(3), rand(3, 10);\n\njulia> potential(model, R)\n0.0\n\njulia> derivative(model, R)\n3×10 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.Harmonic","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.Harmonic","text":"Harmonic(m=1.0, ω=1.0, r₀=0.0)\n\nAdiabatic harmonic potential. V(x) = mω^2(x-r₀)^2  2\n\njulia> using Symbolics;\n\njulia> @variables x, m, ω, r₀;\n\njulia> model = Harmonic(m=m, ω=ω, r₀=r₀);\n\njulia> potential(model, hcat(x))\n0.5m*(ω^2)*((x - r₀)^2)\n\njulia> derivative(model, hcat(x))\n1×1 Matrix{Num}:\n m*(x - r₀)*(ω^2)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.Morse","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.Morse","text":"Parameters.@with_kw struct Morse{T} <: AdiabaticModel\n\nReferences\n\nJ. Chem. Phys. 88, 4535 (1988)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.eigenenergy-Tuple{Morse, Any}","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.eigenenergy","text":"Eq. 43\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.getλ-Tuple{Morse}","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.getλ","text":"Eq. 36\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/adiabaticmodels/#NQCModels.AdiabaticModels.getω₀-Tuple{Morse}","page":"AdiabaticModels","title":"NQCModels.AdiabaticModels.getω₀","text":"Eq. 44\n\n\n\n\n\n","category":"method"},{"location":"atoms/#atoms","page":"Atoms","title":"Handling Atoms","text":"","category":"section"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"This package makes the choice to separate the atomic parameters from their positions and velocities for ease of use with the differential equations solvers. This contrasts somewhat with most other software packages where these would be usually by joined together into a single object.","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"The atomic parameters here are contained within the Atoms type introduced earlier in the Getting started section. As mentioned previously, there exist some basic constructors which use either elemental symbols or numbers to initialise the parameters:","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"using NQCDynamics\nAtoms([:H, :H, :H])\nAtoms([1, 2, 3])","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"If there are many atoms, you can use Julia's array manipulation utilities to create large vectors with many atoms types. For example, if adding an adsorbate to a metal surface, it could be initialised as:","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"au = fill(:Au, 40)\nno = [:N, :O]\nauno = [au; no]\nAtoms(auno)","category":"page"},{"location":"atoms/#reading-and-writing","page":"Atoms","title":"Reading and writing atomic structures","text":"","category":"section"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"When using a complex system however, it is likely more effective to read structures directly from a file. We provide two ways to do this, either using the  ExtXYZ.jl package which works for xyz files. Or instead there is a conversion to and from the ase.Atoms type which can be used when PyCall.jl is loaded.","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"First we can use ase to build a system and write it to an .xyz file.","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"using PyCall\n\nbuild = pyimport(\"ase.build\")\n\nslab = build.fcc100(\"Al\", size=(2, 2, 3))\nbuild.add_adsorbate(slab, \"Au\", 1.7, \"hollow\")\nslab.center(axis=2, vacuum=4.0)\n\nslab.write(\"slab.xyz\")","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"Now we can read it in with the read_extxyz function.","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"atoms, positions, cell = read_extxyz(\"slab.xyz\")\natoms\npositions\ncell","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"Similarly, we can write the file with write_extxyz:","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"write_extxyz(\"out.xyz\", atoms, positions, cell)","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"Both of these functions also work with trajectories such that the positions will be a vector of configurations, whilst the atoms and cell will remain unchanged.","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"If not using .xyz files, we can directly use the IO capability of ase to read or the write the files. This can be done by using the conversions between our data types and the ase.Atoms object.","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"atoms = Atoms([:H, :H, :C])\nase_atoms = NQCBase.convert_to_ase_atoms(atoms, rand(3, 3))\nNQCBase.convert_from_ase_atoms(ase_atoms)","category":"page"},{"location":"atoms/","page":"Atoms","title":"Atoms","text":"These conversions work both ways such that you can read any file format using ase then convert the ase.Atoms object to our types afterwards. Then at the end when you are finished, you can convert them back and write your output with ase.","category":"page"},{"location":"api/NQCBase/nqcbase/#NQCBase","page":"NQCBase","title":"NQCBase","text":"","category":"section"},{"location":"api/NQCBase/nqcbase/","page":"NQCBase","title":"NQCBase","text":"Modules=[NQCBase]","category":"page"},{"location":"api/NQCBase/nqcbase/#NQCBase.Atoms","page":"NQCBase","title":"NQCBase.Atoms","text":"Atoms{T<:AbstractFloat}\n\nBasic atomic parameters: element symbols, numbers and masses\n\nMasses are converted to atomic units. Constructed using either element symbols or masses.\n\njulia> Atoms(:H)\nAtoms{Float64}([:H], [1], [1837.4715941070515])\n\njulia> Atoms([:H, :H, :H, :C])\nAtoms{Float64}([:H, :H, :H, :C], [1, 1, 1, 6], [1837.4715941070515, 1837.4715941070515, 1837.4715941070515, 21894.713607956142])\n\njulia> Atoms([100, 200])\nAtoms{Float64}([:X, :X], [0, 0], [100.0, 200.0])\n\n\n\n\n\n","category":"type"},{"location":"api/NQCBase/nqcbase/#NQCBase.PeriodicCell","page":"NQCBase","title":"NQCBase.PeriodicCell","text":"PeriodicCell{T<:AbstractFloat} <: AbstractCell\n\nOptionally periodic cell\n\n\n\n\n\n","category":"type"},{"location":"api/NQCBase/nqcbase/#NQCBase.check_atoms_in_cell-Tuple{PeriodicCell, AbstractMatrix}","page":"NQCBase","title":"NQCBase.check_atoms_in_cell","text":"check_atoms_in_cell(cell::PeriodicCell, R::AbstractMatrix)::Bool\n\nTrue if all atoms are inside the cell, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCBase/nqcbase/#NQCBase.read_extxyz-Tuple{Any}","page":"NQCBase","title":"NQCBase.read_extxyz","text":"read_extxyz(file)\n\nUses ExtXYZ.jl to read a .extxyz file\n\n\n\n\n\n","category":"method"},{"location":"api/NQCBase/nqcbase/#NQCBase.write_extxyz-Tuple{Any, Any, Matrix, Any}","page":"NQCBase","title":"NQCBase.write_extxyz","text":"write_extxyz(file, atoms, R, cell)\n\nUses ExtXYZ.jl to write a .extxyz file\n\nR can be either a single configuration (Matrix) or many (Vector{<:Matrix}).\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#InitialConditions","page":"InitialConditions","title":"InitialConditions","text":"","category":"section"},{"location":"api/NQCDynamics/initialconditions/","page":"InitialConditions","title":"InitialConditions","text":"Modules=[NQCDynamics.InitialConditions]","category":"page"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions","page":"InitialConditions","title":"NQCDynamics.InitialConditions","text":"InitialConditions\n\nFunctions and types for generating initial conditions for simulations.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/initialconditions/#ThermalMonteCarlo","page":"InitialConditions","title":"ThermalMonteCarlo","text":"","category":"section"},{"location":"api/NQCDynamics/initialconditions/","page":"InitialConditions","title":"InitialConditions","text":"Modules=[NQCDynamics.InitialConditions.ThermalMonteCarlo]","category":"page"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.ThermalMonteCarlo.run_advancedhmc_sampling-Tuple{Simulation, Any, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.ThermalMonteCarlo.run_advancedhmc_sampling","text":"run_advancedhmc_sampling(sim::Simulation, r, n_samples;\n    target_acceptance=0.5, kwargs...)\n\nPerform Hamiltonian Monte Carlo sampling for the simulation sim using AdvancedHMC.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.ThermalMonteCarlo.run_advancedmh_sampling-Tuple{NQCDynamics.AbstractSimulation, Any, Real, Dict{Symbol, <:Real}}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.ThermalMonteCarlo.run_advancedmh_sampling","text":"run_advancedhmc_sampling(sim, r, steps, σ; move_ratio=0.0, internal_ratio=0.0)\n\nSample the configuration space for the simulation sim starting from r.\n\nTotal number of steps is given by steps and σ is the dictionary of step sizes for each species.\n\nmove_ratio defaults to 0.0 and denotes the fraction of system moved each step. If move_ratio = 0, every degree of freedom is moved at each step. If move_ratio = 1, then nothing will happen. Experiment with this parameter to achieve optimal sampling.\n\ninternal_ratio works as for move_ratio but for the internal modes of the ring polymer.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#QuantisedDiatomic","page":"InitialConditions","title":"QuantisedDiatomic","text":"","category":"section"},{"location":"api/NQCDynamics/initialconditions/","page":"InitialConditions","title":"InitialConditions","text":"Modules=[NQCDynamics.InitialConditions.QuantisedDiatomic]","category":"page"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic","text":"QuantisedDiatomic\n\nThis module exports two user facing functions:\n\ngenerate_configurations   Creates a set of velocities and positions for diatomic molecule with specified   vibrational ν and rotational J quantum numbers.\nquantise_diatomic   Obtains vibrational ν and rotational J quantum numbers for a diatomic molecule   with a given set of velocities and positions.\n\nThe central concept of this module is the EBK procedure which is nicely detailed here: Andrew J. Larkoski, David G. Ellis, Lorenzo J. Curtis (2006)\n\nInspired by VENUS96: William L Hase, Ronald J Duchovic, Xiche Hu, Andrew Komornicki, Kieran F Lim, Da-hong Lu, Gilles H Peslherbe, Kandadai N Swamy, SR Vande Linde, Antonio Varandas, others (1996)\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.apply_random_rotation!-Tuple{Any, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.apply_random_rotation!","text":"Randomly rotate each column of two 3*N matrix, same rotation for all columns.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.calculate_diatomic_energy-Tuple{NQCModels.AdiabaticModels.AdiabaticModel, Real, NQCDynamics.InitialConditions.QuantisedDiatomic.SurfaceParameters}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.calculate_diatomic_energy","text":"calculate_diatomic_energy(model::AdiabaticModel, bond_length::Real;\n    height=10, normal_vector=[0, 0, 1])\n\nReturns potential energy of diatomic with bond_length at height from surface.\n\nOrients molecule parallel to the surface at the specified height, the surface is assumed to intersect the origin. This requires that the model implicitly provides the surface, or works fine without one.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.calculate_force_constant-Tuple{Any, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.calculate_force_constant","text":"calculate_force_constant(sim::Simulation, surface::SurfaceParameters)\n\nEvaluate energy for different bond lengths and identify force constant. \n\nThis uses LsqFit.jl to fit a morse potential with optimised minimum.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.combine_slab_and_molecule-Tuple{Any, Any, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.combine_slab_and_molecule","text":"combine_slab_and_molecule(atom_indices, molecule, slab)\n\nRevert the transformation separate_slab_and_molecule\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.configure_diatomic-Tuple{Any, Any, Any, Any, NQCDynamics.InitialConditions.QuantisedDiatomic.SurfaceParameters, NQCDynamics.InitialConditions.QuantisedDiatomic.GenerationParameters}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.configure_diatomic","text":"Randomly orient molecule in space for a given bond length and radial momentum\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.find_total_energy-Tuple{NQCModels.AdiabaticModels.AdiabaticModel, Any, Any, NQCDynamics.InitialConditions.QuantisedDiatomic.SurfaceParameters}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.find_total_energy","text":"find_total_energy(sim, ν, J, surface)\n\nReturns the energy associated with the specified quantum numbers\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.generate_configurations-Tuple{Any, Any, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.generate_configurations","text":"generate_configurations(sim, ν, J; samples=1000, height=10, normal_vector=[0, 0, 1],\n    translational_energy=0, direction=[0, 0, -1], position=[0, 0, height])\n\nGenerate positions and momenta for given quantum numbers\n\ntranslational_energy, direction and position specify the kinetic energy in a specific direction with the molecule placed with centre of mass at position.\n\nKeyword arguments height and normal_vector become relevant if the potential requires specific placement of the molecule. These allow the molecule to be placed at a distance height in the direction normal_vector when performing potential evaluations.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.quantise_diatomic-Tuple{Simulation, Matrix, Matrix}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.quantise_diatomic","text":"quantise_diatomic(sim::Simulation, v::Matrix, r::Matrix;\n    height=10, normal_vector=[0, 0, 1])\n\nQuantise the vibrational and rotational degrees of freedom for the specified positions and velocities\n\nWhen evaluating the potential, the molecule is moved to height in direction normal_vector. If the potential is independent of centre of mass position, this has no effect. Otherwise, be sure to modify these parameters to give the intended behaviour.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.select_random_bond_lengths-Tuple{Any, Any, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.select_random_bond_lengths","text":"Pick a random bond length and corresponding radial momentum that matches the radial probability distribution.\n\nUses rejection sampling: https://en.wikipedia.org/wiki/Rejection_sampling\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.QuantisedDiatomic.separate_slab_and_molecule-Tuple{Any, Any}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.QuantisedDiatomic.separate_slab_and_molecule","text":"separate_slab_and_molecule(atom_indices, r)\n\nGet the coordinates of the molecule and slab separately.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#MetropolisHastings","page":"InitialConditions","title":"MetropolisHastings","text":"","category":"section"},{"location":"api/NQCDynamics/initialconditions/","page":"InitialConditions","title":"InitialConditions","text":"Modules=[NQCDynamics.InitialConditions.MetropolisHastings]","category":"page"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings","text":"MetropolisHastings\n\nSampling of the initial conditions using the Metropolis-Hastings Markov chain Monte Carlo method.\n\nIncluded within is the ability to sample the canonical distribution for adiabatic classical and ring polymer systems.\n\nUsage involves creating an instance of an AbstractSystem{MonteCarlo} and calling run_monte_carlo_sampling.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.MonteCarlo","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.MonteCarlo","text":"Parameters for Monte carlo simulations.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.MonteCarloOutput","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.MonteCarloOutput","text":"Container for storing simulation quantities\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.acceptance_probability-Tuple{Simulation, NQCDynamics.InitialConditions.MetropolisHastings.MonteCarlo}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.acceptance_probability","text":"acceptance_probability(system::AbstractSystem{MonteCarlo})\n\nReturn the Metropolis-Hastings acceptance probability.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.apply_random_perturbation!-Tuple{Atoms, NQCDynamics.InitialConditions.MetropolisHastings.MonteCarloParameters, AbstractMatrix, Integer, Integer}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.apply_random_perturbation!","text":"apply_random_perturbation!(system::AbstractSystem{MonteCarlo}, R::AbstractMatrix, atom::Integer)\n\nRandomly perturb the xyz coordinates of a single atom.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.assess_proposal!-Tuple{NQCDynamics.AbstractSimulation, NQCDynamics.InitialConditions.MetropolisHastings.MonteCarloParameters, Any, Any, Any, Integer}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.assess_proposal!","text":"assess_proposal!(system::AbstractSystem{MonteCarlo}, Rᵢ, Rₚ, output, i)\n\nUpdate the energy, check for acceptance, and update the output. \n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.propose_centroid_move!-Union{Tuple{T}, Tuple{RingPolymerSimulation, NQCDynamics.InitialConditions.MetropolisHastings.PathIntegralMonteCarlo, Array{T, 3}, Array{T, 3}, Integer}} where T<:AbstractFloat","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.propose_centroid_move!","text":"propose_centroid_move!(system::RingPolymerSystem{MonteCarlo}, Rᵢ::Array{T, 3}, Rₚ::Array{T, 3}) where {T<:AbstractFloat}\n\nPropose a move for the ring polymer centroid for one atom.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.propose_move!-Tuple{Simulation, NQCDynamics.InitialConditions.MetropolisHastings.MonteCarlo, Matrix, Matrix, Integer}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.propose_move!","text":"propose_move!(system::System{MonteCarlo}, Rᵢ::Matrix{T}, Rₚ::Matrix{T}) where {T<:AbstractFloat}\n\nPropose simple cartesian move for a single atom.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.propose_normal_mode_move!-Union{Tuple{T}, Tuple{RingPolymerSimulation, NQCDynamics.InitialConditions.MetropolisHastings.PathIntegralMonteCarlo, Array{T, 3}, Array{T, 3}, Integer}} where T","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.propose_normal_mode_move!","text":"propose_normal_mode_move!(system::RingPolymerSystem{MonteCarlo}, Rᵢ::Array{T, 3}, Rₚ::Array{T, 3}) where {T}\n\nPropose a move for a single normal mode for a single atom.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.run_main_loop!-Tuple{Simulation, NQCDynamics.InitialConditions.MetropolisHastings.MonteCarlo, Matrix, Matrix, NQCDynamics.InitialConditions.MetropolisHastings.MonteCarloOutput}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.run_main_loop!","text":"run_main_loop!(system::System{MonteCarlo}, Rᵢ::Matrix, Rₚ::Matrix, output::MonteCarloOutput)\n\nMain loop for classical systems.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.run_main_loop!-Union{Tuple{T}, Tuple{RingPolymerSimulation, NQCDynamics.InitialConditions.MetropolisHastings.PathIntegralMonteCarlo, Array{T, 3}, Array{T, 3}, NQCDynamics.InitialConditions.MetropolisHastings.MonteCarloOutput}} where T","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.run_main_loop!","text":"Main loop for ring polymer systems.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.run_monte_carlo_sampling-Union{Tuple{T}, Tuple{Simulation, Matrix{T}, Dict{Symbol, T}, Real}} where T","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.run_monte_carlo_sampling","text":"run_monte_carlo_sampling(sim::AbstractSimulation, monte::MonteCarloParameters, R0)\n\nPerform Monte Carlo sampling for the system defined by the sim and monte parameters.\n\nFrom the initial positions specified R0 the system will be explored using the Metropolis-Hastings algorithm.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/initialconditions/#NQCDynamics.InitialConditions.MetropolisHastings.write_output!-Tuple{NQCDynamics.InitialConditions.MetropolisHastings.MonteCarloOutput, AbstractArray, AbstractFloat}","page":"InitialConditions","title":"NQCDynamics.InitialConditions.MetropolisHastings.write_output!","text":"write_output!(output::MonteCarloOutput, Rᵢ::AbstractArray, energy::AbstractFloat, i::Integer)\n\nStore the current configuration and associated energy.\n\n\n\n\n\n","category":"method"},{"location":"examples/reactive_scattering/#example-h2scattering","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"","category":"section"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"Our implementation allows us to simulate vibrational de-excitation probability during reactive scattering events at metal surfaces for any diatomic molecule  with a suitable model to describe energies and forces (and friction coefficients for MDEF simulations).  Here, we investigate the reactive scattering of hydrogen on a Ag(111) metal surface as a prototypical example.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"To run this kind of simulation, a set of initial positions and velocities (mathbfR and mathbfdotR) with ro-vibrational quantum states nu and j have to be generated (see EBK quantisation). With a specific ro-vibrational quantum state it is possible to compute different properties after molecular collision and energy transfer with the metal surface like the vibrational de-excitation probabilities discussed here.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"In order to reproduce the state-to-state vibrational de-excitation probability results presented originally by Yaolong Zhang, Reinhard J. Maurer, Hua Guo, Bin Jiang (2019) for this system, the same initial conditions were generated with QuantisedDiatomic.generate_configurations setting the initial ro-vibrational quantum state to (nu=2 j=0) as was explored in the original paper. ","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"As shown earlier in the EBK documentation we are able to generate a semiclassically quantised distribution for a diatomic molecule on a collision course with a metal surface. In this example we follow the EBK example using the H2AgModel to prepare our initial distribution and run our simulation.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"Specifically, we have produced a set of initial conditions with different translational energy (translational_energy keyword) ranging from 0.2 to 1.4 eV, locating the hydrogen molecule 8 Å away from the metal surface (height keyword) with a normal incidence.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"note: Atomic units\nAs usual, all quantities default to atomic units. Here we use Unitful to input the translational energy and height using different units, where they are later converted internally.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"using NQCDynamics\nusing NNInterfaces\nusing Unitful\nusing NQCDynamics.InitialConditions: QuantisedDiatomic\nusing JLD2\n\natoms = Atoms([:H, :H])\nmodel = H2AgModel()\ncell = PeriodicCell([11.1175 -5.5588 0.0; 0.0 9.628 0.0; 0.0 0.0 70.3079])\nsim = Simulation(atoms, model; cell=cell)\n\nν, J = 2, 0     # selected ro-vibrational quantum states  \nnsamples = 300  # number of configurations      \nEk = 0.5u\"eV\"   # Translational energy [eV] ; range considered [0.2-1.4] eV\nz = 8.0u\"Å\"     # Height [Å]  ; fixed at 8 Å\n\nconfigurations = QuantisedDiatomic.generate_configurations(sim, ν, J;\n    samples=nsamples, translational_energy=Ek, height=z)\nv = first.(configurations)\nr = last.(configurations)\n\ndistribution = DynamicalDistribution(v, r, (3,2))\nnothing # hide","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"tip: Saving the distribution\nGenerally it will be desirable to generate a distribution once and re-use it for multiple dynamics simulations. The simplest way to do this is to save the distribution using JLD2.jl. Refer to Saving and loading to learn more.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"In order to produce an unweighted distribution, the lateral and angular orientation are randomly selected within the unit cell. As an example of the spacial and orientation distribution generated with this module, a subset of data (300 configurations) is shown below. To run our production simulations, however, a set of 80,000 initial velocities and positions were used.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"(Image: initial conditions)","category":"page"},{"location":"examples/reactive_scattering/#Data-analysis-and-truncation-function","page":"Reactive scattering from a metal surface","title":"Data analysis and truncation function","text":"","category":"section"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"Since we are interested in the dynamics only when the molecule is close to the surface, we can use a callback to terminate the simulation early to save us some time. This requires defining a function that returns true when we want the simulation to terminate. This means we can set our time span relatively long since we expect most simulations to terminate before reaching the time limit.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"using Statistics: mean\nusing LinearAlgebra: norm\n\nh2distance(p) = norm(p[:,1] .- p[:,2])\n\n\"Terminates simulation if returns `true`.\" \nfunction termination_condition(u, t, integrator)::Bool\n    R = get_positions(u)\n    zcom = au_to_ang(mean(R[3,:]))          # Convert vertical centre of mass to angstrom\n    if zcom > 8.1                           # Scattering event\n        return true\n    elseif au_to_ang(h2distance(R)) > 2.5   # Reactive event\n        return true\n    else\n        return false\n    end\nend\n\nterminate = DynamicsUtils.TerminatingCallback(termination_condition)\ntspan = (0.0, 420.0u\"fs\")\nnothing # hide","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"In this example, we consider the outcome a reactive event if the H-H bond length is larger than 2.5 Å in any point of during the trajectory and a scattering event if the molecule rebounds to a vertical distance from the metal surface greater than 8.1 Å.","category":"page"},{"location":"examples/reactive_scattering/#MDEF-with-the-LDFA","page":"Reactive scattering from a metal surface","title":"MDEF with the LDFA","text":"","category":"section"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"Now that we have set up the initial distribution and some of our simulation parameters, we can choose which form of friction we would like use. First, let's use the LDFA implementation provided by the CubeLDFAModel. This takes a .cube file containing the electron density and will provide the friction during the dynamics. Here we have given the new model our model from above, which will provide the forces.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"using CubeLDFAModel\nmodel = LDFAModel(model, \"../assets/friction/test.cube\", atoms, friction_atoms=[1,2], cell)","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"Now we can pass all the variables defined so far to the Simulation and run multiple trajectories using run_ensemble.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"sim = Simulation{MDEF}(atoms, model, cell=cell, temperature=300u\"K\")\nensemble = run_ensemble(sim, tspan, distribution;selection=1:20,\n    dt=0.1u\"fs\", output=:position, trajectories=20, callback=terminate)","category":"page"},{"location":"examples/reactive_scattering/#MDEF-with-neural-network-friction","page":"Reactive scattering from a metal surface","title":"MDEF with neural network friction","text":"","category":"section"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"Above, we used the LDFA interpretation of MDEF to perform the simulation. However, the H2AgModel actually provides it's own friction tensor trained on ab initio data. This can be used by simply using the model directly, without wrapping it with the LDFAModel.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"model = H2AgModel()\nsim = Simulation{MDEF}(atoms, model, cell=cell, temperature=300u\"K\")\nensemble = run_ensemble(sim, tspan, distribution;selection=1:20,\n    dt=0.1u\"fs\", output=:position, trajectories=20, callback=terminate)","category":"page"},{"location":"examples/reactive_scattering/#Visualisation","page":"Reactive scattering from a metal surface","title":"Visualisation","text":"","category":"section"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"To show the effect of the truncation procedure, we have run 20 trajectories with and without the truncation function starting with an initial translation energy at 1.0 eV. For both figures, the total and kinetic energies are shown in the top panels along with the H-H distance and centre of mass z coordinate for each individual trajectory.","category":"page"},{"location":"examples/reactive_scattering/","page":"Reactive scattering from a metal surface","title":"Reactive scattering from a metal surface","text":"(Image: truncation)","category":"page"},{"location":"NQCModels/overview/#NQCModels.jl","page":"NQCModels.jl","title":"NQCModels.jl","text":"","category":"section"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"To perform nonadiabatic molecular dynamics simulations, it is necessary to define the system Hamiltonian. For simple models, this often comes in the form of small matrix in the diabatic representation but equally the electronic Hamiltonian could be obtained directly from ab initio electronic structure theory.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"NQCModels.jl is a package that aims to provide a common interface for defining these models that is flexible enough to allow for a wide range of specifications and requirements. NQCDynamics.jl uses this interface to obtain the potentials and couplings necessary to perform the dynamics simulations. Along with the minimal interface, NQCModels.jl also provides a small set of popular models often used in the field of nonadiabatic dynamics.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"note: Note\nTaking advantages of Julia's seamless modularity, NQCModels.jl is designed as a separate package so that it can also be used independently from the main package.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"Depending on the quantities provided by the Model, we use Julia's abstract type system to group models that provide the same quantities. Currently, there are two top-level abstract types: AdiabaticModel and DiabaticModel. The AdiabaticModel is used for adiabatic dynamics, providing only the potential and force used in classical mechanics. The DiabaticModel is used for nonadiabatic dynamics,  where the potential is instead a Hermitian matrix.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"In the Getting started section we briefly touched on how the AdiabaticModel works and introduced one of the included models. Here let's take a look at a DiabaticModel, which is more appropriate for nonadiabatic dynamics.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"The DoubleWell is a two state, 1 dimensional model where each state is harmonic with linear coupling to the single degree of freedom.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"using NQCModels\n\nmodel = DoubleWell()","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"Our DoubleWell implements the functions potential, derivative, nstates and ndofs that return the potential, the derivative of the potential, the number of states, and the number of degrees of freedom, respectively.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"potential(model, 0.2)\nderivative(model, 0.2)\nnstates(model)\nndofs(model)","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"Since this is a 1D model, the position argument that appears in the derivative and the potential is a real number. For higher dimensional models with multiple atoms, the position will need to be provided as an AbstractMatrix.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"To understand how this can extend to another dimension, we can take a quick look at the GatesHollowayElbow model which is another two state diabatic model, but this one uses two dimensions to model a diatomic molecule interacting with a surface. The two coordinates are the molecular bond length and the distance from the surface. Technically, the model has been defined such that there are two atoms, each with only a single degree of freedom. This allows us to use different masses for each of the coordinates when performing dynamics.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"model = GatesHollowayElbow()\npotential(model, [1.0 1.0])\nderivative(model, [1.0 1.0])\nnstates(model)\nndofs(model)","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"Here we see how the derivative now becomes a Matrix with size matching our input, but each entry is a Hermitian containing the elementwise derivative of the potential with respect to each degree of freedom. In this case, the Matrix has size = (1, 2), but it should be clear how this can extend to arbitrary numbers of atoms and degrees of freedom for complex models.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"The models currently available can be seen in type tree of the Model below. The leaves of the tree are the concrete models, whereas each branch is one of the abstract types. Each of these models can be seen in the Analytic model library and many shall return later when we investigate the dynamics methods.","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"import AbstractTrees # hide\nimport InteractiveUtils: subtypes # hide\nimport NQCModels: Model # hide\nAbstractTrees.children(x::Type) = subtypes(x) # hide\nAbstractTrees.print_tree(Model) # hide","category":"page"},{"location":"NQCModels/overview/","page":"NQCModels.jl","title":"NQCModels.jl","text":"note: Contributing new models\nTo learn more about NQCModels.jl and learn how to implement new models, visit the developer documentation.","category":"page"},{"location":"devdocs/new_methods/#Contributing-a-new-method","page":"Contributing a new method","title":"Contributing a new method","text":"","category":"section"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"A key goal of NQCDynamics.jl is to provide an accessible toolkit for implementing new nonadiabatic dynamics methods. This page details the steps you must take in order to create a new dynamics method. The existing methods are stored inside the DynamicsMethods submodule, and this is where new methods should be implemented. Technically, it is possible to implement new methods completely separately from the package by importing and extending the relevant functions but if you would like to include your method in the package, it should be added within this submodule.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"note: Note\nGenerally, each method has its own file, though similar methods are grouped into submodules and share functionality across files. For example, multiple surface hopping methods have been implemented in the submodule DynamicsMethods.SurfaceHoppingMethods, where some functions are shared across the files. ","category":"page"},{"location":"devdocs/new_methods/#Basic-implementation","page":"Contributing a new method","title":"Basic implementation","text":"","category":"section"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"To implement a new dynamics method, the necessary steps are:","category":"page"},{"location":"devdocs/new_methods/#Create-a-new-subtype-of-DynamicsMethods.Method.","page":"Contributing a new method","title":"Create a new subtype of DynamicsMethods.Method.","text":"","category":"section"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"This Method acts as an extra parameter inside the simulation that allows us to specify any extra information needed for our dynamics method. This can be a good place to include any temporary arrays and parameters for the simulation. Refer to the Julia manual section on Composite Types to learn how this types are created. Here, our type is called MyMethod and we have included an a parameter that will influence our dynamics:","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"using NQCDynamics\n\nstruct MyMethod <: DynamicsMethods.Method\n    a::Float64\nend","category":"page"},{"location":"devdocs/new_methods/#Implement-DynamicsVariables","page":"Contributing a new method","title":"Implement DynamicsVariables","text":"","category":"section"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"This function returns an AbstractArray of the variables to be used as the initial condition for the simulation. The array should contain all of the variables that will change during the dynamics.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"tip: Choosing an array format\nThe only constraint on the array type is that they are AbstractArrays. It could be a simple matrix or vector, but usually we use ComponentArrays.jl to structure the variables. The ComponentVector allows us to collect variables of different types into a convenient format to perform dynamics.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"For classical dynamics, this would include only the positions and velocities, however, for FSSH we must also include the continuous electronic variables and the discrete state.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"note: Discrete variables\nSome methods such as FSSH have discontinuous variables, like the current occupied state. Discrete variables be handled separately using DEDataArrays.jl. For surface hopping methods, we have the SurfaceHoppingVariables type that uses this to combine a ComponentVector containing the continuous variables and the discrete state label.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"For our new method, MyMethod, we implement the DynamicsVariables function and return a ComponentVector containing the velocities, positions and extra variables x. Inside this function we are free to take any inputs and manipulate them before returning the result. As an example, suppose that our x variables are randomly generated each time we run the dynamics, this could be done as follows:","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"using ComponentArrays\n\nfunction DynamicsMethods.DynamicsVariables(sim::Simulation{<:MyMethod}, v, r, k)\n    return ComponentVector(v=v, r=r, x=rand()*k)\nend","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"Here, we take the velocities v, positions r and assign them to the output as we would for classical dynamics, but we also generate a random between 0 and k, where k was given as input.","category":"page"},{"location":"devdocs/new_methods/#Implement-motion!(du,-u,-sim,-t)","page":"Contributing a new method","title":"Implement motion!(du, u, sim, t)","text":"","category":"section"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"This function should fill du with the time-derivative of the dynamics variables u in the usual way expected by DifferentialEquations.jl. We use the in-place version, where each element of du is filled with the time derivative of the correponding element in u.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"Inside the DynamicsUtils submodule there are some useful functions like velocity! and divide_by_mass! which can handle some of the common parts of the motion! function. You are free to perform whatever manipulations you like inside this function, but note that motion! is a performance critical function, called numerous times during the simulation, so you should attempt to minimise allocations inside this function.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"note: Note\nBy convention in Julia, functions that end with the ! modify at least one of their arguments.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"function DynamicsMethods.motion!(du, u, sim::Simulation{MyMethod}, t)\n\n    DynamicsUtils.velocity!(du.r, u.v, u.r, sim, t) # Set du.r equal to the velocity\n\n    # Set the acceleration of the particles\n    du.v .= -sim.method.a .* u.r # Use the `a` parameter we stored in the `method`.\n    DynamicsUtils.divide_by_mass!(du.v, sim.atoms.masses) # Divide du.v by the mass\n\n    du.x .= 1 ./ u.x # Set time derivative of `x`.\n\n    return nothing # The return of this function is not used so the return is unimportant\nend","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"Here we have set the time derivative of the positions equal to the velocity, the time derivative of the velocities equal to the acceleration where the force involves the parameter a. Finally, the time derivative of the extra x variable is also set.","category":"page"},{"location":"devdocs/new_methods/#Solve-a-trajectory","page":"Contributing a new method","title":"Solve a trajectory","text":"","category":"section"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"To perform a simulation with our new method, we can write a script in the usual format and run the dynamics. In this script, we have a single atom with a mass of 1 with a single degree of freedom. We match this by initialising the positions and velocities equal to random 1x1 matrices.  The a parameter of the method has been set equal to 2.0, and the initial value of x has been set to 0.5.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"sim = Simulation(Atoms(1), Free(), MyMethod(2.0))\nu = DynamicsVariables(sim, rand(1,1), rand(1,1), [0.5])\n\nsol = run_trajectory(u, (0.0, 10.0), sim, output=(:position, :velocity, :u))","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"note: Note\nIn the definition of our motion! method, we have accessed only the atoms field of the simulation. This means that the model we pass to the Simulation constructor is not used. Generally the model is accessed through the calculator interface and examples of its usage can be found by referring the implementations of the existing methods.","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"To visualise the result we can plot each of the quantities from the output table:","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"using Plots\n\nplot(sol, :position, label=\"Position\")\nplot!(sol, :velocity, label=\"Velocity\")\nplot!(sol, :u, label=\"u\", legend=true)\nylabel!(\"Value(t)\")","category":"page"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"note: Note\nThe additional x parameter that we created cannot be accessed in the output tuple by name as with position and velocity since it is not a standard quantity. Instead, we request u which contains all of the dynamical variables. In the plot, two of the lines labelled u overlap the position and velocity result. The unique line labelled u is the x variable. When implementing your method, if you want to add new output quantities you should do this inside the DynamicsOutputs submodule.","category":"page"},{"location":"devdocs/new_methods/#Advanced-tips","page":"Contributing a new method","title":"Advanced tips","text":"","category":"section"},{"location":"devdocs/new_methods/#Is-there-a-custom-algorithm-you-can-implement?","page":"Contributing a new method","title":"Is there a custom algorithm you can implement?","text":"","category":"section"},{"location":"devdocs/new_methods/","page":"Contributing a new method","title":"Contributing a new method","text":"Some dynamics methods have special algorithms that are tailored to the specific problem and achieve better performance than the general algorithms include in DifferentialEquations.jl. For example, ring polymer methods typically use a symplectic scheme to solve for the internal modes of the ring polymer, allowing much larger timesteps. The DifferentialEquations.jl framework provides a simple interface for adding new algorithms, check out the developer documentation to learn how it works. You can also find some examples of custom algorithms in the DynamicsMethods.IntegrationAlgorithms module.","category":"page"},{"location":"devdocs/models/#devdocs-model","page":"Implementing a new model","title":"Implementing a new model","text":"","category":"section"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"NQCModels.jl aims to provide a unified interface for defining model Hamiltonians for nonadiabatic dynamics simulations.","category":"page"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"Here, we walk through the implementation of a few different types of model to explain the interface.","category":"page"},{"location":"devdocs/models/#Abstract-types","page":"Implementing a new model","title":"Abstract types","text":"","category":"section"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"Julia's abstract type system can be likened to the inheritance concept from object-oriented programming or the trait system from Rust. It allows us to defined shared behaviour for a groups of structs and allows us to define a common set of functions that all of the concrete types must implement.","category":"page"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"In NQCModels.jl the top level abstract type is the Model, under which all of our models must fall. The second tier below this includes the two abstract types AdiabaticModel and DiabaticModel. These form the two distinct branches within the NQCModels type hierachy and the shared behaviour across the branches is minimal. The AdiabaticModel describes the familiar form from molecular dynamics that provides a single potential energy surface. The DiabaticModel instead provides  multiple potential energy surfaces with couplings between them. As implied by the name, these are in the diabatic representation. If the desired model does not fall under either of these branches, a new abstract type should be created.","category":"page"},{"location":"devdocs/models/#Minor-branches","page":"Implementing a new model","title":"Minor branches","text":"","category":"section"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"Under the two main branches there also exists some specialised abstract types that are useful in some cases, such as when using many electronic states, or when implementing extra functions is required. See the docstrings for more info:","category":"page"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"AdiabaticFrictionModel\nLargeDiabaticModel\nDiabaticFrictionModel","category":"page"},{"location":"devdocs/models/#Example-implementations","page":"Implementing a new model","title":"Example implementations","text":"","category":"section"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"To implement a new model, you first select the abstract type, where you should first take a look at the docstring for the abstract type (click on the links above). There, a list of the functions  that need to be implemented along with an example implementation are provided.","category":"page"},{"location":"devdocs/models/","page":"Implementing a new model","title":"Implementing a new model","text":"For further examples, you can also take a look into the source code of the NQCModels.jl package to see how the analytic models have been implemented.  If you have any issues or questions about implementing a new model, open up an issue on Github and we can work together to resolve the problem. ","category":"page"},{"location":"api/NQCDynamics/estimators/#Estimators","page":"Estimators","title":"Estimators","text":"","category":"section"},{"location":"api/NQCDynamics/estimators/","page":"Estimators","title":"Estimators","text":"Modules=[NQCDynamics.Estimators]","category":"page"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators","page":"Estimators","title":"NQCDynamics.Estimators","text":"Estimators\n\nFunctions for computing thermal expectation values as ensemble averages.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators.adiabatic_population","page":"Estimators","title":"NQCDynamics.Estimators.adiabatic_population","text":"adiabatic_population\n\n\n\n\n\n","category":"function"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators.diabatic_population","page":"Estimators","title":"NQCDynamics.Estimators.diabatic_population","text":"diabatic_population\n\n\n\n\n\n","category":"function"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators.kinetic_energy-Tuple{Simulation, Any}","page":"Estimators","title":"NQCDynamics.Estimators.kinetic_energy","text":"kinetic_energy(sim, u)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators.potential_energy-Tuple{NQCDynamics.AbstractSimulation, Any}","page":"Estimators","title":"NQCDynamics.Estimators.potential_energy","text":"potential_energy(sim, u)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators.radius_of_gyration-Union{Tuple{T}, Tuple{RingPolymerSimulation, AbstractArray{T, 3}}} where T","page":"Estimators","title":"NQCDynamics.Estimators.radius_of_gyration","text":"radius_of_gyration(sim, r)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators.total_energy-Tuple{NQCDynamics.AbstractSimulation, Any}","page":"Estimators","title":"NQCDynamics.Estimators.total_energy","text":"total_energy(sim, u)\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/estimators/#NQCDynamics.Estimators.@estimate-Tuple{Any}","page":"Estimators","title":"NQCDynamics.Estimators.@estimate","text":"@estimate f(simulation, vector)\n\nEvaluate f(simulation, vector[i]) for all i and return the average.\n\nCan be used for any function defined in Estimators.jl.\n\n\n\n\n\n","category":"macro"},{"location":"initialconditions/samplingmethods/hamiltonian/#hmc-sampling","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"","category":"section"},{"location":"initialconditions/samplingmethods/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"Our implementation of Hamiltonian Monte Carlo (HMC) is a light wrapper around the AdvancedHMC.jl package. If you want to learn about the HMC theory, refer to the references and documentation provided with AdvancedHMC.jl.","category":"page"},{"location":"initialconditions/samplingmethods/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"Currently, our implementation works for systems with classical nuclei only (i.e. Simulation but not RingPolymerSimulation).","category":"page"},{"location":"initialconditions/samplingmethods/hamiltonian/#Example","page":"Thermal Hamiltonian Monte Carlo","title":"Example","text":"","category":"section"},{"location":"initialconditions/samplingmethods/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"In this example we use Hamiltonian Monte Carlo to sample the canonical distribution of a 3 dimensional harmonic oscillator potential containing 4 atoms.","category":"page"},{"location":"initialconditions/samplingmethods/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"using NQCDynamics\nusing Unitful\nusing UnitfulAtomic\n\nsim = Simulation(Atoms([:H, :H, :C, :C]), Harmonic(dofs=3); temperature=300u\"K\")\nr0 = randn(size(sim))\nchain, stats = InitialConditions.ThermalMonteCarlo.run_advancedhmc_sampling(sim, r0, 1e4)\nnothing # hide","category":"page"},{"location":"initialconditions/samplingmethods/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"The Monte Carlo chain contains the nuclear configurations that we have sampled:","category":"page"},{"location":"initialconditions/samplingmethods/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"chain","category":"page"},{"location":"initialconditions/samplingmethods/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"and stats contains extra information about the sampling procedure:","category":"page"},{"location":"initialconditions/samplingmethods/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"stats","category":"page"},{"location":"initialconditions/samplingmethods/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"Here we should see that the energy expectation for the generated ensemble matches with the equipartition theorem:","category":"page"},{"location":"initialconditions/samplingmethods/hamiltonian/","page":"Thermal Hamiltonian Monte Carlo","title":"Thermal Hamiltonian Monte Carlo","text":"Estimators.@estimate potential_energy(sim, chain)\naustrip(sim.temperature) * 3 * 4 / 2","category":"page"},{"location":"NQCModels/analyticmodels/#Analytic-model-library","page":"Analytic model library","title":"Analytic model library","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"This page plots many of the analytic models included in NQCDynamics.","category":"page"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"tip: Tip\nTo produce the plots we use two of Julia's plotting options Plots and Makie. Plots has a mature recipe system that allows us to define custom plots for the 1D models but we use Makie to produce the more complex images. Each of these has their pros and cons and if you are interested in producing plots using Julia you should visit their documentation to decide which is best for you.","category":"page"},{"location":"NQCModels/analyticmodels/#[AdiabaticModels](@ref-NQCModels.AdiabaticModels)","page":"Analytic model library","title":"AdiabaticModels","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"These models are used for classical dynamics and provide a single potential energy surface.","category":"page"},{"location":"NQCModels/analyticmodels/#[Harmonic](@ref)","page":"Analytic model library","title":"Harmonic","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nplot(-10:0.1:10, Harmonic())","category":"page"},{"location":"NQCModels/analyticmodels/#[DiatomicHarmonic](@ref)","page":"Analytic model library","title":"DiatomicHarmonic","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels\nusing Plots\n\nmodel = DiatomicHarmonic(r₀=10.0)\nf(x,y) = potential(model, [x y 0])\ncontour(-10:0.1:10, -10:0.1:10, f, fill=true)\nxlabel!(\"x coordinate /a₀\")\nylabel!(\"y coordinate /a₀\")","category":"page"},{"location":"NQCModels/analyticmodels/#[DarlingHollowayElbow](@ref)","page":"Analytic model library","title":"DarlingHollowayElbow","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels\nusing NQCBase: eV_to_au\nusing CairoMakie\n\nmodel = DarlingHollowayElbow()\nV(x,z) = potential(model, [x, z])\n\nx = range(-0.5, 3.5, length=200)\nz = range(-0.5, 4.5, length=200)\n\nf = Figure()\nax = Axis(f[1,1], xlabel=\"Bond length /a₀\", ylabel=\"Surface molecule distance /a₀\")\n\nlevels = eV_to_au.([-0.1, 0.1, 0.3, 0.5, 0.7, 0.9, 1.1])\ncontourf!(ax, x, z, V, levels=levels)\ncontour!(ax, x, z, V, levels=levels, color=:black)\nColorbar(f[1,2], limits=(-0.1, 1.1))\nxlims!(-0.5, 3.5)\nylims!(-0.5, 4.5)\nf","category":"page"},{"location":"NQCModels/analyticmodels/#[DiabaticModels](@ref-NQCModels.DiabaticModels)","page":"Analytic model library","title":"DiabaticModels","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"These models define a Hermitian potential operator in a diabatic basis. These can be used for various forms of nonadiabatic dynamics.","category":"page"},{"location":"NQCModels/analyticmodels/#[TullyModelOne](@ref)","page":"Analytic model library","title":"TullyModelOne","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nplot(-10:0.1:10, TullyModelOne(); coupling=true)","category":"page"},{"location":"NQCModels/analyticmodels/#[TullyModelTwo](@ref)","page":"Analytic model library","title":"TullyModelTwo","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nplot(-10:0.1:10, TullyModelTwo(); coupling=true)","category":"page"},{"location":"NQCModels/analyticmodels/#[TullyModelThree](@ref)","page":"Analytic model library","title":"TullyModelThree","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nplot(-10:0.1:10, TullyModelThree(); coupling=true)","category":"page"},{"location":"NQCModels/analyticmodels/#[ThreeStateMorse](@ref)","page":"Analytic model library","title":"ThreeStateMorse","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nplot(2:0.01:12, ThreeStateMorse(), ylims=(0, 0.06), coupling=true)","category":"page"},{"location":"NQCModels/analyticmodels/#[OuyangModelOne](@ref)","page":"Analytic model library","title":"OuyangModelOne","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nplot(-10:0.1:10, OuyangModelOne())","category":"page"},{"location":"NQCModels/analyticmodels/#[DoubleWell](@ref)","page":"Analytic model library","title":"DoubleWell","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels, Plots\nplot(-5:0.1:5, DoubleWell(); coupling=true)","category":"page"},{"location":"NQCModels/analyticmodels/#[GatesHollowayElbow](@ref)","page":"Analytic model library","title":"GatesHollowayElbow","text":"","category":"section"},{"location":"NQCModels/analyticmodels/","page":"Analytic model library","title":"Analytic model library","text":"using NQCModels\nusing CairoMakie\n\nmodel = GatesHollowayElbow()\nv1(x,z) = potential(model, [x z])[1,1]\nv2(x,z) = potential(model, [x z])[2,2]\ncoupling(x,z) = potential(model, [x z])[1,2]\n\nx = range(-0.5, 4.0, length=200)\nz = range(-0.5, 4.0, length=200)\n\nf = Figure()\nax = Axis(f[1,1], xlabel=\"x coordinate\", ylabel=\"z coordinate\")\n\ncontour!(ax, x, z, coupling, color=:black, levels=10, label=\"V12\")\ncontour!(ax, x, z, v1, color=:blue, levels=0:0.01:0.1, label=\"V11\")\ncontour!(ax, x, z, v2, color=:red, levels=0:0.01:0.1, label=\"V22\")\naxislegend(ax)\nxlims!(-0.5, 4.0)\nylims!(-0.5, 4.0)\nf","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/#rpsh-dynamics","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"Ring polymer surface hopping was one of the early attempts to extend RPMD to the realm of nonadiabatic dynamics Philip Shushkov, Richard Li, John C. Tully (2012). On the surface, the concept is reasonably simple. Since RPMD proceeds on a single adiabatic surface, it should be possible to directly combine the FSSH scheme with ring polymer dynamics to approximately include nuclear quantum effects in the surface hopping dynamics. However, there are some ambiguities surrounding the exact implementation when considering how to couple the electronic equations to the nuclear equations and how the velocity rescaling should be implemented.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"Originally, two varieties were proposed: the bead approximation and the centroid approximation. The centroid approximation is the simpler of the two and involves directly replacing the classical particle in the FSSH algorithm with the ring polymer centroid. This means that the nonadiabatic couplings evaluated at the centroid and the centroid velocity are used to propagate the electronic equations, and the kinetic energy is conserved on the centroid level. This is the version that is implemented here.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"The bead approximation involves evaluating the nonadiabatic couplings for every bead and using these contributions from every bead to propagate the electronics. This version acts to conserve the kinetic energy for the entire ring polymer. Philip Shushkov, Richard Li, John C. Tully (2012) describes both the centroid and bead approximations, Farnaz A. Shakib, Pengfei Huo (2017) uses the centroid approximation.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/#Example","page":"Ring polymer surface hopping (RPSH)","title":"Example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"In this example we can apply RPSH to the ThreeStateMorse model as shown in the supporting info of Farnaz A. Shakib, Pengfei Huo (2017). This model has a single particle with mass of 20000 a.u. and we use 4 beads for the ring polymer.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"using NQCDynamics\nusing Unitful\n\natoms = Atoms(20000)\nmodel = ThreeStateMorse()\nsim = RingPolymerSimulation{FSSH}(atoms, model, 4; temperature=300u\"K\")\nnothing # hide","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"For our initial conditions let's use a position distribution centred at 2.1 a.u. with Boltzmann velocities at 300 K.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"using Distributions: Normal\n\nposition = Normal(2.1, 1 / sqrt(20000 * 0.005))\nvelocity = BoltzmannVelocityDistribution(300u\"K\" * nbeads(sim), masses(sim), size(sim))\ndistribution = DynamicalDistribution(velocity, position, size(sim)) * SingleState(1)\nnothing # hide","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"Now let's run an ensemble of trajectories that sample from this distribution. For the output we will receive the diabatic population at intervals of t=50 and it will be averaged over all trajectories by the :mean keyword.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"solution = run_ensemble(sim, (0.0, 3000.0), distribution;\n    saveat=50, trajectories=5e2, dt=1,\n    output=TimeCorrelationFunctions.PopulationCorrelationFunction(sim, Diabatic()),\n    reduction=:mean, u_init=[zeros(3,3) for i=1:length(0:50:3000)])","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"note: Note\nIn the examples section at the end of the documentation we will return to this model and compare the performance of multiple methods.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"Here we plot diabatic population of each state as a function of time. The result closely resembles the literature reference (Farnaz A. Shakib, Pengfei Huo (2017)). The small discrepancy that occurs at around t=2000 is due to our use of an alternative method to calculate the diabatic populations. A discussion on this topic is available from Brian R. Landry, Martin J. Falk, Joseph E. Subotnik (2013).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"using Plots\n\nplot(0:50:3000, [p[1,1] for p in solution], label=\"State 1\")\nplot!(0:50:3000, [p[1,2] for p in solution], label=\"State 2\")\nplot!(0:50:3000, [p[1,3] for p in solution], label=\"State 3\")\nxlabel!(\"Time /a.u.\")\nylabel!(\"Population\")","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpsh/","page":"Ring polymer surface hopping (RPSH)","title":"Ring polymer surface hopping (RPSH)","text":"For our simulation we are using a Normal distribution to initialise our ring polymer configuration. Since ring polymer surface hopping has not been rigorously derived, this choice is somewhat arbitrary and it is possible that better results could be achieved using a free ring polymer distribution instead. Ralph Welsch, Kai Song, Qiang Shi, Stuart C. Althorpe, Thomas F. Miller (2016) provides a theoretical description of how nonequilibrium simulations using RPMD should be performed. This techniques here should likely be applied to RPSH too.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the documentation for NQCDynamics,  a package for performing nonadiabatic molecular dynamics simulations. The documentation covers both how to use the existing code and describes the intricacies of the implementations, hoping to make further contributions as simple as possible.","category":"page"},{"location":"#Objectives","page":"Introduction","title":"Objectives","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Achieve high performance along with good readability, extensibility, maintainability\nHandle both simple models and high-dimensional systems\nHighlight the advantages of Julia in the field of nonadiabatic dynamics\nEncourage code sharing and reuse within the nonadiabatic dynamics community","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Reproducibility is a pressing issue in the field of theoretical chemistry and physics as often studies either do not attempt to provide all necessary data or code for full reproducibility of the work. This can lead to difficulties when attempting to better understand the theory and implementation of the method and makes it difficult for students not only to learn existing models and theories, but also to improve and extend these.  This project provides implementations for existing dynamics methods along with a framework that can be used for future research with the goal of encouraging greater code sharing and reuse within the nonadiabatic dynamics community.","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Here we provide a list of currently implemented features of the code. We encourage contributions and implementations of methods. To do so, please open up an issue/pull request on Github!","category":"page"},{"location":"#Dynamics-methods","page":"Introduction","title":"Dynamics methods","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Classical molecular dynamics\nClassical Langevin dynamics\nFewest-switches surface hopping (FSSH)\nMolecular dynamics with electronic friction (MDEF)\nRing polymer molecular dynamics (RPMD)\nNonadiabatic ring polymer molecular dynamics (NRPMD)\nRing polymer surface hopping (RPSH)\nEhrenfest molecular dynamics","category":"page"},{"location":"#Generating-initial-conditions","page":"Introduction","title":"Generating initial conditions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Thermal Metropolis-Hastings Monte Carlo\nThermal Hamiltonian Monte Carlo\nLangevin dynamics\nSemiclassical EBK quantisation","category":"page"},{"location":"#Dynamics-with-DifferentialEquations.jl","page":"Introduction","title":"Dynamics with DifferentialEquations.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The DifferentialEquations ecosystem from the SciML organisation provides a large library of integration algorithms along with a simple interface for implementing new algorithms that can be tailored for specific nonadiabatic dynamics methods. Further, they provide helpful utilities for introducing discontinuities through the  callback interface or handling many trajectories at once to obtain ensemble averaged observables with the ensemble interface. We can take advantage of these utilities by basing our dynamics setup on this framework which significantly simplifies the implementation of new methods.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#.-Install-Julia","page":"Introduction","title":"1. Install Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Download and install the current stable release from the Julia website. For most platforms julia is provided as a precompiled binary and do not require any installation procedure. However, you need to specify the path to julia or create a symbolic link to the executable that is in your systempath. ","category":"page"},{"location":"#.-Install-the-NQCRegistry","page":"Introduction","title":"2. Install the NQCRegistry","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Since the package is not included in the default registry (General), we must first install the NQCRegistry. This gives access to the core NQCDynamics package along with some dependencies and add-ons. First, enter the Julia REPL by executing julia from the command line. Then press ] to enter pkg mode. The prompt should change from julia> to pkg>. Install the registry directly from Github with: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> registry add \"https://github.com/NQCD/NQCRegistry\"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nIf this is the first time you're using Julia there's a chance that the General registry will not have been installed. Run pkg> registry status to view the installed registries. If General is not present, run pkg> registry add General before proceeding to the next step.","category":"page"},{"location":"#.-Install-the-package","page":"Introduction","title":"3. Install the package","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Now that the registry has been added, the package can be installed in the same way as any other registered Julia package:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add NQCDynamics","category":"page"},{"location":"#.-Use-the-package!","page":"Introduction","title":"4. Use the package!","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using NQCDynamics","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You are now free to proceed to the next section and learn how to use the package. If you would like you can complete step 5 to double check your installation.","category":"page"},{"location":"#.-Run-the-tests-(optional)","page":"Introduction","title":"5. Run the tests (optional)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To check the package has been installed correctly and everything is working, you can execute the tests with:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> test NQCDynamics","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nThe tests use some extra functionality from the JuliaMolSim registry which can be added directly from Github with pkg> registry add \"https://github.com/JuliaMolSim/MolSim\". Without this, the tests will not run successfully.","category":"page"},{"location":"#How-to-use-this-documentation","page":"Introduction","title":"How to use this documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The first page to read is the Getting started section which walks through all the ingredients needed to perform a conventional classical molecular dynamics simulation. After this, the reader is free to explore at their leisure since everything else builds directly upon sections from the Getting started page.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"examples/threestatemorse/#Time-dependent-populations-with-the-ThreeStateMorse-model","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"","category":"section"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"In this example we investigate the time-dependent populations of the three state morse model parametrised to describe photodissociation processes (Eduardo A. Coronado, Jianhua Xing, William H. Miller (2001)). This reference introduces three versions of this model with different parameter sets. Our ThreeStateMorse model matches model C from the reference.","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"First let's visualise the diabats and couplings for the model. You can see two regions where the diabats cross with non-zero coupling where we can expect to see population transfer.","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"using NQCDynamics\nusing CairoMakie\n\nx = range(2, 12, length=200)\nmodel = ThreeStateMorse()\nV = potential.(model, x)\n\nfig = Figure()\nax = Axis(fig[1,1], xlabel=\"Nuclear coordinate /a.u.\", ylabel=\"Potential energy /a.u.\")\n\nlines!(ax, x, [v[1,1] for v in V], label=\"State 1\")\nlines!(ax, x, [v[2,2] for v in V], label=\"State 2\")\nlines!(ax, x, [v[3,3] for v in V], label=\"State 3\")\n\nlines!(ax, x, [v[1,2] for v in V], label=\"Coupling 12\")\nlines!(ax, x, [v[2,3] for v in V], label=\"Coupling 23\")\nlines!(ax, x, [v[1,3] for v in V], label=\"Coupling 13\")\n\nxlims!(2, 12)\nylims!(0, 0.06)\naxislegend(ax)\n\nfig ","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"To this model we can apply any of the methods capable of starting the population on a single diabatic state and returning the population as a function of time. Here, let's use FSSH and Ehrenfest. We can expect the nuclear quantum effects here to be minimal since the nuclear mass is chosen to be 20000. ","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"m = 20000\natoms = Atoms(m)\nnothing # hide","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"For our initial conditions, we use the Wigner distribution for a Harmonic oscillator centred at 2.1 with a frequency of 5e-3 at a temperature of 300 K. This distribution is chosen to mimic a thermal ground state distribution before photoexcitation.","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"using Distributions: Normal\nusing Unitful, UnitfulAtomic\n\nω = 5e-3\nβ = 1/austrip(300u\"K\")\nposition = PositionHarmonicWigner(ω, β, m; centre=2.1)\nvelocity = VelocityHarmonicWigner(ω, β, m)\ndistribution = DynamicalDistribution(velocity, position, (1,1)) * SingleState(1)\nnothing # hide","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"Now let's run the two simulations using Ehrenfest and FSSH. For both simulations we use the same initial distribution and average the results using reduction=:mean. TimeCorrelationFunctions.PopulationCorrelationFunction will correlate the intial population with the final population at each timestep.","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"sim = Simulation{FSSH}(atoms, model)\nfssh_result = run_ensemble(sim, (0.0, 3000.0), distribution;\n    saveat=10, trajectories=1e3,\n    output=TimeCorrelationFunctions.PopulationCorrelationFunction(sim, Diabatic()),\n    reduction=:mean, dt=1.0, u_init=[zeros(3,3) for i=1:length(0:10:3000)])\nsim = Simulation{Ehrenfest}(atoms, model)\nehrenfest_result = run_ensemble(sim, (0.0, 3000.0), distribution;\n    saveat=10, trajectories=1e3,\n    output=TimeCorrelationFunctions.PopulationCorrelationFunction(sim, Diabatic()),\n    reduction=:mean, dt=1.0, u_init=[zeros(3,3) for i=1:length(0:10:3000)])\n\nfig = Figure()\nax = Axis(fig[1,1], xlabel=\"Time /a.u.\", ylabel=\"Population\")\n\nx = 0:10:3000\nlines!(ax, x, [p[1,1] for p in fssh_result], label=\"FSSH State 1\", color=:red)\nlines!(ax, x, [p[1,2] for p in fssh_result], label=\"FSSH State 2\", color=:green)\nlines!(ax, x, [p[1,3] for p in fssh_result], label=\"FSSH State 3\", color=:blue)\n\nlines!(ax, x, [p[1,1] for p in ehrenfest_result], label=\"Ehrenfest State 1\", color=:red, linestyle=:dash)\nlines!(ax, x, [p[1,2] for p in ehrenfest_result], label=\"Ehrenfest State 2\", color=:green, linestyle=:dash)\nlines!(ax, x, [p[1,3] for p in ehrenfest_result], label=\"Ehrenfest State 3\", color=:blue, linestyle=:dash)\naxislegend(ax)\n\nfig","category":"page"},{"location":"examples/threestatemorse/","page":"Time-dependent populations with the ThreeStateMorse model","title":"Time-dependent populations with the ThreeStateMorse model","text":"To reduce the build time for the documentation the results here are underconverged but already it is clear that both of these methods come close to the exact result shown by Eduardo A. Coronado, Jianhua Xing, William H. Miller (2001). After performing enough trajectories to converge the population dynamics, we would be better able to judge the effectiveness of FSSH and Ehrenfest at reproducing the exact quantum dynamics for this model.","category":"page"},{"location":"devdocs/diffeq/#DifferentialEquations.jl-integration","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"","category":"section"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"NQCDynamics.jl is built directly on top of the established DifferentialEquations.jl that provides a vast array of features. By using DifferentialEquations.jl to perform the dynamics, we can immediately exploit many of these features to save us a lot of work. This page details some of the features from DifferentialEquations.jl that we have used.","category":"page"},{"location":"devdocs/diffeq/#devdocs-callbacks","page":"DifferentialEquations.jl integration","title":"Callbacks","text":"","category":"section"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"Callbacks allow us to introduce extra code during the dynamics without needing to meddle with the integration code directly. On the developer side, [Callbacks] is the mechanism used for the saving in the run_trajectory function and the surface hopping procedure during FSSH. The user can also write their own callbacks and give these to any of the dynamics functions to manipulate the progress of the dynamics or introduce their own saving mechanism.","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"We also provide two pre-made callbacks which can be given to the dynamics functions. These are the TerminatingCallback, for terminating the simulation early, and the CellBoundaryCallback that can be used to ensure the atoms obey the periodicity of the simulation cell.","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"Here, we can show how these callbacks can be used in tandem to alter the course of the simulation. Let's look at a classical dynamics simulation without any extra callbacks:","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"using NQCDynamics\nusing Plots\n\natoms = Atoms(:C)\nmodel = NQCModels.Harmonic()\ncell = PeriodicCell(hcat(50))\nsim = Simulation(atoms, model; cell=cell)\n\nz = DynamicsVariables(sim, hcat(1.0), zeros(1,1))\n\nsolution = run_trajectory(z, (0.0, 300), sim; dt=0.1, output=:position)\nplot(solution, :position, label=\"No callbacks\", legend=true)","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"Now we can introduce callbacks and observe the difference:","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"solution = run_trajectory(z, (0.0, 300), sim; callback=DynamicsUtils.CellBoundaryCallback(), dt=0.1, output=:position)\nplot!(solution, :position, label=\"Cell boundary\" )\n\nusing DiffEqBase: CallbackSet\nterminate(u, t, integrator) = t > 100\ncallbacks = CallbackSet(DynamicsUtils.CellBoundaryCallback(), DynamicsUtils.TerminatingCallback(terminate))\nsolution = run_trajectory(z, (0.0, 300), sim; callback=callbacks, dt=0.1, output=:position)\nplot!(solution, :position, label=\"Cell + termination\")","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"See how the callbacks have altered the dynamics? The atom no longer leaves the simulation cell, and the termination caused the simulation to exit early. ","category":"page"},{"location":"devdocs/diffeq/","page":"DifferentialEquations.jl integration","title":"DifferentialEquations.jl integration","text":"The callback setup we're using is exactly that provided by DifferentialEquations.jl, if you want more details on callbacks, please refer to their documentation.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/classical/#classical-dynamics","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/classical/","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"Classical (molecular) dynamics proceeds by solving the dynamics for a system governed by a classical Hamiltonian containing the kinetic energy of the particles and a potential energy function:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/classical/","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"H = fracP^22M + V(R)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/classical/","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"To integrate the equations we use the VelocityVerlet() algorithm from DifferentialEquations.jl, which is one of the most widely used algorithms for molecular dynamics.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/classical/#Example","page":"Classical molecular dynamics","title":"Example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/classical/","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"We can create two particles with mass = 1 and attach a DiatomicHarmonic interaction which provides a harmonic interatomic potential.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/classical/","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"note: Note\nRecall that the constructor for Simulation(...) when called without a type parameter as below defaults to Simulation{Classical}(...).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/classical/","page":"Classical molecular dynamics","title":"Classical molecular dynamics","text":"using NQCDynamics\nusing Plots\n\nsim = Simulation(Atoms([1, 1]), DiatomicHarmonic())\nv = rand(3, 2)\nu0 = DynamicsVariables(sim, zeros(3, 2), hcat(randn(3), randn(3).+1))\n\ntraj = run_trajectory(u0, (0.0, 1e2), sim; dt=0.1, output=(:position))\n\nplot(traj, :position)","category":"page"},{"location":"api/NQCDynamics/ringpolymers/#RingPolymers","page":"RingPolymers","title":"RingPolymers","text":"","category":"section"},{"location":"api/NQCDynamics/ringpolymers/","page":"RingPolymers","title":"RingPolymers","text":"Modules=[NQCDynamics.RingPolymers]","category":"page"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.RingPolymerParameters-Union{Tuple{T}, Tuple{Integer, Real, AbstractVector{Symbol}, Vector{Symbol}}} where T","page":"RingPolymers","title":"NQCDynamics.RingPolymers.RingPolymerParameters","text":"Constructor for choosing specific elements to be quantum.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.RingPolymerParameters-Union{Tuple{T}, Tuple{Integer, Real, Integer}} where T","page":"RingPolymers","title":"NQCDynamics.RingPolymers.RingPolymerParameters","text":"Constructor for the case where all nuclei are quantum.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.cayley_propagator-Union{Tuple{T}, Tuple{NQCDynamics.RingPolymers.RingPolymerParameters{T}, Real}} where T","page":"RingPolymers","title":"NQCDynamics.RingPolymers.cayley_propagator","text":"cayley_propagator(beads::RingPolymerParameters{T}, dt::Real; half::Bool=true) where {T}\n\nJ. Chem. Phys. 151, 124103 (2019); doi: 10.1063/1.5120282\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.constrain_classical_atoms!-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Any}} where T","page":"RingPolymers","title":"NQCDynamics.RingPolymers.constrain_classical_atoms!","text":"constrain_classical_atoms!(A::AbstractArray{T,3}, classical_atoms) where {T}\n\nMake sure that the classical atoms all have the same values.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.find_rpa-Tuple{Base.Broadcast.Broadcasted}","page":"RingPolymers","title":"NQCDynamics.RingPolymers.find_rpa","text":"A = find_rpa(As) return the first RingPolymerArray among the arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.get_centroid-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T","page":"RingPolymers","title":"NQCDynamics.RingPolymers.get_centroid","text":"Evaluate centroid of ring polymer.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.get_normal_mode_transformation-Tuple{Integer}","page":"RingPolymers","title":"NQCDynamics.RingPolymers.get_normal_mode_transformation","text":"Creates normal mode transformation for n beads.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.get_spring_energy-Tuple{NQCDynamics.RingPolymers.RingPolymerParameters, Any, Any}","page":"RingPolymers","title":"NQCDynamics.RingPolymers.get_spring_energy","text":"get_spring_energy(beads::RingPolymerParameters, masses, R)\n\nCalculate the ring polymer spring potential.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.get_spring_matrix-Tuple{Integer, Real}","page":"RingPolymers","title":"NQCDynamics.RingPolymers.get_spring_matrix","text":"get_L(n_beads, mass, ω_n)\n\nReturn the Circulant symmetric matrix for the ring polymer springs.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ringpolymers/#NQCDynamics.RingPolymers.set_classical!-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Any, Any}} where T","page":"RingPolymers","title":"NQCDynamics.RingPolymers.set_classical!","text":"Copy data from first index into replicas. All classical atoms have repeated values.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ensembles/#Ensembles","page":"Ensembles","title":"Ensembles","text":"","category":"section"},{"location":"api/NQCDynamics/ensembles/","page":"Ensembles","title":"Ensembles","text":"Modules=[NQCDynamics.Ensembles]","category":"page"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles","page":"Ensembles","title":"NQCDynamics.Ensembles","text":"Ensembles\n\nThis module provides the main function run_ensemble. This serves to run multiple trajectories for a given simulation type, sampling from an initial distribution.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.MeanReduction","page":"Ensembles","title":"NQCDynamics.Ensembles.MeanReduction","text":"Average the outputs over all trajectories.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.OrderedSelection","page":"Ensembles","title":"NQCDynamics.Ensembles.OrderedSelection","text":"Select the initial conditions from the distribution in order. \n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.OutputDissociation","page":"Ensembles","title":"NQCDynamics.Ensembles.OutputDissociation","text":"Output a 1 if the molecule has dissociated, 0 otherwise.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.OutputFinal","page":"Ensembles","title":"NQCDynamics.Ensembles.OutputFinal","text":"Output the end point of each trajectory.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.OutputQuantisedDiatomic","page":"Ensembles","title":"NQCDynamics.Ensembles.OutputQuantisedDiatomic","text":"Output the vibrational and rotational quantum numbers of the final image.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.OutputStateResolvedScattering1D","page":"Ensembles","title":"NQCDynamics.Ensembles.OutputStateResolvedScattering1D","text":"Output a ComponentVector with fields reflection and transmission containing the probability of the outcome. Each index in the arrays refers to the adiabatic state.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.RandomSelection","page":"Ensembles","title":"NQCDynamics.Ensembles.RandomSelection","text":"Obtain initial conditions by randomly sampling the distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.SumReduction","page":"Ensembles","title":"NQCDynamics.Ensembles.SumReduction","text":"Sum the outputs from each trajectory.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.Reduction-Tuple{Symbol}","page":"Ensembles","title":"NQCDynamics.Ensembles.Reduction","text":"Reduction(reduction::Symbol)\n\nConverts reduction keyword into function that performs reduction.\n\n:discard is used internally when using callbacks to save outputs instead.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/ensembles/#NQCDynamics.Ensembles.run_ensemble-Tuple{NQCDynamics.AbstractSimulation, Any, Any}","page":"Ensembles","title":"NQCDynamics.Ensembles.run_ensemble","text":"run_ensemble(sim::AbstractSimulation, tspan, distribution;\n    selection::Union{Nothing,AbstractVector}=nothing,\n    output=(sol,i)->(sol,false),\n    reduction=:append\n    reduction::Symbol=:append,\n    ensemble_algorithm=SciMLBase.EnsembleThreads(),\n    algorithm=DynamicsMethods.select_algorithm(sim),\n    saveat=[],\n    trajectories=1,\n    kwargs...\n    )\n\nRun multiple trajectories for timespan tspan sampling from distribution. The DifferentialEquations ensemble interface is used which allows us to specify functions to modify the output and how it is reduced across trajectories.\n\nKeywords\n\nselection should be an AbstractVector containing the indices to sample from the distribution. By default, nothing leads to random sampling.\noutput can be a function that transforms the DiffEq solution to an output, or a tuple of output quantities as for run_trajectory.\nreduction defines how the data is reduced across trajectories. Options are :append, :mean or :sum.\nensemble_algorithm is the algorithm from DifferentialEquations which determines which form of parallelism is used.\nalgorithm is the algorithm used to integrate the equations of motion.\nsaveat mirrors the DiffEq keyword and labels the time points to save the output.\ntrajectories is the number of trajectories to perform.\n\nThis function wraps the EnsembleProblem from DifferentialEquations and passes the kwargs to the solve function.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/nonadiabaticmoleculardynamics/#NQCDynamics","page":"NQCDynamics","title":"NQCDynamics","text":"","category":"section"},{"location":"api/NQCDynamics/nonadiabaticmoleculardynamics/","page":"NQCDynamics","title":"NQCDynamics","text":"Modules=[NQCDynamics]","category":"page"},{"location":"api/NQCDynamics/nonadiabaticmoleculardynamics/#NQCDynamics.Simulation-Union{Tuple{T}, Tuple{M}, Tuple{Atoms{T}, NQCModels.Model, M}} where {M, T}","page":"NQCDynamics","title":"NQCDynamics.Simulation","text":"Simulation(atoms::Atoms{T}, model::Model, method::M;\n    temperature=0u\"K\", cell::AbstractCell=InfiniteCell()) where {M,S,T}\n\nSimulation parameters that controls the types of atoms, interactions, dynamics method, temperature and simulation cell.\n\n\n\n\n\n","category":"method"},{"location":"dynamicssimulations/dynamicsmethods/fssh/#fssh-dynamics","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Tully's FSSH John C. Tully (1990) is one of the most popular methods for nonadiabatic molecular dynamics and is classified as a mixed-quantum classical method, where the nuclei are treated classically and the electrons are treated quantum mechanically.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"The central concept that governs surface hopping methods is that the nuclei evolve on a single adiabatic potential energy surface at any given moment. At each timestep, a hopping probability is evaluated. If the hopping probability is larger than a uniform random number between 0 and 1, the active state is switched and the adiabatic propagation continues on the new electronic state. When this algorithm is applied to an ensemble of trajectories, the discrete adiabatic state  populations approximate the quantum mechanical populations for each state.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"The surface hopping classical Hamiltonian can be written as","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"H(t) = frac12 mathbfP^T mathbfM^-1 mathbfP + sum_i delta(s(t) - i) E_i(mathbfR)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"where mathbfP is the vector of momenta, mathbfR the positions, and mathbfM the diagonal mass matrix. s(t) can be viewed as a digital signal that takes on the value of the currently occupied adiabatic state. As such, this Hamiltonian describes classical dynamics that proceeds under the influence of the potential E_i(mathbfR) when s(t) = i. The summation runs over all adiabatic states.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Of course, to integrate the associated equations of motion, s(t) must be obtained. This quantity is obtained stochastically for each trajectory by making probabilistic hops between surfaces. The probabilities are obtained by integrating the electronic Schrödinger equation alongside the dynamics as","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"ihbar dotc_i(t) = E_i(mathbfR) c_i (t)\n- ihbar sum_j dotmathbfR cdot mathbfd_ij(mathbfR)c_j(t)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"In this equation, c_i(t) are the complex coefficients for state i and mathbfd_ij is the nonadiabatic coupling between adiabatic states i and j. The hopping probability is calculated as","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"gamma_i to j = sum_alpha 2 fracP_alphaM_alpha\nRe(fracsigma_jisigma_ii) d_alpha ij dt","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"At each timestep, a random number between 0 and 1 is generated which is compared to the probabilities. If the probability is higher than the random number, then a hop is attempted.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Additionally in the fewest-switches scheme, the energy is conserved for each trajectory by rescaling the momenta whenever a hop is performed. As such, when a hop is attempted, it will only be successful when there is sufficient kinetic energy for the energy to be conserved after the hop. If there is insufficient kinetic energy, this is termed a frustrated hop, and the dynamics proceeds without performing a hop. When a hop is successful, the kinetic energy is adjusted and s(t) takes on the value of the newly occupied state. For a more detailed description of the algorithm and the momentum rescaling procedure, please refer to Joseph E. Subotnik, Amber Jain, Brian Landry, Andrew Petit, Wenjun Ouyang, Nicole Bellonzi (2016).  In this reference, the notion of reversing the momenta during frustrated hops is discussed. In our implementation we leave the frustrated trajectories unchanged, though it is suggested that the momentum reversal procedure may lead to better results in some cases.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/#Algorithm","page":"Fewest-switches surface hopping (FSSH)","title":"Algorithm","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Integrate classical dynamics for one timestep\nIntegrate electronic dynamics for one timestep\nEvaluate hopping probability\nPerform hop if sufficient probability and kinetic energy\nRescale velocity if hop is performed\nReturn to step 1","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"note: Note\nWith DifferentialEquations.jl we use a callback to perform the surface hopping procedure such that steps 1 and 2 are performed by the DifferentialEquations solvers and steps 3, 4, 5 are performed by the callback.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/#Example","page":"Fewest-switches surface hopping (FSSH)","title":"Example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"In this section we can investigate the results obtained for a single trajectory using FSSH.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"First, the simulation parameters are created. Here, we have a single atom with a mass of 2000 a.u. and we are using Tully's third model (John C. Tully (1990)), provided by NQCModels.jl.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"using Random; Random.seed!(10) # hide\nusing NQCDynamics\n\natoms = Atoms(2000)\nsim = Simulation{FSSH}(atoms, TullyModelThree())","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"The DynamicsVariables constructor has some extra arguments for FSSH. The first three match the classical case, but we also provide the initial state and whether we want this state to be Adiabatic() or Diabatic(). The type of state can be important when considering the ordering of the states. The adiabatic states are always arranged from lowest to highest energy, whereas the diabatic states will be ordered as defined in the model. You can inspect the fields of u to ensure the initilisation has proceeded as you intend.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"u = DynamicsVariables(sim, [20/2000;;], [-10.;;], SingleState(1, Adiabatic()))","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Finally, the trajectory can be run by passing all the parameters we have set up so far. Here, we request both the discrete :state output which is equal to s(t) and  :population, which gives us the population of each diabatic state along the trajectory.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"traj = run_trajectory(u, (0.0, 2000.0), sim, output=(:state, :population))","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Now we can plot s(t) throughout the trajectory. The FSSH algorithm attempts to minimise the total number of hops; in the limit of infinite hops the result would tend to the mean-field (Ehrenfest) result, which is what FSSH attempts to avoid.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"using Plots\nplot(traj, :state)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Similarly, we can plot the diabatic populations. Since FSSH is performed in the adiabatic representation, even in the case of few hops, the diabatic populations can look dramatically different depending on the complexity of the model Hamiltonian. ","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"plot(traj, :population)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/fssh/","page":"Fewest-switches surface hopping (FSSH)","title":"Fewest-switches surface hopping (FSSH)","text":"Another example is available where we use FSSH and other methods to reproduce some of the results from John C. Tully (1990).","category":"page"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels","page":"NQCModels","title":"NQCModels","text":"","category":"section"},{"location":"api/NQCModels/nonadiabaticmodels/","page":"NQCModels","title":"NQCModels","text":"Modules=[NQCModels]","category":"page"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.NQCModels","page":"NQCModels","title":"NQCModels.NQCModels","text":"NQCModels define the potentials and derivatives that govern the dynamics of the particles. These can exist as analytic models or as interfaces to other codes. \n\n\n\n\n\n","category":"module"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.Model","page":"NQCModels","title":"NQCModels.Model","text":"Top-level type for models.\n\nImplementation\n\nWhen adding new models, this should not be directly subtyped. Instead, depending on the intended functionality of the model, one of the child abstract types should be subtyped. If an appropriate type is not already available, a new abstract subtype should be created. \n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.derivative!-Tuple{NQCModels.Model, Any, AbstractMatrix}","page":"NQCModels","title":"NQCModels.derivative!","text":"derivative!(model::Model, D, R::AbstractMatrix)\n\nFill D with the derivative of the electronic potential as a function of the positions R.\n\nThis must be implemented for all models.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.derivative-Tuple{NQCModels.Model, Any}","page":"NQCModels","title":"NQCModels.derivative","text":"derivative(model::Model, R)\n\nAllocating version of derivative!, this definition should be suitable for all models.\n\nImplement zero_derivative to allocate an appropriate array then implement derivative! to fill the array.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.ndofs","page":"NQCModels","title":"NQCModels.ndofs","text":"ndofs(::Model)\n\nGet the number of degrees of freedom for every atom in the model. Usually 1 or 3.\n\n\n\n\n\n","category":"function"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.nstates","page":"NQCModels","title":"NQCModels.nstates","text":"nstates(::Model)\n\nGet the number of electronic states in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.potential!-Tuple{NQCModels.Model, Any, AbstractMatrix}","page":"NQCModels","title":"NQCModels.potential!","text":"potential!(model::Model, V, R::AbstractMatrix)\n\nIn-place version of potential, used only when mutable arrays are preferred.\n\nCurrently used only for LargeDiabaticModels, see diabatic/DiabaticModels.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.potential-Tuple{NQCModels.Model, AbstractMatrix}","page":"NQCModels","title":"NQCModels.potential","text":"potential(model::Model, R::AbstractMatrix)\n\nEvaluate the potential at position R for the given model.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCModels/nonadiabaticmodels/#NQCModels.zero_derivative","page":"NQCModels","title":"NQCModels.zero_derivative","text":"zero_derivative(model::Model, R)\n\nCreate an zeroed array of the right size to match the derivative.\n\n\n\n\n\n","category":"function"},{"location":"api/NQCDynamics/dynamicsutils/#DynamicsUtils","page":"DynamicsUtils","title":"DynamicsUtils","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsutils/","page":"DynamicsUtils","title":"DynamicsUtils","text":"Modules=[NQCDynamics.DynamicsUtils]","category":"page"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils","text":"DynamicsUtils\n\nUtilities for dynamics simulations. Includes:\n\nBasic dynamics variables functions\nDensity matrix dynamics functions\nStandard callbacks to use during dynamics\nPlotting recipes for outputs\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.CellBoundaryCallback-Tuple{}","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils.CellBoundaryCallback","text":"CellBoundaryCallback()\n\nWhenever atoms leave the simulation cell, enforce the periodicity by wrapping the positions at the cell boundary.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.TerminateCellCallback-Tuple{}","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils.TerminateCellCallback","text":"TerminateCellCallback()\n\nIf the atoms leave the simulation cell, terminate the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.TerminatingCallback-Tuple{Any}","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils.TerminatingCallback","text":"TerminatingCallback(func)\n\nProvide a function that returns true when the simulation should terminate.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.apply_interbead_coupling!-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}, RingPolymerSimulation}} where T","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils.apply_interbead_coupling!","text":"apply_interbead_coupling!(du::DynamicalVariables, u::DynamicalVariables,\n                          sim::RingPolymerSimulation)\n\nApplies the force that arises from the harmonic springs between adjacent beads.\n\nOnly applies the force for atoms labelled as quantum within the RingPolymerParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.divide_by_mass!-Tuple{Any, Any}","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils.divide_by_mass!","text":"divide_by_mass!(dv, masses)\n\nDivide the contents of dv by the masses. Assumes dv is an array of size (dofs, atoms) or (dofs, atoms, beads). masses is the vector of masses for each atom that matches length with the second dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsutils/#NQCDynamics.DynamicsUtils.velocity!-NTuple{5, Any}","page":"DynamicsUtils","title":"NQCDynamics.DynamicsUtils.velocity!","text":"velocity!(dr, v, r, sim, t)\n\nWrite the velocity v into dr. Has extra arguments to work with Dynamical(O/S)DEProblems.\n\n\n\n\n\n","category":"method"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/#nrpmd-dynamics","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/#Theory","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Theory","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"Nonadiabatic ring polymer molecular dynamics (NRPMD) is a method that uses the ring polymer formalism to include quantum effects in the nuclear dynamics and mapping variables for the electronic degrees of freedom. (Jeremy O. Richardson, Michael Thoss (2013), Jeremy O. Richardson, Philipp Meyer, Marc-Oliver Pleinert, Michael Thoss (2017), Sutirtha N. Chowdhury, Pengfei Huo (2019)) This results in a classical dynamics in an extended phasespace of the ring polymer with each bead coupled to a set of classical mapping variables. Originally, this method was proposed as a simple combination of the  Meyer-Miller-Stock-Thoss mapping formalism with RPMD but has since been rigorously derived from nonadiabatic Matsubara dynamics (Sutirtha N. Chowdhury, Pengfei Huo (2021)).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"The classical Hamiltonian conserved by NRPMD is given by","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"H_N = sum_alpha=1^N left\nfracP_alpha^22M + V_0(R_alpha)\n+ fracM2beta_N^2hbar^2 (R_alpha - R_alpha-1)^2\n+ frac1hbar sum_nmV_nm(R_alpha)\n(q_alpha_nq_alpha_m + p_alpha_np_alpha_m - delta_nmhbar)\nright","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"which contains N replicas with positions R_alpha and momenta P_alpha joined by harmonic springs. M is the mass, beta_N = beta  N is the inverse temperature scaled by the number of beads. V_0(R_alpha) is the state independent potential. V_nm are the matrix elements of the diabatic potential. The sum runs over all pairs of states. Each replica has a set of mapping variables q_alpha_n and p_alpha_n that interact only within the set associated with a single replica. The consequence of this is that the electronic dynamics is not contaminated by interbead  coupling.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"The equations of motion obtained from this Hamiltonian are","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"beginaligned\ndotR_alpha = fracP_alphaM\n\ndotP_alpha =\n- fracMbeta_N^2 hbar^2(2 R_alpha - R_alpha+1 - R_alpha-1)\n- nabla_R_alpha V_0(R_alpha)\n- frac12hbarsum_nm nabla_R_alpha V_nm(R_alpha)\n(q_alpha_nq_alpha_m + p_alpha_np_alpha_m - delta_nmhbar)\n\ndotq_alpha_n =\nfrac1hbar sum_m V_nm(R_alpha)p_alpha_m\n\ndotp_alpha_n =\n-frac1hbar sum_m V_nm(R_alpha)q_alpha_m\nendaligned","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/#Implementation-details","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Implementation details","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/#Solving-the-differential-equations","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Solving the differential equations","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"For mapping variable methods of this type, a symplectic algorithm (Matthew S. Church, Timothy J. H. Hele, Gregory S. Ezra, Nandini Ananth (2018)) exists. This algorithm has the advantage of long time stability and can be easily combined with the standard algorithms for ring polymer time-evolution. For NRPMD we have implemented this algorithm using the Cayley modified ring polymer propagator (Roman Korol, Nawaf Bou-Rabee, Thomas F. Miller (2019)) and obtain accurate and efficient dynamics. For few beads, similar performance to the OrdinaryDiffEq.jl algorithms is obtained, but as the number of beads increases this algorithm becomes more effective.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/#Generating-the-initial-distribution","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Generating the initial distribution","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"Currently, we provide this functionality only for nonequilibrium simulations where the nuclear part of the distribution is separable from the electronic part. Typically, the nuclear distribution will be sampled using Langevin dynamics or Monte Carlo sampling and the electronic variables are confined to a single electronic state. This is appropriate for modelling photoexcitation dynamics but is not yet suitable for equilibrium simulations. Equilibrium dynamics would require also sampling a thermal distribution for the mapping variables.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/#Form-of-the-Hamiltonian","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Form of the Hamiltonian","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"The diabatic models defined in NQCModels.jl are of the appropriate form for this method though they provide the potential as a single matrix, rather than separating the state-dependent and independent parts. It has been suggested that defining the Hamiltonian such that the lowest eigenvalue of the diabatic matrix is zero everywhere leads to improved convergence in the sampling (Jeremy O. Richardson, Michael Thoss (2013)). However, here we have not done this for simplicity when defining the models.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/#Example","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"Using NRPMD we can reproduce the Fig. 3a in the 2019 paper of Chowdhury and Huo (Sutirtha N. Chowdhury, Pengfei Huo (2019)).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"First we generate a thermal ring polymer distribution in a harmonic potential. A simple way to do this is to use Monte Carlo sampling for the positions and obtain velocities from a Boltzmann distribution.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"using NQCDynamics\n\natom = Atoms(1)\n\nsim = RingPolymerSimulation(atom, Harmonic(dofs=1), 4; temperature=1/16)\n\nr0 = zeros(size(sim))\nsteps = 5e3 # Number of Monte Carlo steps\nstep_size = Dict(:X=>1.0) # Monte Carlo step size for species :X\noutput = InitialConditions.ThermalMonteCarlo.run_advancedmh_sampling(sim, r0, steps, step_size)\nvelocities = BoltzmannVelocityDistribution(1/16, masses(sim), size(sim))\n\ndistribution = DynamicalDistribution(velocities, output, size(sim)) * SingleState(1)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"note: `size(sim)`\nsize(sim) returns the system size as (degrees of freedom, number of atoms, number of beads).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"tip: Monte Carlo sampling\nFurther information on Monte Carlo sampling can be found here.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"We can check the distribution by plotting the phasespace diagram for each of the points in our distribution:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"using CairoMakie\n\nnuclear = distribution.nuclear\nflat_position = reduce(vcat, (p[:] for p in nuclear.position))\nflat_velocity = reduce(vcat, (rand(nuclear.velocity)[:] for p in 1:length(nuclear.position)))\nscatter(flat_position, flat_velocity)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"note: `reduce(vcat, ...)`\nHere we have used reduce in combination with vcat to vertically concatenate all of the information into a single array for plotting.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"The simulation method is given as the type parameter {NRPMD} and the simulation constructor is given the atoms, model, number of beads, temperature and degrees of freedom.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"sim = RingPolymerSimulation{NRPMD}(atom, DoubleWell(γ=0.1), 4; temperature=1/16)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"Next, we can use this distribution as a starting point for the dynamics simulations. This will result in each trajectory starting from a random configuration in the distribution. For NRPMD, the electronic variables are sampled from a Gaussian, independent of the initial electronic state. The electronic state is introduced in the correlation function expression when correlating the initial and final populations.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"The quantities output by the ensemble simulation are specified by the output and the reduction. The output follows the DifferentialEquations format where we provide a function that determines the output of each trajectory. The reduction can be one of :mean, :append, or :sum, which will determine how the data from each trajectory is combined.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"note: Ensemble simulations\nFurther details on ensemble simulations are available here.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"output = TimeCorrelationFunctions.PopulationCorrelationFunction(sim, Diabatic())\nnothing # hide","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"Finally, we can combine the parameters and run the simulation. The resulting plot shows the time dependent population difference and closely matches the figure from the paper we were attempting to reproduce. Nice!","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/nrpmd/","page":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","title":"Nonadiabatic ring polymer molecular dynamics (NRPMD)","text":"ensemble = run_ensemble(sim, (0.0, 30.0), distribution;\n    trajectories=1000, output, reduction=:mean, dt=0.1,\n    u_init=[zeros(2,2) for i=1:length(0:0.1:30.0)])\n\nplt = lines(0:0.1:30, [p[1,1]-p[2,1] for p in ensemble])\nplt.axis.xlabel = \"Time\"\nplt.axis.ylabel = \"Population difference\"\nplt","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/#rpmd-dynamics","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"Ring polymer molecular dynamics is a quantum dynamics methods that attempts to approximate Kubo-transformed real-time correlation functions (Ian R. Craig, David E. Manolopoulos (2004)).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"The idea is to exploit the classical isomorphism that maps a quantum particle onto the extended phasespace of a classical ring polymer. It can be shown that the quantum partition function for a system can be manipulated such that it resembles the classical partition function of a system containing many replicas of the original particle joined to together with harmonic springs in a ring. In the limit of infinite beads or replicas in the ring polymer, the isomorphism becomes exact and it is possible to evaluate quantum expectation values by evaluating ensemble averages for the classical ring polymer system. This is referred to as the field of imaginary-time path integrals and the techniques used are Path Integral Monte Carlo (PIMC) and Path Integral Molecular Dynamics (PIMD) depending on whether molecular dynamics or Monte Carlo methods are used to explore the phasespace (Mark Tuckerman (2010)).","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"RPMD was proposed as a heuristic extension of imaginary-time path integrals to evaluate real-time dynamical quantities. To perform RPMD, it is necessary to solve Hamilton's equations for the ring polymer Hamiltonian:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"H = sum_alpha^N frac12 mathbfP_alpha^T mathbfM mathbfP_alpha\n+ frac12 omega_N^2\n(mathbfR_alpha - mathbfR_alpha+1)^T\nmathbfM\n(mathbfR_alpha - mathbfR_alpha+1)\n+ V(mathbfR_alpha)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"where the ring polymer spring constant omega_N = 1  hbarbeta_N and beta_N = beta  N.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"When the initial distribution is taken as the thermal ring polymer distribution and this Hamiltonian is used to generate configurations at later times, the correlation functions obtained can be used to approximate real-time quantum correlation functions.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/#Example","page":"Ring polymer molecular dynamics (RPMD)","title":"Example","text":"","category":"section"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"Let us perform some simple adiabatic ring polymer dynamics to get a feel for what the ring polymer dynamics looks like.  We set up a 2D system for one hydrogen atom by giving the Free model 2 degrees of freedom and specify that the ring polymer should have 50 beads.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"using NQCDynamics\nusing Unitful\n\natoms = Atoms([:H])\nsim = RingPolymerSimulation(atoms, Free(2), 50; temperature=100u\"K\")","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"note: Atomic units\nRecall that the quantities are always in atomic units unless Unitful.jl has been used to specify alternative units. The temperature here has been specified using Kelvin.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"We initialise the simulation with zero velocity and a random distribution for the ring polymer bead positions. For a real RPMD simulation you will use the thermal ring polymer distribution obtained from a PIMC or Langevin simulation but here for simplicity we use a normally distributed configuration.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"u = DynamicsVariables(sim, zeros(size(sim)), randn(size(sim)))\nnothing # hide","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"tip: Tip\nTo learn how to work with the thermal ring polymer phase space, refer to the Storing and sampling distributions section.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"Now we can run the simulation, for which we use the time interval 0.0 to 500.0 and a time  step of dt = 2.5:","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"dt = 2.5\ntraj = run_trajectory(u, (0.0, 500.0), sim; output=(:position), dt=dt)\nnothing # hide","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"We can visualise this ring polymer trajectory with a 2D scatter plot that shows how the ring polymer evolves in time. Here, we have joined the adjacent beads together with lines, with the end and start beads joined with a different color. This animation shows the cyclic nature of the ring polymer, and how every bead is connected to its two neighbours.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"using CairoMakie\n\nrs = traj.position\n\nindex = Observable(1)\nxs = @lift(rs[$index][1,1,:])\nys = @lift(rs[$index][2,1,:])\nclose_loop_x = @lift([rs[$index][1,1,end], rs[$index][1,1,begin]])\nclose_loop_y = @lift([rs[$index][2,1,end], rs[$index][2,1,begin]])\nfig = scatter(xs, ys, axis = (title = @lift(\"t = $(round(Int, dt*($index-1)))\"),))\nlines!(xs, ys)\nlines!(close_loop_x, close_loop_y)\nxlims!(-3, 3)\nylims!(-3, 3)\n\ntimestamps = 1:length(traj.position)\nfilepath = \"../../assets/figures/rpmd.mp4\" # hide\nrecord(fig, filepath, timestamps;\n        framerate = 30) do i\n    index[] = i\nend\nnothing # hide","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"(Image: rpmd fig)","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"note: Note\nWe have used Makie's animation features to produce this animation. If you want information how Makie works, take a look at the Makie documentation.","category":"page"},{"location":"dynamicssimulations/dynamicsmethods/rpmd/","page":"Ring polymer molecular dynamics (RPMD)","title":"Ring polymer molecular dynamics (RPMD)","text":"Since this package is focused on nonadiabatic dynamics, you won't see much adiabatic RPMD elsewhere in the documentation but it's useful to understand how the original adiabatic version works before moving onto the nonadiabatic extensions.","category":"page"},{"location":"api/NQCDynamics/dynamicsoutputs/#DynamicsOutputs","page":"DynamicsOutputs","title":"DynamicsOutputs","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsoutputs/","page":"DynamicsOutputs","title":"DynamicsOutputs","text":"Here are all the functions that you can specify in the output tuple when using run_trajectory. To add more, simply add a new function in the DynamicsOutputs module. ","category":"page"},{"location":"api/NQCDynamics/dynamicsoutputs/","page":"DynamicsOutputs","title":"DynamicsOutputs","text":"Modules=[NQCDynamics.DynamicsOutputs]\nPrivate=false","category":"page"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs","text":"DynamicsOutputs\n\nInfrastructure for saving quantities during trajectories.\n\nDefines all available options that can be used within the output tuple along with the functions that perform the saving operation.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.adiabatic_population-Tuple{Any, Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.adiabatic_population","text":"Evaluate the adiabatic population\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.centroid_position-Tuple{Any, Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.centroid_position","text":"Get the position of the ring polymer centroid\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.force-Tuple{Any, Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.force","text":"Get the force\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.hamiltonian-Tuple{Any, Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.hamiltonian","text":"Evaluate the classical Hamiltonian\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.kinetic-Tuple{Any, Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.kinetic","text":"Evaluate the classical kinetic energy\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.population-Tuple{Any, Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.population","text":"Evaluate the diabatic population\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.position-Tuple{Any, Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.position","text":"Get the position\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.potential-Tuple{Any, Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.potential","text":"Evaluate the potential from the model\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.quantum_subsystem-Tuple{Any, Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.quantum_subsystem","text":"Get the quantum subsystem of the dynamics variables. Requires that DynamicsUtils.get_quantum_subsystem is implemented for your chosen method.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.state-Tuple{Any, Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.state","text":"Get the currently occupied state from the dynamics variables. Requires that the dynamics variable has a field state. Currently this is for surface hopping methods only. Use population or adiabatic_population for most other methods.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.u-Tuple{Any, Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.u","text":"Get all the dynamics variables. This is the default\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.velocity-Tuple{Any, Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.velocity","text":"Get the velocity\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#Internals","page":"DynamicsOutputs","title":"Internals","text":"","category":"section"},{"location":"api/NQCDynamics/dynamicsoutputs/","page":"DynamicsOutputs","title":"DynamicsOutputs","text":"Modules=[NQCDynamics.DynamicsOutputs]\nPublic=false","category":"page"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputSaver-Tuple{Any, Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputSaver","text":"(output::OutputSaver)(u, t, integrator)\n\nEvaluates every function listed in output.function_names and returns all the results.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.OutputSaver-Union{Tuple{Tuple{Vararg{Symbol, N}}}, Tuple{N}} where N","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.OutputSaver","text":"OutputSaver(function_names::NTuple{N, Symbol}) where {N}\n\nUsed to obtain the outputs for all functions given in function_names.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.centroid_velocity-Tuple{Any, Any, Any}","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.centroid_velocity","text":"Get the velocity of the ring polymer centroid\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.create_saving_callback-Union{Tuple{Tuple{Vararg{Symbol, N}}}, Tuple{N}} where N","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.create_saving_callback","text":"create_saving_callback(quantities::NTuple{N, Symbol}; saveat=[]) where {N}\n\nGet the SavingCallback that will populate saved_values with the result obtained by evaluating the functions provided in function_names.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/dynamicsoutputs/#NQCDynamics.DynamicsOutputs.evaluate_output!-Union{Tuple{F}, Tuple{Any, Any, Any, Any, F, Vararg{Any}}} where F","page":"DynamicsOutputs","title":"NQCDynamics.DynamicsOutputs.evaluate_output!","text":"Used to recursively evaluate every function for the OutputSaver. \n\nSee here for a description of why it is written like this:  https://stackoverflow.com/questions/55840333/type-stability-for-lists-of-closures\n\n\n\n\n\n","category":"method"},{"location":"initialconditions/samplingmethods/langevin/#langevin-sampling","page":"Thermal Langevin dynamics","title":"Thermal Langevin dynamics","text":"","category":"section"},{"location":"initialconditions/samplingmethods/langevin/","page":"Thermal Langevin dynamics","title":"Thermal Langevin dynamics","text":"Thermal initial conditions can be obtained directly from a Langevin dynamics simulations. See the Langevin dynamics page for more info.","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/#mhmc-sampling","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"","category":"section"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Metropolis-Hastings Monte Carlo is a popular method for sampling the canonical distribution for a molecular system. Our implementations uses AdvancedMH.jl from the Turing organisation.","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"For a classical Simulation, the algorithm involves proposing new configurations in a random walk starting from an initial configuration. These are accepted or rejected based upon the Metropolis-Hastings criteria. The result is a Markov chain that samples the canonical distribution.","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/#Example","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Example","text":"","category":"section"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"We can perform the sampling by setting up a classical simulation in the usual way and providing an appropriate initial configuration.","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"using NQCDynamics\nsim = Simulation(Atoms([:H, :H, :H, :H, :H]), Harmonic(); temperature=15)\nr0 = zeros(size(sim))","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Then we must also specify the total number of steps and the size of each step. These can be provided in a dictionary for each species to allow for different step sizes depending on the element in the simulation.","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"steps = 1e4\nstep_size = Dict(:H=>1)","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Now we can run the sampling. The extra keyword argument move_ratio is used to specify the fraction of the system moved during each Monte Carlo step. If we attempt to move the entire system at once, we can expect a very low acceptance ratio, whereas is we move only a single atom, the sampling will take much longer. You will likely have to experiment with this parameter to achieve optimal sampling.","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"using NQCDynamics.InitialConditions: ThermalMonteCarlo\nchain = ThermalMonteCarlo.run_advancedmh_sampling(sim, r0, steps, step_size; move_ratio=0.5)","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Now that our sampling is complete we can evaluate the potential energy expectation value. Here we use the @estimate macro which will evaluate the given function for every configuration inside chain and return the average. Here we can see that the energy we obtain closely matches that predicted by the equipartition theorem.","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Estimators.@estimate potential_energy(sim, chain)\nsim.temperature / 2 * 5","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/#Legacy-version","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Legacy version","text":"","category":"section"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Prior to the use of AdvancedMH.jl, an alternative version of the algorithm was implemented that works for both classical and ring polymer systems. This is currently still included in the code but should be regarded as deprecated and will likely be removed/combined with the AdvancedMH.jl version.","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Here, we use the legacy version to obtain a thermal distribution in a simple model system.","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"using NQCDynamics\nusing Plots","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"First we set up the system in the usual way, here we're using an NO molecule with a harmonic interaction between the atoms. Notice that we use Unitful.jl to specify the temperature.","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"using Unitful\n\natoms = Atoms([:N, :O])\nmodel = DiatomicHarmonic(1.0)\n\nsim = Simulation{Classical}(atoms, model; temperature=300u\"K\")\nnothing # hide","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Then we have to specify the parameters for the Monte Carlo simulation and perform the sampling. Δ contains the step sizes for each of the species, R0 the initial geometry and passes the number of monte carlo passes we perform (passes*n_atoms steps total).","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Δ = Dict([(:N, 0.1), (:O, 0.1)])\nR0 = [1.0 0.0; 0.0 0.0; 0.0 0.0]\npasses = 1000\noutput = InitialConditions.MetropolisHastings.run_monte_carlo_sampling(sim, R0, Δ, passes)\nnothing # hide","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"Output has three fields: the acceptance rates for each species and the energies and geometries obtained during sampling.","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"output.acceptance","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"plot(output.energy)\nxlabel!(\"Step\") # hide\nylabel!(\"Energy\") # hide","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"We can calculate the distance between each atom and plot the bond length throughout the sampling.","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"using LinearAlgebra\nplot([norm(R[:,1] .- R[:,2]) for R in output.R])\nxlabel!(\"Step\") # hide\nylabel!(\"Bond length\") # hide","category":"page"},{"location":"initialconditions/samplingmethods/metropolishastings/","page":"Thermal Metropolis-Hastings Monte Carlo","title":"Thermal Metropolis-Hastings Monte Carlo","text":"The result of this simulation seamlessly interfaces with the DynamicalDistribution presented in the previous section and output.R can be readily passed to provide the position distribution. The Monte Carlo sampling does not include velocities but these can be readily obtained from the Maxwell-Boltzmann distribution.","category":"page"},{"location":"api/NQCModels/cubeldfamodel/#CubeLDFAModel","page":"CubeLDFAModel","title":"CubeLDFAModel","text":"","category":"section"},{"location":"api/NQCModels/cubeldfamodel/","page":"CubeLDFAModel","title":"CubeLDFAModel","text":"Modules=[CubeLDFAModel]","category":"page"},{"location":"api/NQCModels/cubeldfamodel/#CubeLDFAModel.CubeLDFAModel","page":"CubeLDFAModel","title":"CubeLDFAModel.CubeLDFAModel","text":"This uses a cube file to attach friction coefficients to existing models by fitting the data provided by Gerrits et al. in PHYSICAL REVIEW B 102, 155130 (2020).\n\n\n\n\n\n","category":"module"},{"location":"api/NQCModels/cubeldfamodel/#CubeLDFAModel.LDFAModel","page":"CubeLDFAModel","title":"CubeLDFAModel.LDFAModel","text":"LDFAModel(model::Model, filename, atoms, cell;\n          friction_atoms=collect(range(atoms)),\n          )\n\nWrapper for existing models that adds LDFA friction.\n\nThis model uses a cube file to evaluate the electron density used to calculate the friction. This model assumes that the cube file has units of bohr for the grid and cell distances, but provides the density in Å^-3, as is the default in FHI-aims.\n\n\n\n\n\n","category":"type"},{"location":"initialconditions/samplingmethods/ebk/#ebk-sampling","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"","category":"section"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"In surface science, it is often of interest to investigate how collisions with surfaces can perturb the quantum states of molecules. In particular, for diatomic molecules, the rotational and vibrational quantum numbers can undergo significant changes when the molecule impacts the surface.","category":"page"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"Einstein-Brillouinn-Keller (EBK) quantisation allows for a semiclassical investigation into these phenomena by providing a link between the quantum numbers and classical positions and velocities. The quantisation procedure allows the user to generate a classical distribution with a given set of quantum numbers, then perform semiclassical dynamics and extract the quantum numbers at the end by reversing the procedure.","category":"page"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"These three steps can be applied to give insight into the processes taking place during surface scattering and allow us to attempt to predict the experimentally observed change in the quantum numbers.","category":"page"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"A detailed yet approachable description of the theory is given by Andrew J. Larkoski, David G. Ellis, Lorenzo J. Curtis (2006) so we shall not delve into the theory here. Briefly, the procedure for a diatomic molecule involves an optimisation process to find the bounds of an integral, then computing the integral to obtain the vibrational quantum number. The rotational quantum number comes directly from the classical angular momentum of the molecule.","category":"page"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"Configurations can be generated by randomly selecting bond lengths from the appropriate probability distribution and selecting a matching radial velocity.","category":"page"},{"location":"initialconditions/samplingmethods/ebk/#Example","page":"Semiclassical EBK quantisation","title":"Example","text":"","category":"section"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"In this example we will create a quantised distribution suitable for use as initial conditions for hydrogen scattering simulations.","category":"page"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"The simulation can be set up in the usual way, by specifying the atoms along with the model and the simulation cell.","category":"page"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"using NQCDynamics\nusing Unitful, UnitfulAtomic\n\natoms = Atoms([:H, :H])\nmodel = DiatomicHarmonic()\ncell = PeriodicCell(austrip.([5.883 -2.942 0; 0 5.095 0; 0 0 20] .* u\"Å\"))\nsim = Simulation(atoms, model; cell=cell)","category":"page"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"The distribution is generated using the QuantisedDiatomic.generate_configurations function. We have to provide the desired vibrational ν and rotational J quantum numbers, along with the number of samples and some other options as keyword arguments. In addition to the rotational and vibrational energy we have applied a translational impulse of 1 eV and positioned the molecule at a height of 10 bohr.","category":"page"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"using NQCDynamics.InitialConditions: QuantisedDiatomic\n\nν, J = 2, 0\nnsamples = 150\n\nconfigurations = QuantisedDiatomic.generate_configurations(sim, ν, J;\n    samples=nsamples, translational_energy=1u\"eV\", height=10)","category":"page"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"The output contains both the positions and velocities, these can be passed directly to the DynamicalDistribution for use with dynamics. Here however, let's focus on the positions and visualise the distribution.","category":"page"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"This collects the x and y coordinate for each atom:","category":"page"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"r = last.(configurations)\nx = hcat([i[1,:] for i in r]...)\ny = hcat([i[2,:] for i in r]...)","category":"page"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"Now we can plot the distribution using CairoMakie","category":"page"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"using CairoMakie\n\nf = Figure()\nax = Axis(f[1,1], xlabel=\"x coordinate / bohr\", ylabel=\"y coordinate / bohr\")\nax.aspect = AxisAspect(1)\nhidedecorations!(ax; ticks=false, ticklabels=false, label=false)\n\nfor i=1:nsamples\n    lines!([x[1,i], x[2,i]], [y[1,i], y[2,i]], linewidth=5, color=:black)\nend\n\ncolors = rand(nsamples)\nscatter!(x[1,:], y[1,:]; markersize=20, color=colors)\nscatter!(x[2,:], y[2,:]; markersize=20, color=colors)\n\nf","category":"page"},{"location":"initialconditions/samplingmethods/ebk/","page":"Semiclassical EBK quantisation","title":"Semiclassical EBK quantisation","text":"Here we can see that the molecule is randomly distributed within the unit cell. Since we have used a harmonic potential, this could have been produced without using the EBK procedure, but this technique can use any arbitrary potential. In the hydrogen scattering example we build on this example and use the sample procedure to perform scattering simulations starting from this distribution.","category":"page"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NonadiabaticDistributions","page":"NonadiabaticDistributions","title":"NonadiabaticDistributions","text":"","category":"section"},{"location":"api/NQCDynamics/nonadiabaticdistributions/","page":"NonadiabaticDistributions","title":"NonadiabaticDistributions","text":"Modules=[NQCDynamics.NonadiabaticDistributions]","category":"page"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions","text":"NonadiabaticDistributions\n\nModule containing types for representing distributions of combined nuclear and electronic configurations.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions.Adiabatic","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions.Adiabatic","text":"Singleton type for labelling states as adiabatic.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions.BoltzmannVelocityDistribution-Tuple{Any, Any, Any}","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions.BoltzmannVelocityDistribution","text":"BoltzmannVelocityDistribution(temperature, masses)\n\nObtain velocities sampled from the Boltzmann distribution for given temperature and masses.\n\nThis is effectively just a multivariate normal distribution but when combined with the DynamicalDistribution it ensure samples are generated with the correct size. If using for ring polymer dynamics, ensure the temperature is given as nbeads*temperature.\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions.Diabatic","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions.Diabatic","text":"Singleton type for labelling states as diabatic.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions.DynamicalDistribution","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions.DynamicalDistribution","text":"DynamicalDistribution(velocity, position, size)\n\nSampleable that provides positions and velocities sampled from a variety of distributions.\n\nArguments\n\nvelocity and position provide the velocities and positions and can be any type for which select_item has been implemented.\n\nsize denotes to the size of the samples that should be produced.\n\nKeywords\n\nExample\n\nusing NQCDynamics.InitialConditions\nusing Distributions\n\nd = DynamicalDistribution(5.0, Normal(), (1, 1))\nrand(d)\n\n# output\n\nComponentVector{Float64}(v = [5.0;;], r = [0.5314767537831963;;])\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions.ElectronicDistribution","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions.ElectronicDistribution","text":"ElectronicDistribution{S<:StateType} <: NonadiabaticDistribution\n\nAbstract type for distributions of electronic degrees of freedom only.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions.ElectronicPopulation","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions.ElectronicPopulation","text":"ElectronicPopulation{T,S} <: ElectronicDistribution{S}\n\nElectronic distribution for representing a mixed state with non-zero population in multiple states.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions.FermiPopulation","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions.FermiPopulation","text":"FermiPopulation{T,S} <: ElectronicDistribution{S}\n\nElectronic distribution for Fermions following Fermi-Dirac distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions.HarmonicRingPolymer-NTuple{4, Any}","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions.HarmonicRingPolymer","text":"HarmonicRingPolymer(ω, β, m, n_beads)\n\nRing polymer position distribution in a 1D harmonic potential\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions.NonadiabaticDistribution","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions.NonadiabaticDistribution","text":"NonadiabaticDistribution\n\nTop level type for all nonadiabatic distributions.\n\nThese distributions contain a both electronic and nuclear degrees of freedom.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions.SingleState","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions.SingleState","text":"SingleState{S} <: ElectronicDistribution{S}\n\nElectronic distribution for representing a system confined to a single state.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions.MomentumHarmonicWigner-Tuple{Any, Any}","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions.MomentumHarmonicWigner","text":"MomentumHarmonicWigner(ω, β)\n\nWigner distribution in a 1D harmonic potential for the momentum\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions.PositionHarmonicWigner-Tuple{Any, Any, Any}","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions.PositionHarmonicWigner","text":"PositionHarmonicWigner(ω, β)\n\nWigner distribution in a 1D harmonic potential for the position\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions.Q-Tuple{Any, Any}","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions.Q","text":"Quantum corrector for the Wigner distribution\n\n\n\n\n\n","category":"method"},{"location":"api/NQCDynamics/nonadiabaticdistributions/#NQCDynamics.NonadiabaticDistributions.VelocityHarmonicWigner-Tuple{Any, Any, Any}","page":"NonadiabaticDistributions","title":"NQCDynamics.NonadiabaticDistributions.VelocityHarmonicWigner","text":"VelocityHarmonicWigner(ω, β, m)\n\nWigner distribution in a 1D harmonic potential for the velocity\n\n\n\n\n\n","category":"method"},{"location":"NQCModels/frictionmodels/#models-friction","page":"Electronic friction models","title":"Electronic friction models","text":"","category":"section"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"To perform molecular dynamics with electronic friction (MDEF) a specific type of model must be used that provides the friction tensor used to propagate the dynamics.","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"As detailed in the MDEF page, there are two ways to obtain friction values, either from the local density friction approximation (LDFA), or from time-dependent perturbation theory (TDPT). The models on this page describe our existing implementations.","category":"page"},{"location":"NQCModels/frictionmodels/#Analytic-models","page":"Electronic friction models","title":"Analytic models","text":"","category":"section"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"Since ab initio friction calculations are often expensive it is useful to have some models that we can use to test different friction methods. The DiabaticFrictionModel is the abstract type that groups together the diabatic models for which electronic friction can be evaluated. These have many electronic states, modelling the electronic structure characteristic of a metal.  The friction is calculated for these models directly from the nonadiabatic couplings with the equation:","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"γ = 2pihbar sum_j 1dHjjdH1 delta(omega_j)  omega_j","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"where the delta function is approximated by a normalised Gaussian function and the sum runs over the adiabatic states (Connor L. Box, Yaolong Zhang, Rongrong Yin, Bin Jiang, Reinhard J. Maurer (2021)). The matrix elements in this equation are the position derivatives of the diabatic hamiltonian converted to the adiabatic representation.","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"warning: Warning\nThe analytic friction models and the equation above are experimental and subject to change.","category":"page"},{"location":"NQCModels/frictionmodels/#models-cubeldfa","page":"Electronic friction models","title":"CubeLDFAModel.jl","text":"","category":"section"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"Our LDFA implementation is given in CubeLDFAModel.jl which takes a .cube file containing the electron density and evaluates the friction based upon this local density.","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"The model works by fitting the LDA data provided by Nick Gerrits, J. I\\~naki Juaristi, J\\\"org Meyer (2020) that provides the LDFA friction coefficient as a function of the Wigner-Seitz radius. When the model is initialised, the LDA data from Nick Gerrits, J. I\\~naki Juaristi, J\\\"org Meyer (2020) is interpolated using DataInterpolations.jl with a cubic spline. Then, whenever required, the density at the current position is taken directly from the .cube file and converted to the Wigner-Seitz radius with the following relation:","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"r_s(rho) = (frac34pi rho (mathbfr_i))^13","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"Then, the interpolation function is evaluated with this value for the radius, which gives the LDA friction. Optimally, this would be done via an ab initio calculation to get the electron density, but this model instead uses a pre-computed .cube file to get the density with minimal cost. This makes the assumption that the density does not change throughout the dynamics, or that the surface is assumed to be frozen in place.","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"This graph shows how we interpolate the LDA data and evaluate the friction coefficient as a function of the Wigner-Seitz radius. (Image: ldfa graph)","category":"page"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"The reactive scattering example uses this model to investigate the scattering of a diatomic molecule from a metal surface.","category":"page"},{"location":"NQCModels/frictionmodels/#NNInterfaces.jl","page":"Electronic friction models","title":"NNInterfaces.jl","text":"","category":"section"},{"location":"NQCModels/frictionmodels/","page":"Electronic friction models","title":"Electronic friction models","text":"Another way to perform MDEF simulations is the use one of the models from NNInterfaces.jl that uses a neural network to obtain the time-dependent perturbation theory friction from the atomic positions. As with LDFA, one of these models is used in the reactive scattering example.","category":"page"},{"location":"initialconditions/dynamicaldistribution/#Storing-and-sampling-distributions","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"","category":"section"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"In order to perform ensembles of trajectories, it is useful to have a convenient way to generate distributions of velocities and positions which can be sampled to initialise trajectories. The NonadiabaticDistributions module contains the types and functions that seek to address this requirement as painlessly as possible. ","category":"page"},{"location":"initialconditions/dynamicaldistribution/#Nuclear-Distributions","page":"Storing and sampling distributions","title":"Nuclear Distributions","text":"","category":"section"},{"location":"initialconditions/dynamicaldistribution/#DynamicalDistribution","page":"Storing and sampling distributions","title":"DynamicalDistribution","text":"","category":"section"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"When handling distributions for the nuclear degrees of freedom, the DynamicalDistribution type can be used to store initial velocities and positions:","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"using NQCDynamics","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"d = DynamicalDistribution(10, 5, (3, 2))\nnothing # hide","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"Here, we have created a delta distribution with fixed velocities and positions, the final argument specifies the size of each sample. The (3, 2) case shown here would be appropriate when using 2 atoms each with 3 degrees of freedom.","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"rand(d)","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"DynamicalDistribution is flexible and each of the first two arguments can be Real, Vector or Sampleable.","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"note: Note\nReals are used whenever the same value is desired for every sample, as above.\nVectors can be provided when sampling a provided vector of configurations.\nSampleables are provided by Distributions.jl and can be used when specifying an   analytic distribution such as the Maxwell-Boltzmann distribution for velocities.","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"Each of these options can be composed in any combination, let's see the case where we have an analytic distribution of positions and a preset collection of velocities:","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"using Distributions\n\nvelocity = [[1.0 1.0;1.0 1.0], [2.0 2.0; 2.0 2.0], [3.0 3.0; 3.0 3.0]] \nposition = Normal()\nd = DynamicalDistribution(velocity, position, (2, 2))\nrand(d)","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"This has generated normally distributed positions along with one of the three velocities we provided.","category":"page"},{"location":"initialconditions/dynamicaldistribution/#BoltzmannVelocityDistribution","page":"Storing and sampling distributions","title":"BoltzmannVelocityDistribution","text":"","category":"section"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"When performing equilibrium simulations it is often desirable to initialise trajectories when thermal velocities. These can be obtained for each atom from a gaussian distribution of the appropriate width, or alternatively, using the BoltzmannVelocityDistribution which simplifies the process. This takes the temperature, masses and size of the system and ensures the samples you obtain are of the correct shape:","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"using NQCDynamics\nusing Unitful\n\nvelocity = BoltzmannVelocityDistribution(300u\"K\", rand(10), (3, 10))\nrand(velocity)","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"This can be handed directly to the DynamicalDistribution when Boltzmann velocities are required.","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"distribution = DynamicalDistribution(velocity, 1, (3, 10))\nrand(distribution)","category":"page"},{"location":"initialconditions/dynamicaldistribution/#Wigner-distributions","page":"Storing and sampling distributions","title":"Wigner distributions","text":"","category":"section"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"For harmonic oscillator systems, we have implemented the analytic Wigner distribution. These are just mormal distributions of the appropriate width but can be accessed easily as in the following:","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"omega = 1.0;\nbeta = 1e-3;\nmass = 10;\n\ndist = PositionHarmonicWigner(omega, beta, mass, centre=0.0)\nrand(dist)\ndist = VelocityHarmonicWigner(omega, beta, mass)\nrand(dist)","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"These can also be given to the DynamicalDistribution since they are just univariate normal distributions.","category":"page"},{"location":"initialconditions/dynamicaldistribution/#Electronic-distributions","page":"Storing and sampling distributions","title":"Electronic distributions","text":"","category":"section"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"For nonadiabatic dynamics, the initial electronic variables must also be sampled. For this, we can use an ElectronicDistribution which will tell our simulation how we want to sample the initial variables. Currently, two of these are provided, the SingleState and the ElectronicPopulation. The SingleState is used for nonequilibrium simulations when the population is confined to a single state, whereas ElectronicPopulation allows for a mixed state distribution.","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"SingleState(1, Diabatic())\nSingleState(2, Adiabatic())\nElectronicPopulation([1, 2], Diabatic())","category":"page"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"These structs contain only the minimal information about the distributions, whereas the sampling of the distribution is handled separately by each of the different methods.","category":"page"},{"location":"initialconditions/dynamicaldistribution/#Sampling-the-nuclear-distribution","page":"Storing and sampling distributions","title":"Sampling the nuclear distribution","text":"","category":"section"},{"location":"initialconditions/dynamicaldistribution/","page":"Storing and sampling distributions","title":"Storing and sampling distributions","text":"To learn how to generate configurations to use with the DynamicalDistribution, read on to the next sections about the included sampling methods.","category":"page"},{"location":"api/NQCModels/diabaticmodels/#DiabaticModels","page":"DiabaticModels","title":"DiabaticModels","text":"","category":"section"},{"location":"api/NQCModels/diabaticmodels/","page":"DiabaticModels","title":"DiabaticModels","text":"Modules=[NQCModels.DiabaticModels]","category":"page"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels","page":"DiabaticModels","title":"NQCModels.DiabaticModels","text":"DiabaticModels\n\nModels defined within this module subtype the DiabaticModel and provide potentials as Hermitian matrices and derivatives as arrays of Hermitian matrices.\n\n\n\n\n\n","category":"module"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.AltDebyeSpectralDensity","page":"DiabaticModels","title":"NQCModels.DiabaticModels.AltDebyeSpectralDensity","text":"AltDebyeSpectralDensity{T} <: SpectralDensity\n\nStandard Debye spectral density but uses an alternative discretization scheme that requires a cutoff parameter ωᵐ.\n\nReferences\n\nNajeh Rekik, Chang-Yu Hsieh, Holly Freedman, Gabriel Hanna, J. Chem. Phys. 138, 144106 (2013)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.AnanthModelOne","page":"DiabaticModels","title":"NQCModels.DiabaticModels.AnanthModelOne","text":"AnanthModelOne(a=0.01, b=1.6, c=0.005, d=1.0)\n\nAnanth's simple avoided crossing model (similar to Tully's first model) from J. Chem. Phys. 127, 084114 (2007).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.AnanthModelTwo","page":"DiabaticModels","title":"NQCModels.DiabaticModels.AnanthModelTwo","text":"AnanthModelTwo(a=0.04, b=0.01, c=0.005, d=1.0, e=0.7, f=1.6)\n\nAnanth's asymmetric model from J. Chem. Phys. 127, 084114 (2007).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.BosonBath","page":"DiabaticModels","title":"NQCModels.DiabaticModels.BosonBath","text":"BosonBath(density::SpectralDensity, N::Integer)\n\nBosonic bath with given spectral density.\n\nUseful for sampling the bath uncoupled from the spin for spin-boson dynamics.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.DebyeSpectralDensity","page":"DiabaticModels","title":"NQCModels.DiabaticModels.DebyeSpectralDensity","text":"DebyeSpectralDensity{T} <: SpectralDensity\n\nDebye density as detailed in: Xin He, Jian Liu, J. Chem. Phys. 151, 024105 (2019)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.DiabaticFrictionModel","page":"DiabaticModels","title":"NQCModels.DiabaticModels.DiabaticFrictionModel","text":"DiabaticFrictionModel <: LargeDiabaticModel\n\nThese models are defined identically to the LargeDiabaticModel but allocate extra temporary arrays when used with NQCDynamics.jl.\n\nThis allows for the calculation of electronic friction internally from the diabatic potential after diagonalisation and calculation of nonadiabatic couplings.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.DiabaticModel","page":"DiabaticModels","title":"NQCModels.DiabaticModels.DiabaticModel","text":"DiabaticModel <: Model\n\nDiabaticModels are used when a system has multiple electronic states that are presented in the diabatic representation. This is the case for the majority of model systems.\n\nImplementation\n\nDiabaticModels should implement:\n\npotential(model, R)\nderivative!(model, D, R)\nnstates(model)\nndofs(model)\n\nExample\n\nIn this example we create a simple 2 state, 1 dimensional diabatic model MyModel. As noted above, we implement the 4 relevant functions then evaluate the potential. Since this is a 1D model the argument R accepts a Real value.\n\nusing StaticArrays: SMatrix\nusing LinearAlgebra: Hermitian\n\nstruct MyModel <: NQCModels.DiabaticModels.DiabaticModel end\n\nNQCModels.nstates(::MyModel) = 2\nNQCModels.ndofs(::MyModel) = 1\n\nfunction NQCModels.potential(::MyModel, R::Real) \n    V11 = R\n    V22 = -R\n    V12 = 1\n    return Hermitian(SMatrix{2,2}(V11, V12, V12, V22))\nend\n\nfunction NQCModels.derivative!(::MyModel, D, R::Real)\n    return Hermitian(SMatrix{2,2}(1, 0, 0, 1))\nend\n\nmodel = MyModel()\nNQCModels.potential(model, 10)\n\n# output\n\n2×2 Hermitian{Int64, SMatrix{2, 2, Int64, 4}}:\n 10    1\n  1  -10\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.DoubleWell","page":"DiabaticModels","title":"NQCModels.DiabaticModels.DoubleWell","text":"DoubleWell(mass=1, ω=1, γ=1, Δ=1)\n\nTwo state double well, also called the one-dimensional spin-boson model. See: J. Chem. Phys. 150, 244102 (2019)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.ErpenbeckThoss","page":"DiabaticModels","title":"NQCModels.DiabaticModels.ErpenbeckThoss","text":"struct ErpenbeckThoss{T<:AbstractFloat} <: DiabaticModel\n\n1D two-state diabatic system capable of modelling a molecule adsorbed on a metal surface or a single-molecule junction.\n\nIn the two references, all of the parameters are identical except for the particle mass m and the vertical shift c applied to the ϵ₀ state. Both references modify the shift to ensure the quantum ground-state has an energy of 0 eV. Note that the mass m is specified in atomic mass units (amu) not atomic units. We calculate the offset automatically in the constructor from the Morse potential zero-point energy.\n\nReferences\n\nPHYSICAL REVIEW B 97, 235452 (2018)\nJ. Chem. Phys. 151, 191101 (2019)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.GatesHollowayElbow","page":"DiabaticModels","title":"NQCModels.DiabaticModels.GatesHollowayElbow","text":"GatesHollowayElbow()\n\nSimple two state elbow potential from Gates and Holloway: Journal of Electron Spectroscopy and Related Phenomena, 64/65 (1993) 633-639\n\nHas two diabatic states each comprised of the sum of a Morse and a repulsive potential. The coupling between them is an exponential function of z (distance from the surface).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.LargeDiabaticModel","page":"DiabaticModels","title":"NQCModels.DiabaticModels.LargeDiabaticModel","text":"LargeDiabaticModel <: DiabaticModel\n\nSame as the DiabaticModels but uses normal Julia arrays instead of StaticArrays and must implement the inplace potential! rather than potential. This is useful when nstates is very large and StaticArrays are no longer efficient.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.MiaoSubotnik","page":"DiabaticModels","title":"NQCModels.DiabaticModels.MiaoSubotnik","text":"Model MiaoSubotnik according to Miao & Subotnik, J. Chem Phys., 150, 041711 (2019).\nV_0 =  0.5*m*ω^2 x^2\nV_1 =  0.5*m*ω^2 (x-g)^2 + ΔG\nMolecule-metal coupling:\nV = sqrt(\\Gamma*2*W/(2*\\pi*M))\nd is the minimum of the PES, d = g/2 +ΔG/(mω^2g) \n2W is the bandwidth\nIn the original model, m = 2000, ω = 0.0002, g = 20.6097, ΔG = -0.0038 and \nkBT=0.00095. In the paper, Γ, 2W and M were varied and tested.\nThe numbers given as default correspond to the one listed in the paper.\nThe model is defined such that h=(V_0-V_1)d^t d + V_1, however, the diabatic surfaces\nthat they show in the paper in Fig. 1 correspond to the picture implemented below\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.OhmicSpectralDensity","page":"DiabaticModels","title":"NQCModels.DiabaticModels.OhmicSpectralDensity","text":"OhmicSpectralDensity{T} <: SpectralDensity\n\nOhmic density as detailed in: Xin He, Jian Liu, J. Chem. Phys. 151, 024105 (2019)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.OuyangModelOne","page":"DiabaticModels","title":"NQCModels.DiabaticModels.OuyangModelOne","text":"OuyangModelOne(A=0.01, B=1.6, Γ=1e-4, N=10, ΔE=1.6e-2, D=1.0)\n\nModel #1 from Ouyang and Subotnik. See also Ouyang's thesis.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.SpinBoson","page":"DiabaticModels","title":"NQCModels.DiabaticModels.SpinBoson","text":"SpinBoson(density::SpectralDensity, N::Integer, ϵ, Δ)\n\nSpin boson model with N bosons with given spectral density.\n\nReferences\n\nXin He, Jian Liu, J. Chem. Phys. 151, 024105 (2019)\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.ThreeStateMorse","page":"DiabaticModels","title":"NQCModels.DiabaticModels.ThreeStateMorse","text":"ThreeStateMorse()\n\nThree state morse potential referred to as Model IA here: J. Chem. Phys. 150, 244102 (2019) \n\nModels IB and IC retain the same functional form and need only a change of parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.TullyModelOne","page":"DiabaticModels","title":"NQCModels.DiabaticModels.TullyModelOne","text":"TullyModelOne(a=0.01, b=1.6, c=0.005, d=1.0)\n\nTully's simple avoided crossing model from J. Chem. Phys. 93, 1061 (1990).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.TullyModelThree","page":"DiabaticModels","title":"NQCModels.DiabaticModels.TullyModelThree","text":"TullyModelThree(a=0.0006, b=0.1, c=0.9)\n\nTully's extended coupling with reflection model from J. Chem. Phys. 93, 1061 (1990).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.TullyModelTwo","page":"DiabaticModels","title":"NQCModels.DiabaticModels.TullyModelTwo","text":"TullyModelTwo(a=0.1, b=0.28, c=0.015, d=0.06, e=0.05)\n\nTully's dual avoided crossing model from J. Chem. Phys. 93, 1061 (1990).\n\n\n\n\n\n","category":"type"},{"location":"api/NQCModels/diabaticmodels/#NQCModels.DiabaticModels.discretize-Tuple{NQCModels.DiabaticModels.SpectralDensity, Integer}","page":"DiabaticModels","title":"NQCModels.DiabaticModels.discretize","text":"Discretize a given spectral density for N oscillators. Returns frequencies and couplings.\n\n\n\n\n\n","category":"method"},{"location":"NQCModels/ase/#ASE-interface","page":"ASE interface","title":"ASE interface","text":"","category":"section"},{"location":"NQCModels/ase/","page":"ASE interface","title":"ASE interface","text":"The easiest way to obtain potentials and forces from established codes is to use the interfaces implemented in ASE.","category":"page"},{"location":"NQCModels/ase/","page":"ASE interface","title":"ASE interface","text":"We provide the AdiabaticASEModel which wraps an ASE atoms object and its associated calculator to implement the required potential and derivative functions.","category":"page"},{"location":"NQCModels/ase/","page":"ASE interface","title":"ASE interface","text":"note: Note\nThe interface works by calling the relevant Python functions using PyCall. To use PyCall, you must make sure that your python version contains all the relevant packages, such as ase. PyCall can be configured to use a particular pre-installed Python or install its own. Refer to the PyCall README for installation and configuration instructions.","category":"page"},{"location":"NQCModels/ase/#Example","page":"ASE interface","title":"Example","text":"","category":"section"},{"location":"NQCModels/ase/","page":"ASE interface","title":"ASE interface","text":"First, it is necessary to import ase and create the ase.Atoms object and attach the desired calculator. This works exactly as in Python:","category":"page"},{"location":"NQCModels/ase/","page":"ASE interface","title":"ASE interface","text":"using PyCall\n\nase = pyimport(\"ase\")\nemt = pyimport(\"ase.calculators.emt\")\n\nh2 = ase.Atoms(\"H2\", [(0, 0, 0), (0, 0, 0.74)])\nh2.calc = emt.EMT()\nnothing # hide","category":"page"},{"location":"NQCModels/ase/","page":"ASE interface","title":"ASE interface","text":"Next, the AdiabaticASEModel is created by passing the ase.Atoms object directly to the model:","category":"page"},{"location":"NQCModels/ase/","page":"ASE interface","title":"ASE interface","text":"using NQCModels\nmodel = AdiabaticASEModel(h2)","category":"page"},{"location":"NQCModels/ase/","page":"ASE interface","title":"ASE interface","text":"Now the model can be used in the same way as any of the previously introduced analytic models.","category":"page"},{"location":"NQCModels/ase/","page":"ASE interface","title":"ASE interface","text":"potential(model, rand(3, 2))\nderivative(model, rand(3, 2))","category":"page"},{"location":"NQCModels/ase/","page":"ASE interface","title":"ASE interface","text":"tip: Tip\nIn theory, this should work with any of the ASE calculators that correctly implement the get_potential_energy and get_forces functions. For instance, you can use SchNetPack (SPK) by passing their ASE calculator to the AdiabaticASEModel. Take a look at Neural network models to learn more.","category":"page"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To get started with the package we can identify the necessary ingredients to perform a simple classical dynamics simulation and walk through how to set up the simulation.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using NQCDynamics","category":"page"},{"location":"getting_started/#Atoms","page":"Getting started","title":"Atoms","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"First, we must define the particles in the simulation. For this purpose we provide the Atoms  type which will contain the symbols, atomic numbers and masses for our atoms. Technically these need not be actual atoms and be a generic particle.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If using real atoms, then they can be constructed using the chemical symbols as a Vector of Julia's Symbol types, a Vector{Symbol}:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Atoms([:H, :C])","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"You can see that this contains two atoms labelled by their atomic numbers with their masses in atomic units.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"note: Atomic units\nInternally atomic units are used for all quantities. This makes things simple when performing nonadiabatic dynamics. Unitful.jl and UnitfulAtomic.jl can be used to help with unit transformations, and many functions will directly accept Unitful quantities and handle the conversions for you.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Alternatively, if not using real atoms, Atoms can be created using a Vector{<:Real} where the provided numbers are the masses of the particles.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Atoms([1, 2, 3, 4, 5, 6])","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"A more detailed look into the Atoms type along with a description of how to save and load structures can be found here.","category":"page"},{"location":"getting_started/#Representing-atomic-positions-and-velocities","page":"Getting started","title":"Representing atomic positions and velocities","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"This package chooses to separate the dynamical variables from the static atomic parameters included in the Atoms type. This allows us to easily interface with other numerical packages like DifferentialEquations.jl and AdvancedMH.jl. As such, both positions and velocities are represented using Julia's standard Array type, specifically as an Array{T,2} or the Matrix{T} type, which are equivalent. If you are new to Julia, you can find a description of the Array here. The first dimension contains each atomic degree of freedom, and the second dimension contains each atom. For example, a 3D system with two atoms would have positions:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using Symbolics\n@variables x1, y1, z1, x2, y2, z2\nr = [x1 x2;\n     y1 y2;\n     z1 z2]","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"info: Adding external packages\nSymbolics is a package available from the General registry. You will have to add it to your current environment using pkg> add Symbolics to be able to reproduce this example. Throughout the documentation we occasionally use external packages, if you run into an error you will likely have to add the package before being able to use it. Refer to the Julia manual for further information on installing packages.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"For a 1D system it would be necessary to create a 1x1 matrix:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"r = fill(x1, (1,1))","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Velocities are handled in the same way as positions and the data structures are the same. Usually manual initialisation like this will only be necessary for small model systems, whereas full dimensional model system will be read from a file instead. This is explored in the Atoms documentation.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"tip: Ring polymer simulations?\nWe can also perform simulations using ring polymers which have multiple replicas of each atom, these are implemented using Array{T,3} where the third dimension is used for each ring polymer bead. For more information, see the ring polymer methods in the dynamics methods section.","category":"page"},{"location":"getting_started/#Models","page":"Getting started","title":"Models","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The next ingredient required to set up the simulation is the Model, i.e., the potentials in which the system evolves. These Models are provided by NQCModels.jl, which  is a convenient infrastructure for defining different kinds of models for adiabatic and nonadiabatic dynamics. These models can range from simple analytic potentials all the way up to multi-dimensional ab initio potentials. Refer to the NQCModels.jl page for information on the available models and a description of how to implement further models.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"For now we can look at an AdiabaticModel which provides a simple harmonic potential energy function.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"model = Harmonic()","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Here, the four parameters (m, ω, r₀ and dofs) for this model are shown along with their types and default values. These values can be modified by specifying a new value in the constructor. For example for m:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"model = Harmonic(m=0.4)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"tip: Check out Parameters.jl\nMany of the models use Parameters.jl to provide convenient keyword constructors and formatted printing for the models. The Harmonic model above is defined using the @with_kw macro from Parameters.jl to give it a set of default parameters. Each of these can be modified by specifying a new value using keyword arguments in the constructor as demonstrated above.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Adiabatic models implement two functions to calculate the total energy and the forces, respectively: potential(model, R) and derivative(model, R).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Let's try these out and take a look at the results:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"potential(model, hcat(25.0))\nderivative(model, hcat(25.0))","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"note: Why hcat?\nAll models accept an R::AbstractMatrix for the argument representing the positions of the particles in the system. These are structured such that size(R) = (dofs, natoms) where dofs is the number of degrees of freedom for each atom, and natoms is the number of atoms in the  simulation.Since this is a 1D model, we use hcat to quickly create a 1x1 matrix.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To make sure the model is what we expect, we can plot the potential and derivative  using a custom plotting recipe. This looks pretty harmonic to me!","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using Plots\n\nplot(-5:0.1:5, model)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"warning: Warning\nPlotting recipes currently only exist for 1D models. For more complex models you will have to handle the plotting manually.","category":"page"},{"location":"getting_started/#Simulation","page":"Getting started","title":"Simulation","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To control all simulation parameters in one environment, we use the Simulation type which will contain both the Atoms and Models explained above, along with any extra information required for the simulation.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"sim = Simulation{Classical}(Atoms(:H), model)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Here, we have specified that each atom has a single degree of freedom and have not provided a simulation cell. Classical is a type parameter, and specifies the dynamics method that we want to use. Check out Dynamics methods to learn about the other kinds of dynamics available.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"note: Note\nTechnically Simulation(atoms, model) is equivalent to Simulation{Classical}(atoms, model) since Classical is the default.","category":"page"},{"location":"getting_started/#Dynamics-variables","page":"Getting started","title":"Dynamics variables","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The final ingredient before we can perform our simulation is the initial positions and velocities of our particles. For each dynamics type, the method DynamicsVariables is implemented and creates the dynamics variables for us. For classical dynamics we must provide a Matrix of velocities and of positions. These should have size = (dofs, natoms), matching the arguments of the potential and derivative functions. Usually the initial coordinates would have some physical significance, perhaps sampled from a relevant distribution, but here we use random numbers for simplicity.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"v = rand(3, 3);\nr = rand(3, 3);\nDynamicsVariables(sim, v, r)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"note: Note\nSince DifferentialEquations.jl requires AbstractArrays for the dynamics variables, we use ComponentArrays.jl which allow us to conveniently store all the required information for different types of dynamics.","category":"page"},{"location":"getting_started/#Bringing-it-all-together","page":"Getting started","title":"Bringing it all together","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"We have now covered all the parts necessary to perform our first classical dynamics simulation. Let's quickly set up our simulation parameters using what we've learned. Here we'll have two atoms in a harmonic potential, each with a single degree of freedom.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using NQCDynamics # hide\n\natoms = Atoms([:H, :C])\nsim = Simulation{Classical}(atoms, Harmonic(ω=50.0))\nz = DynamicsVariables(sim, randn(size(sim)), randn(size(sim)))\n\nnothing # hide","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Now, we can finally run the trajectory using the run_trajectory function. This takes three positional arguments: the dynamics variables z, the time span we want to solve for tspan, and the simulation parameters sim. For classical dynamics we also provide a timestep dt since we're using the VelocityVerlet algorithm by default.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"note: Integration algorithms\nEach method will default to an appropriate integration algorithm though it is possible to specify via a keyword argument to run_trajectory if an alternative algorithm is preferred. Refer to the dynamics documentation for more information.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The final keyword argument output is used to specify the quantities we want to save during the dynamics. A list of the available quantities can be found here.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"tip: Output format\nrun_trajectory returns a Table from TypedTables.jl that has columns containing the time and the output quantities saved at each time. By default, it outputs the value of the dynamics variables into the field u.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"tspan = (0.0, 50.0)\nsolution = run_trajectory(z, (0.0, 50.0), sim;\n                                   dt=0.1, output=(:position, :velocity))","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Here you can see the output table with columns for the time and the output quantities we specified. These can be accessed directly as shown here:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"solution.t\nsolution.position","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"As with the models, we provide custom plotting recipes to quickly visualise the results before performing further analysis by manually accessing the fields of the solution table. To use these recipes, simply provide the solution to the plot function from Plots.jl and give the name of the output quantity as the second argument. This will only work if this quantity was specified in run_trajectory.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using Plots # hide\nplot(solution, :position)\nplot!(solution, :velocity)","category":"page"},{"location":"getting_started/#Ensemble-simulations","page":"Getting started","title":"Ensemble simulations","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"So we have solved a single trajectory? That's pretty cool but wouldn't it be great if we could do a whole bunch at once? Well, fortunately we can thanks to the Ensembles module.  This provides run_ensemble which can be used to perform many trajectories in parallel. To learn more and see some examples, refer to the Ensemble simulations section.","category":"page"},{"location":"getting_started/#What's-next?","page":"Getting started","title":"What's next?","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Now that we've covered the basics of classical dynamics, we're ready to explore the world of nonadiabatic dynamics. All the dynamics methods follow these patterns and anything you find elsewhere in the documentation should now seem relatively familiar.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/#dynamicssimulations","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"Performing dynamics simulations is at the core of this package's functionality (as you might have guessed from the name). This section of the documentation will describe how to perform dynamics simulations, building on the introduction from Getting started.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"Since we use DifferentialEquations to perform the dynamics, it is most natural to split up the system parameters from the dynamics variables. This manifests itself as two separate data types: the Simulation, and the DynamicsVariables.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"info: Info\nIf you intend to implement a new dynamics method, we recommend reading DifferentialEquations.jl to understand more deeply how this package works.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"The Simulation holds all the static information about the system: the atoms, the model, the temperature, the cell and the dynamics method.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"using NQCDynamics # hide\natoms = Atoms(2000) # Single atom with mass = 2000 a.u.\nsim = Simulation{Ehrenfest}(atoms, TullyModelOne(); temperature=0, cell=InfiniteCell())","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"Here we have initialised the simulation parameters, including the default temperature and cell explicitly. sim takes the place of the p parameter seen throughout DifferentialEquations.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"For DifferentialEquations to allow for a wide variety of solvers,  the input arrays DynamicsVariables must be AbstractArrays. In nonadiabatic dynamics simulations, we usually have different groups of variables that behave in particular ways. For example: for mapping variable methods we have positions, velocities, and two sets of mapping variables representing the electronic degrees of freedom.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"For this purpose we use the ComponentVector, which allows us to arbitrarily partition the variables into their subgroups. This allows us to keep all the variables in a single array as required by DifferentialEquations, whilst still having them partitioned for convenient computation and readable code.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"v0 = hcat(10) / 2000\nr0 = hcat(-5)\nu0 = DynamicsVariables(sim, v0, r0, SingleState(1))","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"Since each dynamics method has a different set of variables, each method implements DynamicsVariables(sim, args...), which will convert the input into the correct structure. This helps to ensure each method follows a similar workflow, making it easy to switch between different methods. The output of this function takes the place of the u argument seen throughout DifferentialEquations.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"With both the Simulation and DynamicsVariables in hand, the central function is run_trajectory which allows us to perform a single dynamics trajectory. run_trajectory takes the simulation parameters sim and the initial conditions u0, along with a time span tspan that the trajectory will cover.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"tspan = (0.0, 2000.0)\nrun_trajectory(u0, tspan, sim)","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"By default, we can see that the output contains both t and u. These are the time and dynamics variables respectively. By passing a Tuple to the output keyword argument we can ask for specific quantities.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"out = run_trajectory(u0, tspan, sim; output=(:position, :adiabatic_population))","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"The quantities that are available are listed here. Adding more quantities requires that a new function is defined inside the DynamicsOutputs module that has the same set of parameters as the existing quantities.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"This time we can see that the output contains only the quantities that we asked for.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"using Plots\nplot(out, :position)","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"plot(out, :adiabatic_population)","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"note: Note\nHere we have used a special plot recipe that will automatically plot any quantity against time. This is useful when investigating the results of a single trajectory.","category":"page"},{"location":"dynamicssimulations/dynamicssimulations/","page":"Introduction","title":"Introduction","text":"All of the dynamics methods work in a similar way. For details on a specific method along with examples, please see the method specific page in the sidebar under Dynamics methods.","category":"page"}]
}
